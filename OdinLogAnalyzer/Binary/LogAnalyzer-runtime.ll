; ModuleID = 'LogAnalyzer-runtime'
source_filename = "LogAnalyzer-runtime"
target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-windows-msvc"

%"runtime::Source_Code_Location" = type { %..string, i32, i32, %..string }
%..string = type { ptr, i64 }
%"runtime::Default_Random_State" = type { i64, i64 }
%"runtime::Default_Temp_Allocator" = type { %"runtime::Arena" }
%"runtime::Arena" = type { %"runtime::Allocator", ptr, i64, i64, i64, i64 }
%"runtime::Allocator" = type { ptr, ptr }
%"runtime::Map_Cell_Info" = type { i64, i64, i64, i64 }
%"runtime::Map_Info" = type { ptr, ptr, ptr, ptr }
%"runtime::string_decode_rune::Accept_Range::$1" = type { i8, i8 }
%"runtime::Raw_String" = type { ptr, i64 }
%"runtime::Memory_Block" = type { ptr, %"runtime::Allocator", ptr, i64, i64 }
%"runtime::Context" = type { %"runtime::Allocator", %"runtime::Allocator", ptr, %"runtime::Logger", %"runtime::Random_Generator", ptr, i64, ptr }
%"runtime::Logger" = type { ptr, ptr, i64, i16, [6 x i8] }
%"runtime::Random_Generator" = type { ptr, ptr }
%"runtime::Arena_Temp" = type { ptr, ptr, i64 }
%"runtime::Type_Info_Parameters" = type { { ptr, i64 }, { ptr, i64 } }
%"runtime::Type_Info" = type { i64, i64, i32, [4 x i8], i64, { [9 x i64], i64 } }
%"runtime::Type_Info_Named" = type { %..string, ptr, %..string, ptr }
%"runtime::Type_Info_Integer" = type { i8, i8 }
%"runtime::Type_Info_Pointer" = type { ptr }
%"runtime::Type_Info_Multi_Pointer" = type { ptr }
%"runtime::Type_Info_Soa_Pointer" = type { ptr }
%"runtime::Type_Info_Procedure" = type { ptr, ptr, i8, i8, [6 x i8] }
%"runtime::Type_Info_Array" = type { ptr, i64, i64 }
%"runtime::Type_Info_Enumerated_Array" = type { ptr, ptr, i64, i64, i64, i64, i8, [7 x i8] }
%"runtime::Type_Info_Dynamic_Array" = type { ptr, i64 }
%"runtime::Type_Info_Slice" = type { ptr, i64 }
%"runtime::Type_Info_Map" = type { ptr, ptr, ptr }
%"runtime::Type_Info_Struct" = type { ptr, ptr, ptr, ptr, ptr, i32, i8, i8, [2 x i8], i32, [4 x i8], ptr, ptr }
%"runtime::Type_Info_Union" = type { { ptr, i64 }, i64, ptr, ptr, i8, i8, i8, [5 x i8] }
%"runtime::Type_Info_Enum" = type { ptr, { ptr, i64 }, { ptr, i64 } }
%"runtime::Type_Info_Bit_Set" = type { ptr, ptr, i64, i64 }
%"runtime::Type_Info_Bit_Field" = type { ptr, ptr, ptr, ptr, ptr, ptr, i64 }
%"runtime::Type_Info_Simd_Vector" = type { ptr, i64, i64 }
%"runtime::Type_Info_Matrix" = type { ptr, i64, i64, i64, i64, i8, [7 x i8] }
%"runtime::Raw_Dynamic_Array" = type { ptr, i64, i64, %"runtime::Allocator" }
%"runtime::Raw_Map" = type { i64, i64, %"runtime::Allocator" }
%"runtime::Raw_Slice" = type { ptr, i64 }
%"text_analyzer::Filter" = type { i64, %..string, i8, i8, [6 x i8] }
%"text_analyzer::Highlight" = type { i64, %..string, [4 x i8], i8, [3 x i8] }
%"text_analyzer::DisplayLine" = type { i64, i8, [7 x i8], %..string }
%"runtime::gnu_h2f_ieee::fp32::$1" = type { i32 }
%..any = type { ptr, i64 }

@"csbs$LogAnalyzer-runtime$0" = private constant [16 x i8] c"block.used == 0\00", align 1
@"csbs$LogAnalyzer-runtime$1" = private constant [62 x i8] c"C:/MyCode/Odin/base/runtime/default_temp_allocator_arena.odin\00", align 1
@"csbs$LogAnalyzer-runtime$2" = private constant [19 x i8] c"memory_block_alloc\00", align 1
@"scl$[memory_block_alloc1638]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$LogAnalyzer-runtime$1", i64 61 }, i32 50, i32 2, %..string { ptr @"csbs$LogAnalyzer-runtime$2", i64 18 } }
@"ggv$runtime::memory_block_alloc$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$0", i64 15 }
@"csbs$LogAnalyzer-runtime$3" = private constant [18 x i8] c"block.prev == nil\00", align 1
@"scl$[memory_block_alloc1664]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$LogAnalyzer-runtime$1", i64 61 }, i32 51, i32 2, %..string { ptr @"csbs$LogAnalyzer-runtime$2", i64 18 } }
@"ggv$runtime::memory_block_alloc$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$3", i64 17 }
@"csbs$LogAnalyzer-runtime$4" = private constant [61 x i8] c"C:/MyCode/Odin/base/runtime/default_temporary_allocator.odin\00", align 1
@"csbs$LogAnalyzer-runtime$5" = private constant [31 x i8] c"default_temp_allocator_destroy\00", align 1
@"scl$[default_temp_allocator_destroy1111]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$LogAnalyzer-runtime$4", i64 60 }, i32 33, i32 4, %..string { ptr @"csbs$LogAnalyzer-runtime$5", i64 30 } }
@"runtime::default_random_generator_proc-.global_rand_seed-40933" = thread_local global %"runtime::Default_Random_State" zeroinitializer, align 8
@"csbs$LogAnalyzer-runtime$6" = private constant [1 x i8] zeroinitializer, align 1
@"csbs$LogAnalyzer-runtime$7" = private constant [24 x i8] c" Invalid slice indices \00", align 1
@"ggv$runtime::slice_handle_error$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$7", i64 23 }
@"csbs$LogAnalyzer-runtime$8" = private constant [2 x i8] c":\00", align 1
@"ggv$runtime::slice_handle_error$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$8", i64 1 }
@"csbs$LogAnalyzer-runtime$9" = private constant [22 x i8] c" is out of range 0..<\00", align 1
@"ggv$runtime::slice_handle_error$3" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$9", i64 21 }
@"runtime::args__" = external global { ptr, i64 }
@"csbs$LogAnalyzer-runtime$a" = private constant [47 x i8] c"C:/MyCode/Odin/base/runtime/entry_windows.odin\00", align 1
@"ggv$main$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$a", i64 46 }
@"ggv$runtime::multi_pointer_slice_handle_error$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$7", i64 23 }
@"ggv$runtime::multi_pointer_slice_handle_error$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$8", i64 1 }
@"runtime::global_default_temp_allocator_data" = external thread_local global %"runtime::Default_Temp_Allocator"
@"ggv$runtime::alloc_from_memory_block$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$1", i64 61 }
@"csbs$LogAnalyzer-runtime$b" = private constant [27 x i8] c"non-power of two alignment\00", align 1
@"ggv$runtime::arena_alloc$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$b", i64 26 }
@"csbs$LogAnalyzer-runtime$c" = private constant [33 x i8] c"Alignment must be a power of two\00", align 1
@"ggv$runtime::mem_alloc_bytes$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$c", i64 32 }
@"csbs$LogAnalyzer-runtime$d" = private constant [3 x i8] c"\\a\00", align 1
@"ggv$runtime::print_encoded_rune$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$d", i64 2 }
@"csbs$LogAnalyzer-runtime$e" = private constant [3 x i8] c"\\b\00", align 1
@"ggv$runtime::print_encoded_rune$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$e", i64 2 }
@"csbs$LogAnalyzer-runtime$f" = private constant [3 x i8] c"\\e\00", align 1
@"ggv$runtime::print_encoded_rune$3" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$f", i64 2 }
@"csbs$LogAnalyzer-runtime$10" = private constant [3 x i8] c"\\f\00", align 1
@"ggv$runtime::print_encoded_rune$4" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$10", i64 2 }
@"csbs$LogAnalyzer-runtime$11" = private constant [3 x i8] c"\\n\00", align 1
@"ggv$runtime::print_encoded_rune$5" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$11", i64 2 }
@"csbs$LogAnalyzer-runtime$12" = private constant [3 x i8] c"\\r\00", align 1
@"ggv$runtime::print_encoded_rune$6" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$12", i64 2 }
@"csbs$LogAnalyzer-runtime$13" = private constant [3 x i8] c"\\t\00", align 1
@"ggv$runtime::print_encoded_rune$7" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$13", i64 2 }
@"csbs$LogAnalyzer-runtime$14" = private constant [3 x i8] c"\\v\00", align 1
@"ggv$runtime::print_encoded_rune$8" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$14", i64 2 }
@"csbs$LogAnalyzer-runtime$15" = private constant [5 x i8] c"\\x00\00", align 1
@"ggv$runtime::print_encoded_rune$9" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$15", i64 4 }
@"csbs$LogAnalyzer-runtime$16" = private constant [3 x i8] c"\\x\00", align 1
@"ggv$runtime::print_encoded_rune$10" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$16", i64 2 }
@"runtime::[print.odin]::_INTEGER_DIGITS_VAR" = external global %..string
@"csbs$LogAnalyzer-runtime$17" = private constant [39 x i8] c"C:/MyCode/Odin/base/runtime/print.odin\00", align 1
@"ggv$runtime::print_encoded_rune$11" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$17", i64 38 }
@"ggv$runtime::print_encoded_rune$12" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$17", i64 38 }
@"ggv$runtime::mem_alloc$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$c", i64 32 }
@"ggv$runtime::mem_alloc_non_zeroed$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$c", i64 32 }
@"ggv$runtime::_mem_resize$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$c", i64 32 }
@"csbs$LogAnalyzer-runtime$18" = private constant [42 x i8] c"C:/MyCode/Odin/base/runtime/internal.odin\00", align 1
@"ggv$runtime::_mem_resize$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$18", i64 41 }
@"ggv$runtime::_mem_resize$3" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$18", i64 41 }
@"csbs$LogAnalyzer-runtime$19" = private constant [4 x i8] c"nil\00", align 1
@"ggv$runtime::print_typeid$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$19", i64 3 }
@"ggv$runtime::print_type$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$19", i64 3 }
@"csbs$LogAnalyzer-runtime$1a" = private constant [4 x i8] c"int\00", align 1
@"ggv$runtime::print_type$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$1a", i64 3 }
@"csbs$LogAnalyzer-runtime$1b" = private constant [5 x i8] c"uint\00", align 1
@"ggv$runtime::print_type$3" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$1b", i64 4 }
@"csbs$LogAnalyzer-runtime$1c" = private constant [8 x i8] c"uintptr\00", align 1
@"ggv$runtime::print_type$4" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$1c", i64 7 }
@"csbs$LogAnalyzer-runtime$1d" = private constant [5 x i8] c"rune\00", align 1
@"ggv$runtime::print_type$5" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$1d", i64 4 }
@"csbs$LogAnalyzer-runtime$1e" = private constant [8 x i8] c"complex\00", align 1
@"ggv$runtime::print_type$6" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$1e", i64 7 }
@"csbs$LogAnalyzer-runtime$1f" = private constant [11 x i8] c"quaternion\00", align 1
@"ggv$runtime::print_type$7" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$1f", i64 10 }
@"csbs$LogAnalyzer-runtime$20" = private constant [7 x i8] c"string\00", align 1
@"ggv$runtime::print_type$8" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$20", i64 6 }
@"csbs$LogAnalyzer-runtime$21" = private constant [5 x i8] c"bool\00", align 1
@"ggv$runtime::print_type$9" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$21", i64 4 }
@"csbs$LogAnalyzer-runtime$22" = private constant [4 x i8] c"any\00", align 1
@"ggv$runtime::print_type$10" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$22", i64 3 }
@"csbs$LogAnalyzer-runtime$23" = private constant [7 x i8] c"typeid\00", align 1
@"ggv$runtime::print_type$11" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$23", i64 6 }
@"csbs$LogAnalyzer-runtime$24" = private constant [7 x i8] c"rawptr\00", align 1
@"ggv$runtime::print_type$12" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$24", i64 6 }
@"csbs$LogAnalyzer-runtime$25" = private constant [2 x i8] c"^\00", align 1
@"ggv$runtime::print_type$13" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$25", i64 1 }
@"csbs$LogAnalyzer-runtime$26" = private constant [4 x i8] c"[^]\00", align 1
@"ggv$runtime::print_type$14" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$26", i64 3 }
@"csbs$LogAnalyzer-runtime$27" = private constant [7 x i8] c"#soa ^\00", align 1
@"ggv$runtime::print_type$15" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$27", i64 6 }
@"csbs$LogAnalyzer-runtime$28" = private constant [5 x i8] c"proc\00", align 1
@"ggv$runtime::print_type$16" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$28", i64 4 }
@"csbs$LogAnalyzer-runtime$29" = private constant [3 x i8] c"()\00", align 1
@"ggv$runtime::print_type$17" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$29", i64 2 }
@"ggv$runtime::print_type$18" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$17", i64 38 }
@"csbs$LogAnalyzer-runtime$2a" = private constant [3 x i8] c", \00", align 1
@"ggv$runtime::print_type$19" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2a", i64 2 }
@"csbs$LogAnalyzer-runtime$2b" = private constant [2 x i8] c")\00", align 1
@"ggv$runtime::print_type$20" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2b", i64 1 }
@"csbs$LogAnalyzer-runtime$2c" = private constant [5 x i8] c" -> \00", align 1
@"ggv$runtime::print_type$21" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2c", i64 4 }
@"ggv$runtime::print_type$22" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2a", i64 2 }
@"ggv$runtime::print_type$23" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$17", i64 38 }
@"csbs$LogAnalyzer-runtime$2d" = private constant [3 x i8] c": \00", align 1
@"ggv$runtime::print_type$24" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2d", i64 2 }
@"ggv$runtime::print_type$25" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2b", i64 1 }
@"csbs$LogAnalyzer-runtime$2e" = private constant [8 x i8] c"#sparse\00", align 1
@"ggv$runtime::print_type$26" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2e", i64 7 }
@"csbs$LogAnalyzer-runtime$2f" = private constant [10 x i8] c"[dynamic]\00", align 1
@"ggv$runtime::print_type$27" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2f", i64 9 }
@"csbs$LogAnalyzer-runtime$30" = private constant [3 x i8] c"[]\00", align 1
@"ggv$runtime::print_type$28" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$30", i64 2 }
@"csbs$LogAnalyzer-runtime$31" = private constant [5 x i8] c"map[\00", align 1
@"ggv$runtime::print_type$29" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$31", i64 4 }
@"csbs$LogAnalyzer-runtime$32" = private constant [6 x i8] c"#soa[\00", align 1
@"ggv$runtime::print_type$30" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$32", i64 5 }
@"csbs$LogAnalyzer-runtime$33" = private constant [7 x i8] c"#soa[]\00", align 1
@"ggv$runtime::print_type$31" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$33", i64 6 }
@"csbs$LogAnalyzer-runtime$34" = private constant [14 x i8] c"#soa[dynamic]\00", align 1
@"ggv$runtime::print_type$32" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$34", i64 13 }
@"csbs$LogAnalyzer-runtime$35" = private constant [8 x i8] c"struct \00", align 1
@"ggv$runtime::print_type$33" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$35", i64 7 }
@"csbs$LogAnalyzer-runtime$36" = private constant [9 x i8] c"#packed \00", align 1
@"ggv$runtime::print_type$34" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$36", i64 8 }
@"csbs$LogAnalyzer-runtime$37" = private constant [12 x i8] c"#raw_union \00", align 1
@"ggv$runtime::print_type$35" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$37", i64 11 }
@"csbs$LogAnalyzer-runtime$38" = private constant [10 x i8] c"#no_copy \00", align 1
@"ggv$runtime::print_type$36" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$38", i64 9 }
@"csbs$LogAnalyzer-runtime$39" = private constant [8 x i8] c"#align(\00", align 1
@"ggv$runtime::print_type$37" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$39", i64 7 }
@"csbs$LogAnalyzer-runtime$3a" = private constant [3 x i8] c") \00", align 1
@"ggv$runtime::print_type$38" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$3a", i64 2 }
@"ggv$runtime::print_type$39" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$17", i64 38 }
@"ggv$runtime::print_type$40" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2a", i64 2 }
@"ggv$runtime::print_type$41" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2d", i64 2 }
@"csbs$LogAnalyzer-runtime$3b" = private constant [7 x i8] c"union \00", align 1
@"ggv$runtime::print_type$42" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$3b", i64 6 }
@"ggv$runtime::print_type$43" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$39", i64 7 }
@"ggv$runtime::print_type$44" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$3a", i64 2 }
@"csbs$LogAnalyzer-runtime$3c" = private constant [9 x i8] c"#no_nil \00", align 1
@"ggv$runtime::print_type$45" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$3c", i64 8 }
@"ggv$runtime::print_type$46" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2a", i64 2 }
@"csbs$LogAnalyzer-runtime$3d" = private constant [2 x i8] c"}\00", align 1
@"ggv$runtime::print_type$47" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$3d", i64 1 }
@"csbs$LogAnalyzer-runtime$3e" = private constant [6 x i8] c"enum \00", align 1
@"ggv$runtime::print_type$48" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$3e", i64 5 }
@"csbs$LogAnalyzer-runtime$3f" = private constant [3 x i8] c" {\00", align 1
@"ggv$runtime::print_type$49" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$3f", i64 2 }
@"ggv$runtime::print_type$50" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2a", i64 2 }
@"ggv$runtime::print_type$51" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$3d", i64 1 }
@"csbs$LogAnalyzer-runtime$40" = private constant [9 x i8] c"bit_set[\00", align 1
@"ggv$runtime::print_type$52" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$40", i64 8 }
@"csbs$LogAnalyzer-runtime$41" = private constant [3 x i8] c"..\00", align 1
@"ggv$runtime::print_type$53" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$41", i64 2 }
@"ggv$runtime::print_type$54" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$41", i64 2 }
@"csbs$LogAnalyzer-runtime$42" = private constant [3 x i8] c"; \00", align 1
@"ggv$runtime::print_type$55" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$42", i64 2 }
@"csbs$LogAnalyzer-runtime$43" = private constant [11 x i8] c"bit_field \00", align 1
@"ggv$runtime::print_type$56" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$43", i64 10 }
@"ggv$runtime::print_type$57" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$3f", i64 2 }
@"ggv$runtime::print_type$58" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$17", i64 38 }
@"ggv$runtime::print_type$59" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2a", i64 2 }
@"ggv$runtime::print_type$60" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2d", i64 2 }
@"csbs$LogAnalyzer-runtime$44" = private constant [4 x i8] c" | \00", align 1
@"ggv$runtime::print_type$61" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$44", i64 3 }
@"csbs$LogAnalyzer-runtime$45" = private constant [7 x i8] c"#simd[\00", align 1
@"ggv$runtime::print_type$62" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$45", i64 6 }
@"csbs$LogAnalyzer-runtime$46" = private constant [8 x i8] c"matrix[\00", align 1
@"ggv$runtime::print_type$63" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$46", i64 7 }
@"ggv$runtime::print_type$64" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2a", i64 2 }
@"csbs$LogAnalyzer-runtime$47" = private constant [2 x i8] c"]\00", align 1
@"ggv$runtime::print_type$65" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$47", i64 1 }
@"ggv$runtime::arena_allocator_proc$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$1", i64 61 }
@"ggv$runtime::arena_allocator_proc$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$1", i64 61 }
@"ggv$runtime::arena_allocator_proc$3" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$1", i64 61 }
@"ggv$runtime::arena_allocator_proc$4" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$1", i64 61 }
@"ggv$map_cell_info-3143511548502526014" = private constant %"runtime::Map_Cell_Info" { i64 8, i64 8, i64 64, i64 8 }
@"ggv$map_cell_info-14785269867199075517" = private constant %"runtime::Map_Cell_Info" { i64 1, i64 1, i64 64, i64 64 }
@"ggv$map_info-9128505474150644346" = private constant %"runtime::Map_Info" { ptr @"ggv$map_cell_info-3143511548502526014", ptr @"ggv$map_cell_info-14785269867199075517", ptr @"__$hasher-3143511548502526014", ptr @"__$equal-3143511548502526014" }
@"ggv$runtime::mem_resize$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$c", i64 32 }
@"ggv$runtime::non_zero_mem_resize$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$c", i64 32 }
@"csbs$LogAnalyzer-runtime$48" = private constant [10 x i8] c"nil arena\00", align 1
@"ggv$runtime::arena_temp_begin$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$48", i64 9 }
@"csbs$LogAnalyzer-runtime$49" = private constant [18 x i8] c"temp.block == nil\00", align 1
@"csbs$LogAnalyzer-runtime$4a" = private constant [15 x i8] c"arena_temp_end\00", align 1
@"scl$[arena_temp_end8667]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$LogAnalyzer-runtime$1", i64 61 }, i32 283, i32 3, %..string { ptr @"csbs$LogAnalyzer-runtime$4a", i64 14 } }
@"ggv$runtime::arena_temp_end$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$49", i64 17 }
@"csbs$LogAnalyzer-runtime$4b" = private constant [15 x i8] c"temp.used == 0\00", align 1
@"scl$[arena_temp_end8696]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$LogAnalyzer-runtime$1", i64 61 }, i32 284, i32 3, %..string { ptr @"csbs$LogAnalyzer-runtime$4a", i64 14 } }
@"ggv$runtime::arena_temp_end$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$4b", i64 14 }
@"csbs$LogAnalyzer-runtime$4c" = private constant [57 x i8] c"memory block stored within Arena_Temp not owned by Arena\00", align 1
@"ggv$runtime::arena_temp_end$3" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$4c", i64 56 }
@"scl$[arena_temp_end9151]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$LogAnalyzer-runtime$1", i64 61 }, i32 302, i32 4, %..string { ptr @"csbs$LogAnalyzer-runtime$4a", i64 14 } }
@"csbs$LogAnalyzer-runtime$4d" = private constant [35 x i8] c"out of order use of arena_temp_end\00", align 1
@"ggv$runtime::arena_temp_end$4" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$4d", i64 34 }
@"csbs$LogAnalyzer-runtime$4e" = private constant [29 x i8] c"double-use of arena_temp_end\00", align 1
@"ggv$runtime::arena_temp_end$5" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$4e", i64 28 }
@"ggv$map_cell_info-13197927915248882629" = private constant %"runtime::Map_Cell_Info" { i64 8, i64 8, i64 64, i64 8 }
@"csbs$LogAnalyzer-runtime$4f" = private constant [39 x i8] c"allocation not aligned to a cache line\00", align 1
@"ggv$runtime::map_alloc_dynamic$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$4f", i64 38 }
@"runtime::type_table" = external global { ptr, i64 }
@"csbs$LogAnalyzer-runtime$50" = private constant [28 x i8] c"unable to insert into a map\00", align 1
@"csbs$LogAnalyzer-runtime$51" = private constant [54 x i8] c"C:/MyCode/Odin/base/runtime/dynamic_map_internal.odin\00", align 1
@"csbs$LogAnalyzer-runtime$52" = private constant [33 x i8] c"map_insert_hash_dynamic_with_key\00", align 1
@"scl$[map_insert_hash_dynamic_with_key18063]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$LogAnalyzer-runtime$51", i64 53 }, i32 427, i32 4, %..string { ptr @"csbs$LogAnalyzer-runtime$52", i64 32 } }
@"ggv$runtime::map_insert_hash_dynamic_with_key$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$50", i64 27 }
@"csbs$LogAnalyzer-runtime$53" = private constant [2 x i8] c" \00", align 1
@"ggv$runtime::default_assertion_contextless_failure_proc$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$53", i64 1 }
@"ggv$runtime::default_assertion_contextless_failure_proc$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2d", i64 2 }
@"csbs$LogAnalyzer-runtime$54" = private constant [12 x i8] c"data != nil\00", align 1
@"ggv$runtime::_append_elem$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$54", i64 11 }
@"runtime::string_decode_rune-.accept_sizes-41963" = internal constant [256 x i8] c"\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\13\03\03\03\03\03\03\03\03\03\03\03\03#\03\034\04\04\04D\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1", align 1
@"runtime::string_decode_rune-.accept_ranges-42885" = internal constant [5 x %"runtime::string_decode_rune::Accept_Range::$1"] [%"runtime::string_decode_rune::Accept_Range::$1" { i8 -128, i8 -65 }, %"runtime::string_decode_rune::Accept_Range::$1" { i8 -96, i8 -65 }, %"runtime::string_decode_rune::Accept_Range::$1" { i8 -128, i8 -97 }, %"runtime::string_decode_rune::Accept_Range::$1" { i8 -112, i8 -65 }, %"runtime::string_decode_rune::Accept_Range::$1" { i8 -128, i8 -113 }], align 1
@"ggv$runtime::string_decode_rune$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$18", i64 41 }
@"ggv$runtime::string_decode_rune$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$18", i64 41 }
@"ggv$runtime::string_decode_rune$3" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$18", i64 41 }
@"ggv$runtime::string_decode_rune$4" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$18", i64 41 }
@"ggv$runtime::string_decode_rune$5" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$18", i64 41 }
@"ggv$runtime::string_decode_rune$6" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$18", i64 41 }
@"ggv$runtime::string_decode_rune$7" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$18", i64 41 }
@"ggv$runtime::_append_elems$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$54", i64 11 }
@"csbs$LogAnalyzer-runtime$55" = private constant [29 x i8] c"a.allocator.procedure != nil\00", align 1
@"csbs$LogAnalyzer-runtime$56" = private constant [46 x i8] c"C:/MyCode/Odin/base/runtime/core_builtin.odin\00", align 1
@"csbs$LogAnalyzer-runtime$57" = private constant [23 x i8] c"_reserve_dynamic_array\00", align 1
@"scl$[_reserve_dynamic_array28302]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$LogAnalyzer-runtime$56", i64 45 }, i32 801, i32 2, %..string { ptr @"csbs$LogAnalyzer-runtime$57", i64 22 } }
@"ggv$runtime::_reserve_dynamic_array$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$55", i64 28 }
@"csbs$LogAnalyzer-runtime$58" = private constant [6 x i8] c"panic\00", align 1
@"ggv$runtime::panic$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$58", i64 5 }
@"csbs$LogAnalyzer-runtime$59" = private constant [48 x i8] c"C:/MyCode/Odin/base/runtime/heap_allocator.odin\00", align 1
@"ggv$runtime::heap_allocator_proc.aligned_resize-2$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$59", i64 47 }
@"csbs$LogAnalyzer-runtime$5a" = private constant [8 x i8] c" Index \00", align 1
@"ggv$runtime::bounds_check_error.handle_error-0$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$5a", i64 7 }
@"ggv$runtime::bounds_check_error.handle_error-0$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$9", i64 21 }
@"csbs$LogAnalyzer-runtime$5b" = private constant [18 x i8] c" Matrix indices [\00", align 1
@"ggv$runtime::matrix_bounds_check_error.handle_error-0$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$5b", i64 17 }
@"ggv$runtime::matrix_bounds_check_error.handle_error-0$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$2a", i64 2 }
@"csbs$LogAnalyzer-runtime$5c" = private constant [23 x i8] c" is out of range [0..<\00", align 1
@"ggv$runtime::matrix_bounds_check_error.handle_error-0$3" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$5c", i64 22 }
@"csbs$LogAnalyzer-runtime$5d" = private constant [7 x i8] c", 0..<\00", align 1
@"ggv$runtime::matrix_bounds_check_error.handle_error-0$4" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$5d", i64 6 }
@"ggv$runtime::matrix_bounds_check_error.handle_error-0$5" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$47", i64 1 }
@"csbs$LogAnalyzer-runtime$5e" = private constant [30 x i8] c" Invalid type assertion from \00", align 1
@"ggv$runtime::type_assertion_check.handle_error-0$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$5e", i64 29 }
@"csbs$LogAnalyzer-runtime$5f" = private constant [5 x i8] c" to \00", align 1
@"ggv$runtime::type_assertion_check.handle_error-0$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$5f", i64 4 }
@"csbs$LogAnalyzer-runtime$60" = private constant [46 x i8] c"C:/MyCode/Odin/base/runtime/error_checks.odin\00", align 1
@"ggv$runtime::type_assertion_check2.variant_type-0$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$60", i64 45 }
@"ggv$runtime::type_assertion_check2.handle_error-1$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$5e", i64 29 }
@"ggv$runtime::type_assertion_check2.handle_error-1$2" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$5f", i64 4 }
@"csbs$LogAnalyzer-runtime$61" = private constant [16 x i8] c", actual type: \00", align 1
@"ggv$runtime::type_assertion_check2.handle_error-1$3" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$61", i64 15 }
@"csbs$LogAnalyzer-runtime$62" = private constant [33 x i8] c" Invalid slice length for make: \00", align 1
@"ggv$runtime::make_slice_error_loc.handle_error-0$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$62", i64 32 }
@"csbs$LogAnalyzer-runtime$63" = private constant [45 x i8] c" Invalid dynamic array parameters for make: \00", align 1
@"ggv$runtime::make_dynamic_array_error_loc.handle_error-0$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$63", i64 44 }
@"csbs$LogAnalyzer-runtime$64" = private constant [18 x i8] c"runtime assertion\00", align 1
@"ggv$runtime::assert.internal-0$1" = private constant %..string { ptr @"csbs$LogAnalyzer-runtime$64", i64 17 }

define i8 @"runtime::string_eq"(ptr %0, ptr %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca ptr, align 8
  %4 = alloca i64, align 8
  %a.i = alloca ptr, align 8
  %b.i = alloca ptr, align 8
  %n.i = alloca i64, align 8
  %i.i = alloca i64, align 8
  %m.i = alloca i64, align 8
  %load_a.i = alloca <16 x i8>, align 16
  %load_b.i = alloca <16 x i8>, align 16
  %ne.i = alloca <16 x i8>, align 16
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca %..string, align 8
  %8 = alloca %..string, align 8
  %x = alloca %"runtime::Raw_String", align 8
  %y = alloca %"runtime::Raw_String", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %8, ptr %1, i64 16, i1 false)
  %9 = load %"runtime::Raw_String", ptr %7, align 8
  store %"runtime::Raw_String" %9, ptr %x, align 8
  %10 = load %"runtime::Raw_String", ptr %8, align 8
  store %"runtime::Raw_String" %10, ptr %y, align 8
  %11 = getelementptr inbounds nuw %"runtime::Raw_String", ptr %x, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  %13 = getelementptr inbounds nuw %"runtime::Raw_String", ptr %y, i32 0, i32 1
  %14 = load i64, ptr %13, align 8
  %15 = icmp ne i64 %12, %14
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %18 = getelementptr inbounds nuw %"runtime::Raw_String", ptr %x, i32 0, i32 0
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr inbounds nuw %"runtime::Raw_String", ptr %y, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr inbounds nuw %"runtime::Raw_String", ptr %x, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  store ptr %19, ptr %2, align 8
  store ptr %21, ptr %3, align 8
  store i64 %23, ptr %4, align 8
  %24 = icmp eq i64 %23, 0
  %25 = zext i1 %24 to i8
  br i1 %24, label %switch.case.body.i, label %switch.case.next.i

switch.case.next.i:                               ; preds = %if.done
  %26 = icmp eq ptr %19, %21
  %27 = zext i1 %26 to i8
  br i1 %26, label %switch.case.body2.i, label %switch.case.next1.i

switch.case.body.i:                               ; preds = %if.done
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  br label %"runtime::memory_equal.exit"

switch.case.next1.i:                              ; preds = %switch.case.next.i
  store ptr %19, ptr %a.i, align 8
  store ptr %21, ptr %b.i, align 8
  store i64 %23, ptr %n.i, align 8
  store i64 0, ptr %i.i, align 8
  store i64 0, ptr %m.i, align 8
  %28 = load i64, ptr %n.i, align 8
  %29 = icmp uge i64 %28, 8
  %30 = zext i1 %29 to i8
  br i1 %29, label %if.then.i, label %if.done10.i

switch.case.body2.i:                              ; preds = %switch.case.next.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  br label %"runtime::memory_equal.exit"

if.then.i:                                        ; preds = %switch.case.next1.i
  %31 = load i64, ptr %n.i, align 8
  %32 = load i64, ptr %i.i, align 8
  %33 = sub i64 %31, %32
  %34 = udiv i64 %33, 16
  %35 = mul i64 %34, 16
  store i64 %35, ptr %m.i, align 8
  br label %for.loop.i

for.loop.i:                                       ; preds = %if.done.i, %if.then.i
  %36 = load i64, ptr %i.i, align 8
  %37 = load i64, ptr %m.i, align 8
  %38 = icmp ult i64 %36, %37
  %39 = zext i1 %38 to i8
  br i1 %38, label %for.body.i, label %for.done.i

for.body.i:                                       ; preds = %for.loop.i
  %40 = load ptr, ptr %a.i, align 8
  %41 = load i64, ptr %i.i, align 8
  %42 = getelementptr i8, ptr %40, i64 %41
  %43 = load <16 x i8>, ptr %42, align 1
  store <16 x i8> %43, ptr %load_a.i, align 16
  %44 = load ptr, ptr %b.i, align 8
  %45 = load i64, ptr %i.i, align 8
  %46 = getelementptr i8, ptr %44, i64 %45
  %47 = load <16 x i8>, ptr %46, align 1
  store <16 x i8> %47, ptr %load_b.i, align 16
  %48 = load <16 x i8>, ptr %load_a.i, align 16
  %49 = load <16 x i8>, ptr %load_b.i, align 16
  %50 = icmp ne <16 x i8> %48, %49
  %51 = sext <16 x i1> %50 to <16 x i8>
  store <16 x i8> %51, ptr %ne.i, align 16
  %52 = load <16 x i8>, ptr %ne.i, align 16
  %53 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %52)
  %54 = icmp ne i8 %53, 0
  %55 = zext i1 %54 to i8
  br i1 %54, label %if.then3.i, label %if.done.i

if.then3.i:                                       ; preds = %for.body.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  br label %"runtime::memory_equal.exit"

if.done.i:                                        ; preds = %for.body.i
  %56 = load i64, ptr %i.i, align 8
  %57 = add i64 %56, 16
  store i64 %57, ptr %i.i, align 8
  br label %for.loop.i

for.done.i:                                       ; preds = %for.loop.i
  %58 = load i64, ptr %n.i, align 8
  %59 = load i64, ptr %i.i, align 8
  %60 = sub i64 %58, %59
  %61 = udiv i64 %60, 8
  %62 = mul i64 %61, 8
  store i64 %62, ptr %m.i, align 8
  br label %for.loop4.i

for.loop4.i:                                      ; preds = %if.done7.i, %for.done.i
  %63 = load i64, ptr %i.i, align 8
  %64 = load i64, ptr %m.i, align 8
  %65 = icmp ult i64 %63, %64
  %66 = zext i1 %65 to i8
  br i1 %65, label %for.body5.i, label %for.done9.i

for.body5.i:                                      ; preds = %for.loop4.i
  %67 = load ptr, ptr %a.i, align 8
  %68 = load i64, ptr %i.i, align 8
  %69 = getelementptr i8, ptr %67, i64 %68
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %69, i64 8, i1 false)
  %70 = load i64, ptr %5, align 8
  %71 = load ptr, ptr %b.i, align 8
  %72 = load i64, ptr %i.i, align 8
  %73 = getelementptr i8, ptr %71, i64 %72
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %6, ptr %73, i64 8, i1 false)
  %74 = load i64, ptr %6, align 8
  %75 = icmp ne i64 %70, %74
  %76 = zext i1 %75 to i8
  br i1 %75, label %if.then6.i, label %if.done7.i

if.then6.i:                                       ; preds = %for.body5.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  br label %"runtime::memory_equal.exit"

if.done7.i:                                       ; preds = %for.body5.i
  %77 = load i64, ptr %i.i, align 8
  %78 = add i64 %77, 8
  store i64 %78, ptr %i.i, align 8
  br label %for.loop4.i

for.done9.i:                                      ; preds = %for.loop4.i
  br label %if.done10.i

if.done10.i:                                      ; preds = %for.done9.i, %switch.case.next1.i
  br label %for.loop11.i

for.loop11.i:                                     ; preds = %if.done14.i, %if.done10.i
  %79 = load i64, ptr %i.i, align 8
  %80 = load i64, ptr %n.i, align 8
  %81 = icmp ult i64 %79, %80
  %82 = zext i1 %81 to i8
  br i1 %81, label %for.body12.i, label %for.done16.i

for.body12.i:                                     ; preds = %for.loop11.i
  %83 = load ptr, ptr %a.i, align 8
  %84 = load i64, ptr %i.i, align 8
  %85 = getelementptr i8, ptr %83, i64 %84
  %86 = load i8, ptr %85, align 1
  %87 = load ptr, ptr %b.i, align 8
  %88 = load i64, ptr %i.i, align 8
  %89 = getelementptr i8, ptr %87, i64 %88
  %90 = load i8, ptr %89, align 1
  %91 = icmp ne i8 %86, %90
  %92 = zext i1 %91 to i8
  br i1 %91, label %if.then13.i, label %if.done14.i

if.then13.i:                                      ; preds = %for.body12.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  br label %"runtime::memory_equal.exit"

if.done14.i:                                      ; preds = %for.body12.i
  %93 = load i64, ptr %i.i, align 8
  %94 = add i64 %93, 1
  store i64 %94, ptr %i.i, align 8
  br label %for.loop11.i

for.done16.i:                                     ; preds = %for.loop11.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  br label %"runtime::memory_equal.exit"

"runtime::memory_equal.exit":                     ; preds = %for.done16.i, %if.then13.i, %if.then6.i, %if.then3.i, %switch.case.body2.i, %switch.case.body.i
  %95 = phi i8 [ 1, %switch.case.body.i ], [ 1, %switch.case.body2.i ], [ 0, %if.then3.i ], [ 0, %if.then6.i ], [ 0, %if.then13.i ], [ 1, %for.done16.i ]
  ret i8 %95
}

define void @"runtime::[default_temporary_allocator.odin]::_destroy_temp_allocator_fini"(ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  br label %entry

entry:                                            ; preds = %decls
  call void @"runtime::default_temp_allocator_destroy"(ptr @"runtime::global_default_temp_allocator_data", ptr %__.context_ptr)
  ret void
}

; Function Attrs: noreturn
define void @"runtime::bounds_trap"() #0 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  call void @"runtime::[procs_windows_amd64.odin]::windows_trap_array_bounds"()
  unreachable
}

define void @"runtime::heap_allocator"(ptr noalias sret(%"runtime::Allocator") %agg.result, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  br label %entry

entry:                                            ; preds = %decls
  store %"runtime::Allocator" { ptr @"runtime::heap_allocator_proc", ptr null }, ptr %agg.result, align 8
  ret void
}

define <2 x i64> @"runtime::udivmod128"(ptr %0, ptr %1, ptr %2) {
decls:
  %3 = alloca ptr, align 8
  %n = alloca [2 x i64], align 8
  %d = alloca [2 x i64], align 8
  %q = alloca [2 x i64], align 16
  %r = alloca [2 x i64], align 16
  %sr = alloca i32, align 4
  %res = alloca i64, align 8
  %4 = alloca <2 x i64>, align 16
  %5 = alloca <2 x i64>, align 16
  %6 = alloca <2 x i64>, align 16
  %7 = alloca <2 x i64>, align 16
  %8 = alloca <2 x i64>, align 16
  %9 = alloca <2 x i64>, align 16
  %10 = alloca <2 x i64>, align 16
  %11 = alloca <2 x i64>, align 16
  %12 = alloca <2 x i64>, align 16
  %carry = alloca i32, align 4
  %r_all = alloca i128, align 16
  %s = alloca i128, align 16
  %q_all = alloca i128, align 16
  %13 = alloca <2 x i64>, align 16
  br label %entry

entry:                                            ; preds = %decls
  store ptr %2, ptr %3, align 8
  %14 = load [2 x i64], ptr %0, align 8
  store [2 x i64] %14, ptr %n, align 8
  %15 = load [2 x i64], ptr %1, align 8
  store [2 x i64] %15, ptr %d, align 8
  call void @llvm.memset.inline.p0.i64(ptr %q, i8 0, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %r, i8 0, i64 16, i1 false)
  store i32 0, ptr %sr, align 4
  %16 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %17 = load i64, ptr %16, align 8
  %18 = icmp eq i64 %17, 0
  %19 = zext i1 %18 to i8
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %if.then, label %if.done6

if.then:                                          ; preds = %entry
  %21 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %22 = load i64, ptr %21, align 8
  %23 = icmp eq i64 %22, 0
  %24 = zext i1 %23 to i8
  %25 = icmp ne i8 %24, 0
  br i1 %25, label %if.then1, label %if.done3

if.then1:                                         ; preds = %if.then
  %26 = icmp ne ptr %2, null
  %27 = zext i1 %26 to i8
  %28 = icmp ne i8 %27, 0
  br i1 %28, label %if.then2, label %if.done

if.then2:                                         ; preds = %if.then1
  %29 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %30 = load i64, ptr %29, align 8
  %31 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %32 = load i64, ptr %31, align 8
  %33 = urem i64 %30, %32
  store i64 %33, ptr %res, align 8
  %34 = load i64, ptr %res, align 8
  %35 = zext i64 %34 to i128
  store i128 %35, ptr %2, align 16
  br label %if.done

if.done:                                          ; preds = %if.then2, %if.then1
  %36 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %37 = load i64, ptr %36, align 8
  %38 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %39 = load i64, ptr %38, align 8
  %40 = udiv i64 %37, %39
  %41 = zext i64 %40 to i128
  store i128 %41, ptr %4, align 16
  %42 = load <2 x i64>, ptr %4, align 16
  ret <2 x i64> %42

if.done3:                                         ; preds = %if.then
  %43 = icmp ne ptr %2, null
  %44 = zext i1 %43 to i8
  %45 = icmp ne i8 %44, 0
  br i1 %45, label %if.then4, label %if.done5

if.then4:                                         ; preds = %if.done3
  %46 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %47 = load i64, ptr %46, align 8
  %48 = zext i64 %47 to i128
  store i128 %48, ptr %2, align 16
  br label %if.done5

if.done5:                                         ; preds = %if.then4, %if.done3
  store i128 0, ptr %5, align 16
  %49 = load <2 x i64>, ptr %5, align 16
  ret <2 x i64> %49

if.done6:                                         ; preds = %entry
  %50 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %51 = load i64, ptr %50, align 8
  %52 = icmp eq i64 %51, 0
  %53 = zext i1 %52 to i8
  %54 = icmp ne i8 %53, 0
  br i1 %54, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.done6
  %55 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %56 = load i64, ptr %55, align 8
  %57 = icmp eq i64 %56, 0
  %58 = zext i1 %57 to i8
  %59 = icmp ne i8 %58, 0
  br i1 %59, label %if.then8, label %if.done11

if.then8:                                         ; preds = %if.then7
  %60 = icmp ne ptr %2, null
  %61 = zext i1 %60 to i8
  %62 = icmp ne i8 %61, 0
  br i1 %62, label %if.then9, label %if.done10

if.then9:                                         ; preds = %if.then8
  %63 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %64 = load i64, ptr %63, align 8
  %65 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %66 = load i64, ptr %65, align 8
  %67 = urem i64 %64, %66
  %68 = zext i64 %67 to i128
  store i128 %68, ptr %2, align 16
  br label %if.done10

if.done10:                                        ; preds = %if.then9, %if.then8
  %69 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %70 = load i64, ptr %69, align 8
  %71 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %72 = load i64, ptr %71, align 8
  %73 = udiv i64 %70, %72
  %74 = zext i64 %73 to i128
  store i128 %74, ptr %6, align 16
  %75 = load <2 x i64>, ptr %6, align 16
  ret <2 x i64> %75

if.done11:                                        ; preds = %if.then7
  %76 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %77 = load i64, ptr %76, align 8
  %78 = icmp eq i64 %77, 0
  %79 = zext i1 %78 to i8
  %80 = icmp ne i8 %79, 0
  br i1 %80, label %if.then12, label %if.done15

if.then12:                                        ; preds = %if.done11
  %81 = icmp ne ptr %2, null
  %82 = zext i1 %81 to i8
  %83 = icmp ne i8 %82, 0
  br i1 %83, label %if.then13, label %if.done14

if.then13:                                        ; preds = %if.then12
  %84 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %85 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %86 = load i64, ptr %85, align 8
  %87 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %88 = load i64, ptr %87, align 8
  %89 = urem i64 %86, %88
  store i64 %89, ptr %84, align 8
  %90 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  store i64 0, ptr %90, align 8
  %91 = load i128, ptr %r, align 16
  store i128 %91, ptr %2, align 16
  br label %if.done14

if.done14:                                        ; preds = %if.then13, %if.then12
  %92 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %93 = load i64, ptr %92, align 8
  %94 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %95 = load i64, ptr %94, align 8
  %96 = udiv i64 %93, %95
  %97 = zext i64 %96 to i128
  store i128 %97, ptr %7, align 16
  %98 = load <2 x i64>, ptr %7, align 16
  ret <2 x i64> %98

if.done15:                                        ; preds = %if.done11
  %99 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %100 = load i64, ptr %99, align 8
  %101 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %102 = load i64, ptr %101, align 8
  %103 = sub i64 %102, 1
  %104 = and i64 %100, %103
  %105 = icmp eq i64 %104, 0
  %106 = zext i1 %105 to i8
  %107 = icmp ne i8 %106, 0
  br i1 %107, label %if.then16, label %if.done19

if.then16:                                        ; preds = %if.done15
  %108 = icmp ne ptr %2, null
  %109 = zext i1 %108 to i8
  %110 = icmp ne i8 %109, 0
  br i1 %110, label %if.then17, label %if.done18

if.then17:                                        ; preds = %if.then16
  %111 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %112 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %113 = load i64, ptr %112, align 8
  store i64 %113, ptr %111, align 8
  %114 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %115 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %116 = load i64, ptr %115, align 8
  %117 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %118 = load i64, ptr %117, align 8
  %119 = sub i64 %118, 1
  %120 = and i64 %116, %119
  store i64 %120, ptr %114, align 8
  %121 = load i128, ptr %r, align 16
  store i128 %121, ptr %2, align 16
  br label %if.done18

if.done18:                                        ; preds = %if.then17, %if.then16
  %122 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %123 = load i64, ptr %122, align 8
  %124 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %125 = load i64, ptr %124, align 8
  %126 = call i64 @llvm.cttz.i64(i64 %125, i1 false)
  %127 = icmp ult i64 %126, 64
  %128 = lshr i64 %123, %126
  %129 = select i1 %127, i64 %128, i64 0
  %130 = zext i64 %129 to i128
  store i128 %130, ptr %8, align 16
  %131 = load <2 x i64>, ptr %8, align 16
  ret <2 x i64> %131

if.done19:                                        ; preds = %if.done15
  %132 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %133 = load i64, ptr %132, align 8
  %134 = call i64 @llvm.ctlz.i64(i64 %133, i1 false)
  %135 = trunc i64 %134 to i32
  %136 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %137 = load i64, ptr %136, align 8
  %138 = call i64 @llvm.ctlz.i64(i64 %137, i1 false)
  %139 = trunc i64 %138 to i32
  %140 = sub i32 %135, %139
  store i32 %140, ptr %sr, align 4
  %141 = load i32, ptr %sr, align 4
  %142 = icmp ugt i32 %141, 62
  %143 = zext i1 %142 to i8
  %144 = icmp ne i8 %143, 0
  br i1 %144, label %if.then20, label %if.done23

if.then20:                                        ; preds = %if.done19
  %145 = icmp ne ptr %2, null
  %146 = zext i1 %145 to i8
  %147 = icmp ne i8 %146, 0
  br i1 %147, label %if.then21, label %if.done22

if.then21:                                        ; preds = %if.then20
  %148 = load i128, ptr %0, align 16
  store i128 %148, ptr %2, align 16
  br label %if.done22

if.done22:                                        ; preds = %if.then21, %if.then20
  store i128 0, ptr %9, align 16
  %149 = load <2 x i64>, ptr %9, align 16
  ret <2 x i64> %149

if.done23:                                        ; preds = %if.done19
  %150 = load i32, ptr %sr, align 4
  %151 = add i32 %150, 1
  store i32 %151, ptr %sr, align 4
  %152 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  store i64 0, ptr %152, align 8
  %153 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %154 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %155 = load i64, ptr %154, align 8
  %156 = load i32, ptr %sr, align 4
  %157 = sub i32 64, %156
  %158 = zext i32 %157 to i64
  %159 = icmp ult i64 %158, 64
  %160 = shl i64 %155, %158
  %161 = select i1 %159, i64 %160, i64 0
  store i64 %161, ptr %153, align 8
  %162 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %163 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %164 = load i64, ptr %163, align 8
  %165 = load i32, ptr %sr, align 4
  %166 = zext i32 %165 to i64
  %167 = icmp ult i64 %166, 64
  %168 = lshr i64 %164, %166
  %169 = select i1 %167, i64 %168, i64 0
  store i64 %169, ptr %162, align 8
  %170 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %171 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %172 = load i64, ptr %171, align 8
  %173 = load i32, ptr %sr, align 4
  %174 = sub i32 64, %173
  %175 = zext i32 %174 to i64
  %176 = icmp ult i64 %175, 64
  %177 = shl i64 %172, %175
  %178 = select i1 %176, i64 %177, i64 0
  %179 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %180 = load i64, ptr %179, align 8
  %181 = load i32, ptr %sr, align 4
  %182 = zext i32 %181 to i64
  %183 = icmp ult i64 %182, 64
  %184 = lshr i64 %180, %182
  %185 = select i1 %183, i64 %184, i64 0
  %186 = or i64 %178, %185
  store i64 %186, ptr %170, align 8
  br label %if.done42

if.else:                                          ; preds = %if.done6
  %187 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %188 = load i64, ptr %187, align 8
  %189 = icmp eq i64 %188, 0
  %190 = zext i1 %189 to i8
  %191 = icmp ne i8 %190, 0
  br i1 %191, label %if.then24, label %if.else33

if.then24:                                        ; preds = %if.else
  %192 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %193 = load i64, ptr %192, align 8
  %194 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %195 = load i64, ptr %194, align 8
  %196 = sub i64 %195, 1
  %197 = and i64 %193, %196
  %198 = icmp eq i64 %197, 0
  %199 = zext i1 %198 to i8
  %200 = icmp ne i8 %199, 0
  br i1 %200, label %if.then25, label %if.done30

if.then25:                                        ; preds = %if.then24
  %201 = icmp ne ptr %2, null
  %202 = zext i1 %201 to i8
  %203 = icmp ne i8 %202, 0
  br i1 %203, label %if.then26, label %if.done27

if.then26:                                        ; preds = %if.then25
  %204 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %205 = load i64, ptr %204, align 8
  %206 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %207 = load i64, ptr %206, align 8
  %208 = sub i64 %207, 1
  %209 = and i64 %205, %208
  %210 = zext i64 %209 to i128
  store i128 %210, ptr %2, align 16
  br label %if.done27

if.done27:                                        ; preds = %if.then26, %if.then25
  %211 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %212 = load i64, ptr %211, align 8
  %213 = icmp eq i64 %212, 1
  %214 = zext i1 %213 to i8
  %215 = icmp ne i8 %214, 0
  br i1 %215, label %if.then28, label %if.done29

if.then28:                                        ; preds = %if.done27
  %216 = load i128, ptr %0, align 16
  store i128 %216, ptr %10, align 16
  %217 = load <2 x i64>, ptr %10, align 16
  ret <2 x i64> %217

if.done29:                                        ; preds = %if.done27
  %218 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %219 = load i64, ptr %218, align 8
  %220 = call i64 @llvm.cttz.i64(i64 %219, i1 false)
  %221 = trunc i64 %220 to i32
  store i32 %221, ptr %sr, align 4
  %222 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %223 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %224 = load i64, ptr %223, align 8
  %225 = load i32, ptr %sr, align 4
  %226 = zext i32 %225 to i64
  %227 = icmp ult i64 %226, 64
  %228 = lshr i64 %224, %226
  %229 = select i1 %227, i64 %228, i64 0
  store i64 %229, ptr %222, align 8
  %230 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  %231 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %232 = load i64, ptr %231, align 8
  %233 = load i32, ptr %sr, align 4
  %234 = sub i32 64, %233
  %235 = zext i32 %234 to i64
  %236 = icmp ult i64 %235, 64
  %237 = shl i64 %232, %235
  %238 = select i1 %236, i64 %237, i64 0
  %239 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %240 = load i64, ptr %239, align 8
  %241 = load i32, ptr %sr, align 4
  %242 = zext i32 %241 to i64
  %243 = icmp ult i64 %242, 64
  %244 = lshr i64 %240, %242
  %245 = select i1 %243, i64 %244, i64 0
  %246 = or i64 %238, %245
  store i64 %246, ptr %230, align 8
  %247 = load i128, ptr %q, align 16
  store i128 %247, ptr %11, align 16
  %248 = load <2 x i64>, ptr %11, align 16
  ret <2 x i64> %248

if.done30:                                        ; preds = %if.then24
  %249 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %250 = load i64, ptr %249, align 8
  %251 = call i64 @llvm.ctlz.i64(i64 %250, i1 false)
  %252 = trunc i64 %251 to i32
  %253 = add i32 65, %252
  %254 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %255 = load i64, ptr %254, align 8
  %256 = call i64 @llvm.ctlz.i64(i64 %255, i1 false)
  %257 = trunc i64 %256 to i32
  %258 = sub i32 %253, %257
  store i32 %258, ptr %sr, align 4
  %259 = load i32, ptr %sr, align 4
  %260 = icmp eq i32 %259, 64
  %261 = zext i1 %260 to i8
  %262 = icmp eq i8 1, %261
  br i1 %262, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %if.done30
  %263 = load i32, ptr %sr, align 4
  %264 = icmp ult i32 %263, 64
  %265 = zext i1 %264 to i8
  %266 = icmp eq i8 1, %265
  br i1 %266, label %switch.case.body32, label %switch.case.next31

switch.case.body:                                 ; preds = %if.done30
  %267 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  store i64 0, ptr %267, align 8
  %268 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %269 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %270 = load i64, ptr %269, align 8
  store i64 %270, ptr %268, align 8
  %271 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  store i64 0, ptr %271, align 8
  %272 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %273 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %274 = load i64, ptr %273, align 8
  store i64 %274, ptr %272, align 8
  br label %switch.done

switch.case.next31:                               ; preds = %switch.case.next
  br label %switch.default.body

switch.case.body32:                               ; preds = %switch.case.next
  %275 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  store i64 0, ptr %275, align 8
  %276 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %277 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %278 = load i64, ptr %277, align 8
  %279 = load i32, ptr %sr, align 4
  %280 = sub i32 64, %279
  %281 = zext i32 %280 to i64
  %282 = icmp ult i64 %281, 64
  %283 = shl i64 %278, %281
  %284 = select i1 %282, i64 %283, i64 0
  store i64 %284, ptr %276, align 8
  %285 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %286 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %287 = load i64, ptr %286, align 8
  %288 = load i32, ptr %sr, align 4
  %289 = zext i32 %288 to i64
  %290 = icmp ult i64 %289, 64
  %291 = lshr i64 %287, %289
  %292 = select i1 %290, i64 %291, i64 0
  store i64 %292, ptr %285, align 8
  %293 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %294 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %295 = load i64, ptr %294, align 8
  %296 = load i32, ptr %sr, align 4
  %297 = sub i32 64, %296
  %298 = zext i32 %297 to i64
  %299 = icmp ult i64 %298, 64
  %300 = shl i64 %295, %298
  %301 = select i1 %299, i64 %300, i64 0
  %302 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %303 = load i64, ptr %302, align 8
  %304 = load i32, ptr %sr, align 4
  %305 = zext i32 %304 to i64
  %306 = icmp ult i64 %305, 64
  %307 = lshr i64 %303, %305
  %308 = select i1 %306, i64 %307, i64 0
  %309 = or i64 %301, %308
  store i64 %309, ptr %293, align 8
  br label %switch.done

switch.default.body:                              ; preds = %switch.case.next31
  %310 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  %311 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %312 = load i64, ptr %311, align 8
  %313 = load i32, ptr %sr, align 4
  %314 = sub i32 128, %313
  %315 = zext i32 %314 to i64
  %316 = icmp ult i64 %315, 64
  %317 = shl i64 %312, %315
  %318 = select i1 %316, i64 %317, i64 0
  store i64 %318, ptr %310, align 8
  %319 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %320 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %321 = load i64, ptr %320, align 8
  %322 = load i32, ptr %sr, align 4
  %323 = sub i32 128, %322
  %324 = zext i32 %323 to i64
  %325 = icmp ult i64 %324, 64
  %326 = shl i64 %321, %324
  %327 = select i1 %325, i64 %326, i64 0
  %328 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %329 = load i64, ptr %328, align 8
  %330 = load i32, ptr %sr, align 4
  %331 = sub i32 %330, 64
  %332 = zext i32 %331 to i64
  %333 = icmp ult i64 %332, 64
  %334 = lshr i64 %329, %332
  %335 = select i1 %333, i64 %334, i64 0
  %336 = or i64 %327, %335
  store i64 %336, ptr %319, align 8
  %337 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  store i64 0, ptr %337, align 8
  %338 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %339 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %340 = load i64, ptr %339, align 8
  %341 = load i32, ptr %sr, align 4
  %342 = sub i32 %341, 64
  %343 = zext i32 %342 to i64
  %344 = icmp ult i64 %343, 64
  %345 = lshr i64 %340, %343
  %346 = select i1 %344, i64 %345, i64 0
  store i64 %346, ptr %338, align 8
  br label %switch.done

switch.done:                                      ; preds = %switch.default.body, %switch.case.body32, %switch.case.body
  br label %if.done41

if.else33:                                        ; preds = %if.else
  %347 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %348 = load i64, ptr %347, align 8
  %349 = call i64 @llvm.ctlz.i64(i64 %348, i1 false)
  %350 = trunc i64 %349 to i32
  %351 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %352 = load i64, ptr %351, align 8
  %353 = call i64 @llvm.ctlz.i64(i64 %352, i1 false)
  %354 = trunc i64 %353 to i32
  %355 = sub i32 %350, %354
  store i32 %355, ptr %sr, align 4
  %356 = load i32, ptr %sr, align 4
  %357 = icmp ugt i32 %356, 63
  %358 = zext i1 %357 to i8
  %359 = icmp ne i8 %358, 0
  br i1 %359, label %if.then34, label %if.done37

if.then34:                                        ; preds = %if.else33
  %360 = icmp ne ptr %2, null
  %361 = zext i1 %360 to i8
  %362 = icmp ne i8 %361, 0
  br i1 %362, label %if.then35, label %if.done36

if.then35:                                        ; preds = %if.then34
  %363 = load i128, ptr %0, align 16
  store i128 %363, ptr %2, align 16
  br label %if.done36

if.done36:                                        ; preds = %if.then35, %if.then34
  store i128 0, ptr %12, align 16
  %364 = load <2 x i64>, ptr %12, align 16
  ret <2 x i64> %364

if.done37:                                        ; preds = %if.else33
  %365 = load i32, ptr %sr, align 4
  %366 = add i32 %365, 1
  store i32 %366, ptr %sr, align 4
  %367 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  store i64 0, ptr %367, align 8
  %368 = load i32, ptr %sr, align 4
  %369 = icmp eq i32 %368, 64
  %370 = zext i1 %369 to i8
  %371 = icmp ne i8 %370, 0
  br i1 %371, label %if.then38, label %if.else39

if.then38:                                        ; preds = %if.done37
  %372 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %373 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %374 = load i64, ptr %373, align 8
  store i64 %374, ptr %372, align 8
  %375 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  store i64 0, ptr %375, align 8
  %376 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %377 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %378 = load i64, ptr %377, align 8
  store i64 %378, ptr %376, align 8
  br label %if.done40

if.else39:                                        ; preds = %if.done37
  %379 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %380 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %381 = load i64, ptr %380, align 8
  %382 = load i32, ptr %sr, align 4
  %383 = zext i32 %382 to i64
  %384 = icmp ult i64 %383, 64
  %385 = lshr i64 %381, %383
  %386 = select i1 %384, i64 %385, i64 0
  store i64 %386, ptr %379, align 8
  %387 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %388 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %389 = load i64, ptr %388, align 8
  %390 = load i32, ptr %sr, align 4
  %391 = sub i32 64, %390
  %392 = zext i32 %391 to i64
  %393 = icmp ult i64 %392, 64
  %394 = shl i64 %389, %392
  %395 = select i1 %393, i64 %394, i64 0
  %396 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %397 = load i64, ptr %396, align 8
  %398 = load i32, ptr %sr, align 4
  %399 = zext i32 %398 to i64
  %400 = icmp ult i64 %399, 64
  %401 = lshr i64 %397, %399
  %402 = select i1 %400, i64 %401, i64 0
  %403 = or i64 %395, %402
  store i64 %403, ptr %387, align 8
  %404 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %405 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %406 = load i64, ptr %405, align 8
  %407 = load i32, ptr %sr, align 4
  %408 = sub i32 64, %407
  %409 = zext i32 %408 to i64
  %410 = icmp ult i64 %409, 64
  %411 = shl i64 %406, %409
  %412 = select i1 %410, i64 %411, i64 0
  store i64 %412, ptr %404, align 8
  br label %if.done40

if.done40:                                        ; preds = %if.else39, %if.then38
  br label %if.done41

if.done41:                                        ; preds = %if.done40, %switch.done
  br label %if.done42

if.done42:                                        ; preds = %if.done41, %if.done23
  store i32 0, ptr %carry, align 4
  store i128 0, ptr %r_all, align 16
  br label %for.loop

for.loop:                                         ; preds = %for.post, %if.done42
  %413 = load i32, ptr %sr, align 4
  %414 = icmp ugt i32 %413, 0
  %415 = zext i1 %414 to i8
  %416 = icmp ne i8 %415, 0
  br i1 %416, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %417 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %418 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %419 = load i64, ptr %418, align 8
  %420 = shl i64 %419, 1
  %421 = select i1 true, i64 %420, i64 0
  %422 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %423 = load i64, ptr %422, align 8
  %424 = lshr i64 %423, 63
  %425 = select i1 true, i64 %424, i64 0
  %426 = or i64 %421, %425
  store i64 %426, ptr %417, align 8
  %427 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %428 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %429 = load i64, ptr %428, align 8
  %430 = shl i64 %429, 1
  %431 = select i1 true, i64 %430, i64 0
  %432 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %433 = load i64, ptr %432, align 8
  %434 = lshr i64 %433, 63
  %435 = select i1 true, i64 %434, i64 0
  %436 = or i64 %431, %435
  store i64 %436, ptr %427, align 8
  %437 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %438 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %439 = load i64, ptr %438, align 8
  %440 = shl i64 %439, 1
  %441 = select i1 true, i64 %440, i64 0
  %442 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  %443 = load i64, ptr %442, align 8
  %444 = lshr i64 %443, 63
  %445 = select i1 true, i64 %444, i64 0
  %446 = or i64 %441, %445
  store i64 %446, ptr %437, align 8
  %447 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  %448 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  %449 = load i64, ptr %448, align 8
  %450 = shl i64 %449, 1
  %451 = select i1 true, i64 %450, i64 0
  %452 = load i32, ptr %carry, align 4
  %453 = zext i32 %452 to i64
  %454 = or i64 %451, %453
  store i64 %454, ptr %447, align 8
  %455 = load i128, ptr %r, align 16
  store i128 %455, ptr %r_all, align 16
  %456 = load i128, ptr %1, align 16
  %457 = load i128, ptr %r_all, align 16
  %458 = sub i128 %456, %457
  %459 = sub i128 %458, 1
  %460 = ashr i128 %459, 127
  %461 = select i1 true, i128 %460, i128 0
  store i128 %461, ptr %s, align 16
  %462 = load i128, ptr %s, align 16
  %463 = and i128 %462, 1
  %464 = trunc i128 %463 to i32
  store i32 %464, ptr %carry, align 4
  %465 = load i128, ptr %1, align 16
  %466 = load i128, ptr %s, align 16
  %467 = and i128 %465, %466
  %468 = load i128, ptr %r_all, align 16
  %469 = sub i128 %468, %467
  store i128 %469, ptr %r_all, align 16
  %470 = load [2 x i64], ptr %r_all, align 8
  store [2 x i64] %470, ptr %r, align 8
  br label %for.post

for.post:                                         ; preds = %for.body
  %471 = load i32, ptr %sr, align 4
  %472 = sub i32 %471, 1
  store i32 %472, ptr %sr, align 4
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %473 = load i128, ptr %q, align 16
  %474 = shl i128 %473, 1
  %475 = select i1 true, i128 %474, i128 0
  %476 = load i32, ptr %carry, align 4
  %477 = zext i32 %476 to i128
  %478 = or i128 %475, %477
  store i128 %478, ptr %q_all, align 16
  %479 = icmp ne ptr %2, null
  %480 = zext i1 %479 to i8
  %481 = icmp ne i8 %480, 0
  br i1 %481, label %if.then43, label %if.done44

if.then43:                                        ; preds = %for.done
  %482 = load i128, ptr %r_all, align 16
  store i128 %482, ptr %2, align 16
  br label %if.done44

if.done44:                                        ; preds = %if.then43, %for.done
  %483 = load i128, ptr %q_all, align 16
  store i128 %483, ptr %13, align 16
  %484 = load <2 x i64>, ptr %13, align 16
  ret <2 x i64> %484
}

define i64 @"runtime::stderr_write"(ptr %0, ptr noalias nonnull %1) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca i64, align 8
  %4 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 16, i1 false)
  store i64 0, ptr %3, align 8
  %5 = call i64 @"runtime::[os_specific_windows.odin]::_stderr_write"(ptr %2, ptr %3)
  %6 = load i64, ptr %3, align 8
  store i64 %6, ptr %1, align 8
  ret i64 %5
}

; Function Attrs: noreturn
declare x86_stdcallcc void @RaiseException(i32, i32, i32, ptr) #0

define i8 @"runtime::heap_allocator_proc"(ptr %0, i8 %1, i64 %2, i64 %3, ptr %4, i64 %5, ptr %6, ptr noalias nonnull %7, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %8 = alloca ptr, align 8
  %9 = alloca i8, align 1
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i64, align 8
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { { ptr, i64 }, i8 }, align 8
  %16 = alloca { ptr, i64 }, align 8
  %17 = alloca { { ptr, i64 }, i8 }, align 8
  %set = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %8, align 8
  store i8 %1, ptr %9, align 1
  store i64 %2, ptr %10, align 8
  store i64 %3, ptr %11, align 8
  store ptr %4, ptr %12, align 8
  store i64 %5, ptr %13, align 8
  switch i8 %1, label %switch.done [
    i8 0, label %switch.case.body
    i8 6, label %switch.case.body
    i8 1, label %switch.case.body1
    i8 2, label %switch.case.body2
    i8 3, label %switch.case.body3
    i8 7, label %switch.case.body3
    i8 4, label %switch.case.body4
    i8 5, label %switch.case.body5
  ]

switch.case.body:                                 ; preds = %entry, %entry
  %18 = icmp eq i8 %1, 0
  %19 = zext i1 %18 to i8
  %20 = icmp ne i8 %19, 0
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false)
  %21 = call i8 @"runtime::heap_allocator_proc.aligned_alloc-0"(i64 %2, i64 %3, ptr null, i64 0, i1 zeroext %20, ptr %14, ptr %__.context_ptr)
  %22 = load { ptr, i64 }, ptr %14, align 8
  store { ptr, i64 } %22, ptr %7, align 8
  ret i8 %21

switch.case.body1:                                ; preds = %entry
  call void @"runtime::heap_allocator_proc.aligned_free-1"(ptr %4, ptr %__.context_ptr)
  br label %switch.done

switch.case.body2:                                ; preds = %entry
  store { ptr, i64 } zeroinitializer, ptr %7, align 8
  ret i8 4

switch.case.body3:                                ; preds = %entry, %entry
  %23 = icmp eq i8 %1, 3
  %24 = zext i1 %23 to i8
  %25 = icmp ne i8 %24, 0
  call void @llvm.memset.inline.p0.i64(ptr %16, i8 0, i64 16, i1 false)
  %26 = call i8 @"runtime::heap_allocator_proc.aligned_resize-2"(ptr %4, i64 %5, i64 %2, i64 %3, i1 zeroext %25, ptr %16, ptr %__.context_ptr)
  %27 = load { ptr, i64 }, ptr %16, align 8
  store { ptr, i64 } %27, ptr %7, align 8
  ret i8 %26

switch.case.body4:                                ; preds = %entry
  store ptr %4, ptr %set, align 8
  %28 = load ptr, ptr %set, align 8
  %29 = icmp ne ptr %28, null
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %if.then, label %if.done

if.then:                                          ; preds = %switch.case.body4
  %32 = load ptr, ptr %set, align 8
  store i8 -37, ptr %32, align 1
  br label %if.done

if.done:                                          ; preds = %if.then, %switch.case.body4
  store { ptr, i64 } zeroinitializer, ptr %7, align 8
  ret i8 0

switch.case.body5:                                ; preds = %entry
  store { ptr, i64 } zeroinitializer, ptr %7, align 8
  ret i8 4

switch.done:                                      ; preds = %switch.case.body1, %entry
  store { ptr, i64 } zeroinitializer, ptr %7, align 8
  ret i8 0
}

; Function Attrs: noreturn
define void @"runtime::[procs_windows_amd64.odin]::windows_trap_array_bounds"() #0 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  call x86_stdcallcc void @RaiseException(i32 -1073741684, i32 0, i32 0, ptr null)
  unreachable
}

; Function Attrs: noreturn
define void @"runtime::type_assertion_trap"() #0 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  call void @"runtime::[procs_windows_amd64.odin]::windows_trap_type_assertion"()
  unreachable
}

declare x86_stdcallcc ptr @GetStdHandle(i32)

declare x86_stdcallcc ptr @GetProcessHeap()

declare x86_stdcallcc ptr @HeapAlloc(ptr, i32, i64)

declare x86_stdcallcc i32 @SetHandleInformation(ptr, i32, i32)

; Function Attrs: noreturn
define void @"runtime::[procs_windows_amd64.odin]::windows_trap_type_assertion"() #0 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  call void @"runtime::[procs_windows_amd64.odin]::windows_trap_array_bounds"()
  unreachable
}

declare x86_stdcallcc ptr @HeapReAlloc(ptr, i32, ptr, i64)

declare x86_stdcallcc i32 @WriteFile(ptr, ptr, i32, ptr, ptr)

define void @"runtime::bounds_check_error"(ptr %0, i32 %1, i32 %2, i64 %3, i64 %4) {
decls:
  %5 = alloca %..string, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %0, i64 16, i1 false)
  store i32 %1, ptr %6, align 4
  store i32 %2, ptr %7, align 4
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  %10 = icmp ult i64 %3, %4
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  call void @"runtime::bounds_check_error.handle_error-0"(ptr %5, i32 %1, i32 %2, i64 %3, i64 %4)
  unreachable
}

declare x86_stdcallcc i32 @HeapFree(ptr, i32, ptr)

declare x86_stdcallcc i32 @GetLastError()

define ptr @"runtime::_heap_alloc"(i64 %0, i1 zeroext %1) {
decls:
  %2 = alloca i64, align 8
  %3 = alloca i8, align 1
  %ptr = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  %4 = zext i1 %1 to i8
  store i8 %4, ptr %3, align 1
  %5 = call x86_stdcallcc ptr @GetProcessHeap()
  %6 = icmp ne i8 %4, 0
  br i1 %6, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.done

if.else:                                          ; preds = %entry
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  %7 = phi i32 [ 8, %if.then ], [ 0, %if.else ]
  %8 = call x86_stdcallcc ptr @HeapAlloc(ptr %5, i32 %7, i64 %0)
  store ptr %8, ptr %ptr, align 8
  %9 = load ptr, ptr %ptr, align 8
  call void @"sanitizer::address_unpoison_rawptr"(ptr %9, i64 %0)
  %10 = load ptr, ptr %ptr, align 8
  ret ptr %10
}

define i64 @"runtime::[os_specific_windows.odin]::_stderr_write"(ptr %0, ptr noalias nonnull %1) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %n = alloca i64, align 8
  %err = alloca i64, align 8
  %h = alloca ptr, align 8
  %single_write_length = alloca i32, align 4
  %total_write = alloca i64, align 8
  %length = alloca i64, align 8
  %remaining = alloca i64, align 8
  %to_write = alloca i32, align 4
  %e = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 16, i1 false)
  store i64 0, ptr %n, align 8
  store i64 0, ptr %err, align 8
  %3 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %4 = load i64, ptr %3, align 8
  %5 = icmp eq i64 %4, 0
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store i64 0, ptr %n, align 8
  store i64 0, ptr %err, align 8
  store i64 0, ptr %1, align 8
  ret i64 0

if.done:                                          ; preds = %entry
  %8 = call x86_stdcallcc ptr @GetStdHandle(i32 -12)
  store ptr %8, ptr %h, align 8
  %9 = load ptr, ptr %h, align 8
  %10 = call x86_stdcallcc i32 @SetHandleInformation(ptr %9, i32 1, i32 0)
  store i32 0, ptr %single_write_length, align 4
  store i64 0, ptr %total_write, align 8
  %11 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  store i64 %12, ptr %length, align 8
  br label %for.loop

for.loop:                                         ; preds = %if.done2, %if.done
  %13 = load i64, ptr %total_write, align 8
  %14 = load i64, ptr %length, align 8
  %15 = icmp slt i64 %13, %14
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %18 = load i64, ptr %length, align 8
  %19 = load i64, ptr %total_write, align 8
  %20 = sub i64 %18, %19
  store i64 %20, ptr %remaining, align 8
  %21 = load i64, ptr %remaining, align 8
  %22 = trunc i64 %21 to i32
  %23 = icmp slt i32 %22, 1073741824
  %24 = select i1 %23, i32 %22, i32 1073741824
  store i32 %24, ptr %to_write, align 4
  %25 = load ptr, ptr %h, align 8
  %26 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = load i64, ptr %total_write, align 8
  %29 = getelementptr i8, ptr %27, i64 %28
  %30 = load i32, ptr %to_write, align 4
  %31 = call x86_stdcallcc i32 @WriteFile(ptr %25, ptr %29, i32 %30, ptr %single_write_length, ptr null)
  store i32 %31, ptr %e, align 4
  %32 = load i32, ptr %single_write_length, align 4
  %33 = icmp ule i32 %32, 0
  %34 = zext i1 %33 to i8
  %35 = icmp ne i8 %34, 0
  br i1 %35, label %if.then1, label %cmp.or

cmp.or:                                           ; preds = %for.body
  %36 = load i32, ptr %e, align 4
  %37 = icmp ne i32 %36, 0
  br i1 %37, label %if.done2, label %if.then1

if.then1:                                         ; preds = %cmp.or, %for.body
  %38 = call x86_stdcallcc i32 @GetLastError()
  %39 = zext i32 %38 to i64
  store i64 %39, ptr %err, align 8
  %40 = load i64, ptr %total_write, align 8
  store i64 %40, ptr %n, align 8
  %41 = load i64, ptr %n, align 8
  %42 = load i64, ptr %err, align 8
  store i64 %41, ptr %n, align 8
  store i64 %42, ptr %err, align 8
  store i64 %41, ptr %1, align 8
  ret i64 %42

if.done2:                                         ; preds = %cmp.or
  %43 = load i32, ptr %single_write_length, align 4
  %44 = zext i32 %43 to i64
  %45 = load i64, ptr %total_write, align 8
  %46 = add i64 %45, %44
  store i64 %46, ptr %total_write, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %47 = load i64, ptr %total_write, align 8
  store i64 %47, ptr %n, align 8
  %48 = load i64, ptr %n, align 8
  %49 = load i64, ptr %err, align 8
  store i64 %48, ptr %n, align 8
  store i64 %49, ptr %err, align 8
  store i64 %48, ptr %1, align 8
  ret i64 %49
}

; Function Attrs: alwaysinline
define i8 @"runtime::[default_temp_allocator_arena.odin]::safe_add"(i64 %0, i64 %1, ptr noalias nonnull %2) #1 {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %z = alloca i64, align 8
  %did_overflow = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %3, align 8
  store i64 %1, ptr %4, align 8
  %5 = call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %0, i64 %1)
  %6 = extractvalue { i64, i1 } %5, 0
  %7 = extractvalue { i64, i1 } %5, 1
  store i64 %6, ptr %z, align 8
  %8 = zext i1 %7 to i8
  store i8 %8, ptr %did_overflow, align 1
  %9 = load i64, ptr %z, align 8
  %10 = load i8, ptr %did_overflow, align 1
  %11 = icmp eq i8 %10, 0
  %12 = zext i1 %11 to i8
  store i64 %9, ptr %2, align 8
  ret i8 %12
}

; Function Attrs: alwaysinline
define void @"runtime::[internal.odin]::byte_slice"(ptr noalias sret({ ptr, i64 }) %agg.result, ptr %0, i64 %1) #1 {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %4 = alloca ptr, align 8
  %5 = alloca { ptr, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  store ptr %0, ptr %4, align 8
  %6 = load ptr, ptr %4, align 8
  %7 = icmp sgt i64 %1, 0
  %8 = select i1 %7, i64 %1, i64 0
  %9 = getelementptr i8, ptr %6, i64 0
  %10 = sub i64 %8, 0
  %11 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %12 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 1
  store ptr %9, ptr %11, align 8
  store i64 %10, ptr %12, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %agg.result, ptr %5, i64 16, i1 false)
  ret void
}

define i8 @"runtime::memory_block_alloc"(ptr %0, i64 %1, i64 %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca %"runtime::Allocator", align 8
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca %"runtime::Allocator", align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %block = alloca ptr, align 8
  %err = alloca i8, align 1
  %total_size = alloca i64, align 8
  %base_offset = alloca i64, align 8
  %min_alignment = alloca i64, align 8
  %13 = alloca { ptr, i64 }, align 8
  %14 = alloca { { ptr, i64 }, i8 }, align 8
  %data = alloca { ptr, i64 }, align 8
  %15 = alloca ptr, align 8
  %end = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %10, ptr %0, i64 16, i1 false)
  store i64 %1, ptr %11, align 8
  store i64 %2, ptr %12, align 8
  store ptr null, ptr %block, align 8
  store i8 0, ptr %err, align 1
  %16 = icmp ugt i64 %2, 48
  %17 = select i1 %16, i64 %2, i64 48
  %18 = add i64 %1, %17
  store i64 %18, ptr %total_size, align 8
  %19 = icmp ugt i64 %2, 48
  %20 = select i1 %19, i64 %2, i64 48
  store i64 %20, ptr %base_offset, align 8
  %21 = icmp sgt i64 16, %2
  %22 = select i1 %21, i64 16, i64 %2
  store i64 %22, ptr %min_alignment, align 8
  %23 = load i64, ptr %total_size, align 8
  %24 = load i64, ptr %min_alignment, align 8
  call void @llvm.memset.inline.p0.i64(ptr %13, i8 0, i64 16, i1 false)
  call void @llvm.experimental.noalias.scope.decl(metadata !0)
  call void @llvm.experimental.noalias.scope.decl(metadata !3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 16, ptr %8)
  call void @llvm.lifetime.start.p0(i64 16, ptr %9)
  store i64 %23, ptr %6, align 8, !noalias !5
  store i64 %24, ptr %7, align 8, !noalias !5
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %8, ptr %10, i64 16, i1 false), !noalias !5
  call void @llvm.lifetime.start.p0(i64 8, ptr %5), !noalias !5
  store i64 %24, ptr %5, align 8, !noalias !5
  %25 = icmp sle i64 %24, 0
  %26 = zext i1 %25 to i8
  br i1 %25, label %if.then.i.i, label %if.done.i.i

if.then.i.i:                                      ; preds = %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %5), !noalias !5
  br label %"runtime::is_power_of_two_int.exit.i"

if.done.i.i:                                      ; preds = %entry
  %27 = sub i64 %24, 1
  %28 = and i64 %24, %27
  %29 = icmp eq i64 %28, 0
  %30 = zext i1 %29 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %5), !noalias !5
  br label %"runtime::is_power_of_two_int.exit.i"

"runtime::is_power_of_two_int.exit.i":            ; preds = %if.done.i.i, %if.then.i.i
  %31 = phi i8 [ 0, %if.then.i.i ], [ %30, %if.done.i.i ]
  %32 = icmp ne i8 %31, 0
  call void @"runtime::assert"(i1 zeroext %32, ptr @"ggv$runtime::mem_alloc$1", ptr %3, ptr nonnull %__.context_ptr), !noalias !0
  %33 = icmp eq i64 %23, 0
  %34 = zext i1 %33 to i8
  br i1 %33, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %"runtime::is_power_of_two_int.exit.i"
  %35 = load ptr, ptr %8, align 8, !noalias !5
  %36 = icmp eq ptr %35, null
  %37 = zext i1 %36 to i8
  br i1 %36, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %"runtime::is_power_of_two_int.exit.i"
  store { ptr, i64 } zeroinitializer, ptr %13, align 8, !alias.scope !0, !noalias !3
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 16, ptr %8)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::mem_alloc.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %38 = load ptr, ptr %8, align 8, !noalias !5
  %39 = getelementptr inbounds nuw %"runtime::Allocator", ptr %8, i32 0, i32 1
  %40 = load ptr, ptr %39, align 8, !noalias !5
  call void @llvm.memset.inline.p0.i64(ptr %9, i8 0, i64 16, i1 false), !noalias !5
  %41 = call i8 %38(ptr %40, i8 0, i64 %23, i64 %24, ptr null, i64 0, ptr %3, ptr %9, ptr nonnull %__.context_ptr), !noalias !0
  %42 = load { ptr, i64 }, ptr %9, align 8, !noalias !5
  store { ptr, i64 } %42, ptr %13, align 8, !alias.scope !0, !noalias !3
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 16, ptr %8)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::mem_alloc.exit"

"runtime::mem_alloc.exit":                        ; preds = %if.done.i, %if.then.i
  %43 = phi i8 [ 0, %if.then.i ], [ %41, %if.done.i ]
  %44 = load { ptr, i64 }, ptr %13, align 8
  %45 = icmp eq i8 %43, 0
  br i1 %45, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %"runtime::mem_alloc.exit"
  store i8 %43, ptr %err, align 1
  %46 = load ptr, ptr %block, align 8
  %47 = load i8, ptr %err, align 1
  store ptr %46, ptr %block, align 8
  store i8 %47, ptr %err, align 1
  store ptr %46, ptr %4, align 8
  ret i8 %47

or_return.continue:                               ; preds = %"runtime::mem_alloc.exit"
  store { ptr, i64 } %44, ptr %data, align 8
  %48 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %49 = load ptr, ptr %48, align 8
  store ptr %49, ptr %block, align 8
  %50 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %51 = load ptr, ptr %50, align 8
  %52 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 1
  %53 = load i64, ptr %52, align 8
  %54 = getelementptr i8, ptr %51, i64 %53
  store ptr %54, ptr %15, align 8
  %55 = load ptr, ptr %15, align 8
  %56 = ptrtoint ptr %55 to i64
  store i64 %56, ptr %end, align 8
  %57 = load ptr, ptr %block, align 8
  %58 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %57, i32 0, i32 1
  %59 = load %"runtime::Allocator", ptr %10, align 8
  store %"runtime::Allocator" %59, ptr %58, align 8
  %60 = load ptr, ptr %block, align 8
  %61 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %60, i32 0, i32 2
  %62 = load ptr, ptr %block, align 8
  %63 = ptrtoint ptr %62 to i64
  %64 = load i64, ptr %base_offset, align 8
  %65 = add i64 %63, %64
  %66 = inttoptr i64 %65 to ptr
  store ptr %66, ptr %61, align 8
  %67 = load ptr, ptr %block, align 8
  %68 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %67, i32 0, i32 4
  %69 = load i64, ptr %end, align 8
  %70 = load ptr, ptr %block, align 8
  %71 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %70, i32 0, i32 2
  %72 = load ptr, ptr %71, align 8
  %73 = ptrtoint ptr %72 to i64
  %74 = sub i64 %69, %73
  store i64 %74, ptr %68, align 8
  %75 = load ptr, ptr %block, align 8
  %76 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %75, i32 0, i32 3
  %77 = load i64, ptr %76, align 8
  %78 = icmp eq i64 %77, 0
  %79 = zext i1 %78 to i8
  %80 = icmp ne i8 %79, 0
  call void @"runtime::assert"(i1 zeroext %80, ptr @"ggv$runtime::memory_block_alloc$1", ptr @"scl$[memory_block_alloc1638]", ptr %__.context_ptr)
  %81 = load ptr, ptr %block, align 8
  %82 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %81, i32 0, i32 0
  %83 = load ptr, ptr %82, align 8
  %84 = icmp eq ptr %83, null
  %85 = zext i1 %84 to i8
  %86 = icmp ne i8 %85, 0
  call void @"runtime::assert"(i1 zeroext %86, ptr @"ggv$runtime::memory_block_alloc$2", ptr @"scl$[memory_block_alloc1664]", ptr %__.context_ptr)
  %87 = load ptr, ptr %block, align 8
  %88 = load i8, ptr %err, align 1
  store ptr %87, ptr %block, align 8
  store i8 %88, ptr %err, align 1
  store ptr %87, ptr %4, align 8
  ret i8 %88
}

define ptr @"runtime::_heap_resize"(ptr %0, i64 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %new_ptr = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = icmp eq i64 %1, 0
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  call void @"runtime::_heap_free"(ptr %0)
  ret ptr null

if.done:                                          ; preds = %entry
  %7 = icmp eq ptr %0, null
  %8 = zext i1 %7 to i8
  %9 = icmp ne i8 %8, 0
  br i1 %9, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  %10 = call ptr @"runtime::_heap_alloc"(i64 %1, i1 zeroext true)
  ret ptr %10

if.done2:                                         ; preds = %if.done
  %11 = call x86_stdcallcc ptr @GetProcessHeap()
  %12 = call x86_stdcallcc ptr @HeapReAlloc(ptr %11, i32 8, ptr %0, i64 %1)
  store ptr %12, ptr %new_ptr, align 8
  %13 = load ptr, ptr %new_ptr, align 8
  call void @"sanitizer::address_unpoison_rawptr"(ptr %13, i64 %1)
  %14 = load ptr, ptr %new_ptr, align 8
  ret ptr %14
}

; Function Attrs: alwaysinline
define i8 @"runtime::is_power_of_two_int"(i64 %0) #1 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = icmp sle i64 %0, 0
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %5 = sub i64 %0, 1
  %6 = and i64 %0, %5
  %7 = icmp eq i64 %6, 0
  %8 = zext i1 %7 to i8
  ret i8 %8
}

define void @"runtime::default_temp_allocator_destroy"(ptr %0, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = icmp ne ptr %0, null
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %1, align 8
  %6 = getelementptr inbounds nuw %"runtime::Default_Temp_Allocator", ptr %5, i32 0, i32 0
  call void @"runtime::arena_destroy"(ptr %6, ptr @"scl$[default_temp_allocator_destroy1111]", ptr %__.context_ptr)
  call void @llvm.memset.p0.i64(ptr %0, i8 0, i64 56, i1 false)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  ret void
}

define void @"runtime::default_random_generator_proc"(ptr %0, i64 %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca i64, align 8
  %5 = alloca { ptr, i64 }, align 8
  %r = alloca ptr, align 8
  %6 = alloca i64, align 8
  %pos = alloca i8, align 1
  %val = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %seed = alloca i64, align 8
  %info = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store i64 %1, ptr %4, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %2, i64 16, i1 false)
  %9 = icmp eq ptr %0, null
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr @"runtime::default_random_generator_proc-.global_rand_seed-40933", ptr %r, align 8
  br label %if.done

if.else:                                          ; preds = %entry
  store ptr %0, ptr %r, align 8
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  switch i64 %1, label %switch.done10 [
    i64 0, label %switch.case.body
    i64 1, label %switch.case.body6
    i64 2, label %switch.case.body7
  ]

switch.case.body:                                 ; preds = %if.done
  %12 = load ptr, ptr %r, align 8
  %13 = getelementptr inbounds nuw %"runtime::Default_Random_State", ptr %12, i32 0, i32 0
  %14 = load i64, ptr %13, align 8
  %15 = icmp eq i64 %14, 0
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %cmp.and, label %if.done2

cmp.and:                                          ; preds = %switch.case.body
  %18 = load ptr, ptr %r, align 8
  %19 = getelementptr inbounds nuw %"runtime::Default_Random_State", ptr %18, i32 0, i32 1
  %20 = load i64, ptr %19, align 8
  %21 = icmp eq i64 %20, 0
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %if.then1, label %if.done2

if.then1:                                         ; preds = %cmp.and
  %24 = load ptr, ptr %r, align 8
  call void @"runtime::default_random_generator_proc.init-1"(ptr %24, i64 0)
  br label %if.done2

if.done2:                                         ; preds = %if.then1, %cmp.and, %switch.case.body
  %25 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 1
  %26 = load i64, ptr %25, align 8
  switch i64 %26, label %switch.default.body [
    i64 8, label %switch.case.body3
  ]

switch.case.body3:                                ; preds = %if.done2
  %27 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = load ptr, ptr %r, align 8
  %30 = call i64 @"runtime::default_random_generator_proc.read_u64-0"(ptr %29)
  store i64 %30, ptr %6, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %28, ptr %6, i64 8, i1 false)
  br label %switch.done

switch.default.body:                              ; preds = %if.done2
  store i8 0, ptr %pos, align 1
  store i64 0, ptr %val, align 8
  %31 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 1
  %32 = load i64, ptr %31, align 8
  store i64 %32, ptr %7, align 8
  store i64 -1, ptr %8, align 8
  br label %for.index.loop

for.index.loop:                                   ; preds = %if.done5, %switch.default.body
  %33 = load i64, ptr %8, align 8
  %34 = add i64 %33, 1
  store i64 %34, ptr %8, align 8
  %35 = load i64, ptr %7, align 8
  %36 = icmp slt i64 %34, %35
  br i1 %36, label %for.index.body, label %for.index.done

for.index.body:                                   ; preds = %for.index.loop
  %37 = load i64, ptr %8, align 8
  %38 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = getelementptr i8, ptr %39, i64 %37
  %41 = load i8, ptr %pos, align 1
  %42 = icmp eq i8 %41, 0
  %43 = zext i1 %42 to i8
  %44 = icmp ne i8 %43, 0
  br i1 %44, label %if.then4, label %if.done5

if.then4:                                         ; preds = %for.index.body
  %45 = load ptr, ptr %r, align 8
  %46 = call i64 @"runtime::default_random_generator_proc.read_u64-0"(ptr %45)
  store i64 %46, ptr %val, align 8
  store i8 7, ptr %pos, align 1
  br label %if.done5

if.done5:                                         ; preds = %if.then4, %for.index.body
  %47 = load i64, ptr %val, align 8
  %48 = trunc i64 %47 to i8
  store i8 %48, ptr %40, align 1
  %49 = load i64, ptr %val, align 8
  %50 = lshr i64 %49, 8
  %51 = select i1 true, i64 %50, i64 0
  store i64 %51, ptr %val, align 8
  %52 = load i8, ptr %pos, align 1
  %53 = sub i8 %52, 1
  store i8 %53, ptr %pos, align 1
  br label %for.index.loop

for.index.done:                                   ; preds = %for.index.loop
  br label %switch.done

switch.done:                                      ; preds = %for.index.done, %switch.case.body3
  br label %switch.done10

switch.case.body6:                                ; preds = %if.done
  store i64 0, ptr %seed, align 8
  %54 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %55 = load ptr, ptr %54, align 8
  %56 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 1
  %57 = load i64, ptr %56, align 8
  %58 = icmp slt i64 8, %57
  %59 = select i1 %58, i64 8, i64 %57
  %60 = call ptr @"runtime::mem_copy_non_overlapping"(ptr %seed, ptr %55, i64 %59)
  %61 = load ptr, ptr %r, align 8
  %62 = load i64, ptr %seed, align 8
  call void @"runtime::default_random_generator_proc.init-1"(ptr %61, i64 %62)
  br label %switch.done10

switch.case.body7:                                ; preds = %if.done
  %63 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 1
  %64 = load i64, ptr %63, align 8
  %65 = icmp ne i64 %64, 4
  %66 = zext i1 %65 to i8
  %67 = icmp ne i8 %66, 0
  br i1 %67, label %if.then8, label %if.done9

if.then8:                                         ; preds = %switch.case.body7
  ret void

if.done9:                                         ; preds = %switch.case.body7
  %68 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %info, align 8
  %70 = load ptr, ptr %info, align 8
  %71 = load i32, ptr %70, align 4
  %72 = or i32 %71, 10
  store i32 %72, ptr %70, align 4
  br label %switch.done10

switch.done10:                                    ; preds = %if.done9, %switch.case.body6, %switch.done, %if.done
  ret void
}

; Function Attrs: noreturn
define void @"runtime::slice_handle_error"(ptr %0, i32 %1, i32 %2, i64 %3, i64 %4, i64 %5) #0 {
decls:
  %6 = alloca %..string, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca %"runtime::Source_Code_Location", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %6, ptr %0, i64 16, i1 false)
  store i32 %1, ptr %7, align 4
  store i32 %2, ptr %8, align 4
  store i64 %3, ptr %9, align 8
  store i64 %4, ptr %10, align 8
  store i64 %5, ptr %11, align 8
  call void @llvm.memset.p0.i64(ptr %12, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %12, i8 0, i64 40, i1 false)
  %13 = load %..string, ptr %6, align 8
  %14 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %12, i32 0, i32 0
  store %..string %13, ptr %14, align 8
  %15 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %12, i32 0, i32 1
  store i32 %1, ptr %15, align 4
  %16 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %12, i32 0, i32 2
  store i32 %2, ptr %16, align 4
  call void @"runtime::print_caller_location"(ptr %12)
  %17 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::slice_handle_error$1")
  call void @"runtime::print_i64"(i64 %3)
  %18 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::slice_handle_error$2")
  call void @"runtime::print_i64"(i64 %4)
  %19 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::slice_handle_error$3")
  call void @"runtime::print_i64"(i64 %5)
  %20 = call i64 @"runtime::print_byte"(i8 10)
  call void @"runtime::bounds_trap"()
  unreachable
}

; Function Attrs: noinline
define i32 @main(i32 %0, ptr %1) #2 {
decls:
  %2 = alloca i32, align 4
  %3 = alloca ptr, align 8
  %4 = alloca { ptr, i64 }, align 8
  %5 = alloca %"runtime::Context", align 8
  %6 = alloca %"runtime::Context", align 8
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %2, align 4
  store ptr %1, ptr %3, align 8
  %7 = load ptr, ptr %3, align 8
  %8 = sext i32 %0 to i64
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$main$1", i32 43, i32 17, i64 0, i64 %8)
  %9 = getelementptr ptr, ptr %7, i64 0
  %10 = sub i64 %8, 0
  %11 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  %12 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 1
  store ptr %9, ptr %11, align 8
  store i64 %10, ptr %12, align 8
  %13 = load { ptr, i64 }, ptr %4, align 8
  store { ptr, i64 } %13, ptr @"runtime::args__", align 8
  call void @llvm.memset.p0.i64(ptr %5, i8 0, i64 112, i1 false)
  call void @"runtime::[core.odin]::__init_context"(ptr %5)
  call void @llvm.memset.p0.i64(ptr %6, i8 0, i64 112, i1 false)
  call void @"runtime::default_context"(ptr sret(ptr) %6)
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %5, ptr align 8 %6, i64 112, i1 false)
  call void @"__$startup_runtime"(ptr %5) #2
  call void @"main::main"(ptr %5)
  call void @"__$cleanup_runtime"(ptr %5) #2
  ret i32 0
}

define i8 @"runtime::default_temp_allocator_proc"(ptr %0, i8 %1, i64 %2, i64 %3, ptr %4, i64 %5, ptr %6, ptr noalias nonnull %7, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %8 = alloca ptr, align 8
  %9 = alloca i8, align 1
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i64, align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %s = alloca ptr, align 8
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %8, align 8
  store i8 %1, ptr %9, align 1
  store i64 %2, ptr %10, align 8
  store i64 %3, ptr %11, align 8
  store ptr %4, ptr %12, align 8
  store i64 %5, ptr %13, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  store ptr %0, ptr %s, align 8
  %16 = load ptr, ptr %s, align 8
  %17 = getelementptr inbounds nuw %"runtime::Default_Temp_Allocator", ptr %16, i32 0, i32 0
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false)
  %18 = call i8 @"runtime::arena_allocator_proc"(ptr %17, i8 %1, i64 %2, i64 %3, ptr %4, i64 %5, ptr %6, ptr %14, ptr %__.context_ptr)
  %19 = load { ptr, i64 }, ptr %14, align 8
  store { ptr, i64 } %19, ptr %data, align 8
  store i8 %18, ptr %err, align 1
  store { ptr, i64 } %19, ptr %7, align 8
  ret i8 %18
}

define void @"runtime::_heap_free"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = icmp eq ptr %0, null
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  %5 = call x86_stdcallcc ptr @GetProcessHeap()
  %6 = call x86_stdcallcc i32 @HeapFree(ptr %5, i32 0, ptr %0)
  ret void
}

; Function Attrs: noreturn
define void @"runtime::multi_pointer_slice_handle_error"(ptr %0, i32 %1, i32 %2, i64 %3, i64 %4) #0 {
decls:
  %5 = alloca %..string, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca %"runtime::Source_Code_Location", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %0, i64 16, i1 false)
  store i32 %1, ptr %6, align 4
  store i32 %2, ptr %7, align 4
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  call void @llvm.memset.p0.i64(ptr %10, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %10, i8 0, i64 40, i1 false)
  %11 = load %..string, ptr %5, align 8
  %12 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %10, i32 0, i32 0
  store %..string %11, ptr %12, align 8
  %13 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %10, i32 0, i32 1
  store i32 %1, ptr %13, align 4
  %14 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %10, i32 0, i32 2
  store i32 %2, ptr %14, align 4
  call void @"runtime::print_caller_location"(ptr %10)
  %15 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::multi_pointer_slice_handle_error$1")
  call void @"runtime::print_i64"(i64 %3)
  %16 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::multi_pointer_slice_handle_error$2")
  call void @"runtime::print_i64"(i64 %4)
  %17 = call i64 @"runtime::print_byte"(i8 10)
  call void @"runtime::bounds_trap"()
  unreachable
}

define void @"runtime::default_temp_allocator_temp_begin"(ptr noalias sret(%"runtime::Arena_Temp") %agg.result, ptr %0, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %temp = alloca %"runtime::Arena_Temp", align 8
  %1 = alloca %"runtime::Arena_Temp", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memset.inline.p0.i64(ptr %temp, i8 0, i64 24, i1 false)
  %2 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 1
  %3 = getelementptr inbounds nuw %"runtime::Allocator", ptr %2, i32 0, i32 1
  %4 = load ptr, ptr %3, align 8
  %5 = icmp eq ptr %4, @"runtime::global_default_temp_allocator_data"
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  call void @llvm.memset.inline.p0.i64(ptr %1, i8 0, i64 24, i1 false)
  call void @"runtime::arena_temp_begin"(ptr sret(ptr) %1, ptr @"runtime::global_default_temp_allocator_data", ptr %0, ptr %__.context_ptr)
  %8 = load %"runtime::Arena_Temp", ptr %1, align 8
  store %"runtime::Arena_Temp" %8, ptr %temp, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %9 = load %"runtime::Arena_Temp", ptr %temp, align 8
  store %"runtime::Arena_Temp" %9, ptr %temp, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %agg.result, ptr %temp, i64 24, i1 false)
  ret void
}

define void @"runtime::memory_block_dealloc"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca %"runtime::Allocator", align 8
  %4 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  %5 = alloca ptr, align 8
  %allocator = alloca %"runtime::Allocator", align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %5, align 8
  %6 = icmp ne ptr %0, null
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %9 = load ptr, ptr %5, align 8
  %10 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %9, i32 0, i32 1
  %11 = load %"runtime::Allocator", ptr %10, align 8
  store %"runtime::Allocator" %11, ptr %allocator, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %2)
  call void @llvm.lifetime.start.p0(i64 16, ptr %3)
  call void @llvm.lifetime.start.p0(i64 16, ptr %4)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %0, ptr %2, align 8, !noalias !6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %allocator, i64 16, i1 false), !noalias !6
  %12 = icmp eq ptr %0, null
  %13 = zext i1 %12 to i8
  br i1 %12, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %if.then
  %14 = load ptr, ptr %3, align 8, !noalias !6
  %15 = icmp eq ptr %14, null
  %16 = zext i1 %15 to i8
  br i1 %15, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %if.then
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 16, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %17 = load ptr, ptr %3, align 8, !noalias !6
  %18 = getelementptr inbounds nuw %"runtime::Allocator", ptr %3, i32 0, i32 1
  %19 = load ptr, ptr %18, align 8, !noalias !6
  call void @llvm.memset.inline.p0.i64(ptr %4, i8 0, i64 16, i1 false), !noalias !6
  %20 = call i8 %17(ptr %19, i8 1, i64 0, i64 0, ptr %0, i64 0, ptr %1, ptr %4, ptr nonnull %__.context_ptr)
  store i8 %20, ptr %err.i, align 1, !noalias !6
  %21 = load i8, ptr %err.i, align 1, !noalias !6
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 16, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free.exit"

"runtime::mem_free.exit":                         ; preds = %if.done.i, %if.then.i
  br label %if.done

if.done:                                          ; preds = %"runtime::mem_free.exit", %entry
  ret void
}

define void @"runtime::multi_pointer_slice_expr_error"(ptr %0, i32 %1, i32 %2, i64 %3, i64 %4) {
decls:
  %5 = alloca %..string, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %0, i64 16, i1 false)
  store i32 %1, ptr %6, align 4
  store i32 %2, ptr %7, align 4
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  %10 = icmp sle i64 %3, %4
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  call void @"runtime::multi_pointer_slice_handle_error"(ptr %5, i32 %1, i32 %2, i64 %3, i64 %4)
  unreachable
}

define void @"runtime::default_temp_allocator_temp_end"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  br label %entry

entry:                                            ; preds = %decls
  call void @"runtime::arena_temp_end"(ptr %0, ptr %1, ptr %__.context_ptr)
  ret void
}

define i8 @"runtime::alloc_from_memory_block"(ptr %0, i64 %1, i64 %2, ptr noalias nonnull %3, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %z.i5 = alloca i64, align 8
  %did_overflow.i6 = alloca i8, align 1
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %z.i = alloca i64, align 8
  %did_overflow.i = alloca i8, align 1
  %8 = alloca ptr, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %alignment_offset = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca { i64, i8 }, align 8
  %size = alloca i64, align 8
  %size_ok = alloca i8, align 1
  %13 = alloca i64, align 8
  %14 = alloca { i64, i8 }, align 8
  %to_be_used = alloca i64, align 8
  %ok = alloca i8, align 1
  %15 = alloca ptr, align 8
  %16 = alloca { ptr, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %8, align 8
  store i64 %1, ptr %9, align 8
  store i64 %2, ptr %10, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %17 = icmp eq ptr %0, null
  %18 = zext i1 %17 to i8
  %19 = icmp ne i8 %18, 0
  br i1 %19, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store { ptr, i64 } zeroinitializer, ptr %data, align 8
  store i8 1, ptr %err, align 1
  store { ptr, i64 } zeroinitializer, ptr %3, align 8
  ret i8 1

if.done:                                          ; preds = %entry
  %20 = call i64 @"runtime::alloc_from_memory_block.calc_alignment_offset-0"(ptr %0, i64 %2)
  store i64 %20, ptr %alignment_offset, align 8
  %21 = load i64, ptr %alignment_offset, align 8
  store i64 0, ptr %11, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !9)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %z.i5)
  call void @llvm.lifetime.start.p0(i64 1, ptr %did_overflow.i6)
  store i64 %1, ptr %4, align 8, !noalias !9
  store i64 %21, ptr %5, align 8, !noalias !9
  %22 = call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %1, i64 %21)
  %23 = extractvalue { i64, i1 } %22, 0
  %24 = extractvalue { i64, i1 } %22, 1
  store i64 %23, ptr %z.i5, align 8, !noalias !9
  %25 = zext i1 %24 to i8
  store i8 %25, ptr %did_overflow.i6, align 1, !noalias !9
  %26 = load i64, ptr %z.i5, align 8, !noalias !9
  %27 = load i8, ptr %did_overflow.i6, align 1, !noalias !9
  %28 = icmp eq i8 %27, 0
  %29 = zext i1 %28 to i8
  store i64 %26, ptr %11, align 8, !alias.scope !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %z.i5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %did_overflow.i6)
  %30 = load i64, ptr %11, align 8
  store i64 %30, ptr %size, align 8
  store i8 %29, ptr %size_ok, align 1
  %31 = load i8, ptr %size_ok, align 1
  %32 = icmp ne i8 %31, 0
  br i1 %32, label %if.done2, label %if.then1

if.then1:                                         ; preds = %if.done
  store i8 1, ptr %err, align 1
  %33 = load { ptr, i64 }, ptr %data, align 8
  %34 = load i8, ptr %err, align 1
  store { ptr, i64 } %33, ptr %data, align 8
  store i8 %34, ptr %err, align 1
  store { ptr, i64 } %33, ptr %3, align 8
  ret i8 %34

if.done2:                                         ; preds = %if.done
  br label %if.init

if.init:                                          ; preds = %if.done2
  %35 = load ptr, ptr %8, align 8
  %36 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %35, i32 0, i32 3
  %37 = load i64, ptr %36, align 8
  %38 = load i64, ptr %size, align 8
  store i64 0, ptr %13, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !12)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %z.i)
  call void @llvm.lifetime.start.p0(i64 1, ptr %did_overflow.i)
  store i64 %37, ptr %6, align 8, !noalias !12
  store i64 %38, ptr %7, align 8, !noalias !12
  %39 = call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %37, i64 %38)
  %40 = extractvalue { i64, i1 } %39, 0
  %41 = extractvalue { i64, i1 } %39, 1
  store i64 %40, ptr %z.i, align 8, !noalias !12
  %42 = zext i1 %41 to i8
  store i8 %42, ptr %did_overflow.i, align 1, !noalias !12
  %43 = load i64, ptr %z.i, align 8, !noalias !12
  %44 = load i8, ptr %did_overflow.i, align 1, !noalias !12
  %45 = icmp eq i8 %44, 0
  %46 = zext i1 %45 to i8
  store i64 %43, ptr %13, align 8, !alias.scope !12
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %z.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %did_overflow.i)
  %47 = load i64, ptr %13, align 8
  store i64 %47, ptr %to_be_used, align 8
  store i8 %46, ptr %ok, align 1
  %48 = load i8, ptr %ok, align 1
  %49 = icmp ne i8 %48, 0
  br i1 %49, label %cmp.or, label %if.then3

cmp.or:                                           ; preds = %if.init
  %50 = load i64, ptr %to_be_used, align 8
  %51 = load ptr, ptr %8, align 8
  %52 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %51, i32 0, i32 4
  %53 = load i64, ptr %52, align 8
  %54 = icmp ugt i64 %50, %53
  %55 = zext i1 %54 to i8
  %56 = icmp ne i8 %55, 0
  br i1 %56, label %if.then3, label %if.done4

if.then3:                                         ; preds = %cmp.or, %if.init
  store i8 1, ptr %err, align 1
  %57 = load { ptr, i64 }, ptr %data, align 8
  %58 = load i8, ptr %err, align 1
  store { ptr, i64 } %57, ptr %data, align 8
  store i8 %58, ptr %err, align 1
  store { ptr, i64 } %57, ptr %3, align 8
  ret i8 %58

if.done4:                                         ; preds = %cmp.or
  %59 = load ptr, ptr %8, align 8
  %60 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %59, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %8, align 8
  %63 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %62, i32 0, i32 3
  %64 = load i64, ptr %63, align 8
  %65 = load i64, ptr %alignment_offset, align 8
  %66 = add i64 %64, %65
  %67 = getelementptr i8, ptr %61, i64 %66
  store ptr %67, ptr %15, align 8
  %68 = load ptr, ptr %15, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::alloc_from_memory_block$1", i32 89, i32 49, i64 0, i64 %1)
  %69 = getelementptr i8, ptr %68, i64 0
  %70 = sub i64 %1, 0
  %71 = getelementptr inbounds nuw { ptr, i64 }, ptr %16, i32 0, i32 0
  %72 = getelementptr inbounds nuw { ptr, i64 }, ptr %16, i32 0, i32 1
  store ptr %69, ptr %71, align 8
  store i64 %70, ptr %72, align 8
  %73 = load { ptr, i64 }, ptr %16, align 8
  store { ptr, i64 } %73, ptr %data, align 8
  %74 = load ptr, ptr %8, align 8
  %75 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %74, i32 0, i32 3
  %76 = load i64, ptr %size, align 8
  %77 = load i64, ptr %75, align 8
  %78 = add i64 %77, %76
  store i64 %78, ptr %75, align 8
  %79 = load { ptr, i64 }, ptr %data, align 8
  %80 = load i8, ptr %err, align 1
  store { ptr, i64 } %79, ptr %data, align 8
  store i8 %80, ptr %err, align 1
  store { ptr, i64 } %79, ptr %3, align 8
  ret i8 %80
}

define void @"runtime::slice_expr_error_hi"(ptr %0, i32 %1, i32 %2, i64 %3, i64 %4) {
decls:
  %5 = alloca %..string, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %0, i64 16, i1 false)
  store i32 %1, ptr %6, align 4
  store i32 %2, ptr %7, align 4
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  %10 = icmp sle i64 0, %3
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %13 = icmp sle i64 %3, %4
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  ret void

if.done:                                          ; preds = %cmp.and, %entry
  call void @"runtime::slice_handle_error"(ptr %5, i32 %1, i32 %2, i64 0, i64 %3, i64 %4)
  unreachable
}

; Function Attrs: alwaysinline
define void @"runtime::DEFAULT_TEMP_ALLOCATOR_TEMP_GUARD"(ptr noalias sret(%"runtime::Source_Code_Location") %agg.result, i1 zeroext %0, ptr %1, ptr noalias nonnull %2, ptr noalias nocapture nonnull %__.context_ptr) #1 {
decls:
  %3 = alloca i8, align 1
  %4 = alloca %"runtime::Arena_Temp", align 8
  br label %entry

entry:                                            ; preds = %decls
  %5 = zext i1 %0 to i8
  store i8 %5, ptr %3, align 1
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %7 = load %"runtime::Source_Code_Location", ptr %1, align 8
  store %"runtime::Arena_Temp" zeroinitializer, ptr %2, align 8
  store %"runtime::Source_Code_Location" %7, ptr %agg.result, align 8
  ret void

if.else:                                          ; preds = %entry
  call void @llvm.memset.inline.p0.i64(ptr %4, i8 0, i64 24, i1 false)
  call void @"runtime::default_temp_allocator_temp_begin"(ptr sret(ptr) %4, ptr %1, ptr %__.context_ptr)
  %8 = load %"runtime::Arena_Temp", ptr %4, align 8
  %9 = load %"runtime::Source_Code_Location", ptr %1, align 8
  store %"runtime::Arena_Temp" %8, ptr %2, align 8
  store %"runtime::Source_Code_Location" %9, ptr %agg.result, align 8
  ret void

if.done:                                          ; No predecessors!
  unreachable
}

define i64 @"runtime::encode_rune"(i32 %0, ptr noalias nonnull %1) {
decls:
  %2 = alloca i32, align 4
  %r = alloca i32, align 4
  %buf = alloca [4 x i8], align 1
  %i = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %2, align 4
  store i32 %0, ptr %r, align 4
  call void @llvm.memset.inline.p0.i64(ptr %buf, i8 0, i64 4, i1 false)
  %3 = load i32, ptr %r, align 4
  store i32 %3, ptr %i, align 4
  %4 = load i32, ptr %i, align 4
  %5 = icmp ule i32 %4, 127
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %8 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %9 = load i32, ptr %r, align 4
  %10 = trunc i32 %9 to i8
  store i8 %10, ptr %8, align 1
  %11 = load [4 x i8], ptr %buf, align 1
  store [4 x i8] %11, ptr %1, align 1
  ret i64 1

if.done:                                          ; preds = %entry
  %12 = load i32, ptr %i, align 4
  %13 = icmp ule i32 %12, 2047
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  %16 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %17 = load i32, ptr %r, align 4
  %18 = ashr i32 %17, 6
  %19 = select i1 true, i32 %18, i32 0
  %20 = trunc i32 %19 to i8
  %21 = or i8 -64, %20
  store i8 %21, ptr %16, align 1
  %22 = getelementptr [4 x i8], ptr %buf, i64 0, i64 1
  %23 = load i32, ptr %r, align 4
  %24 = trunc i32 %23 to i8
  %25 = and i8 %24, 63
  %26 = or i8 -128, %25
  store i8 %26, ptr %22, align 1
  %27 = load [4 x i8], ptr %buf, align 1
  store [4 x i8] %27, ptr %1, align 1
  ret i64 2

if.done2:                                         ; preds = %if.done
  %28 = load i32, ptr %i, align 4
  %29 = icmp ugt i32 %28, 1114111
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %if.then3, label %cmp.or

cmp.or:                                           ; preds = %if.done2
  %32 = load i32, ptr %i, align 4
  %33 = icmp ule i32 55296, %32
  %34 = zext i1 %33 to i8
  %35 = icmp ne i8 %34, 0
  br i1 %35, label %cmp.and, label %if.done4

cmp.and:                                          ; preds = %cmp.or
  %36 = load i32, ptr %i, align 4
  %37 = icmp ule i32 %36, 57343
  %38 = zext i1 %37 to i8
  %39 = icmp ne i8 %38, 0
  br i1 %39, label %if.then3, label %if.done4

if.then3:                                         ; preds = %cmp.and, %if.done2
  store i32 65533, ptr %r, align 4
  br label %if.done4

if.done4:                                         ; preds = %if.then3, %cmp.and, %cmp.or
  %40 = load i32, ptr %i, align 4
  %41 = icmp ule i32 %40, 65535
  %42 = zext i1 %41 to i8
  %43 = icmp ne i8 %42, 0
  br i1 %43, label %if.then5, label %if.done6

if.then5:                                         ; preds = %if.done4
  %44 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %45 = load i32, ptr %r, align 4
  %46 = ashr i32 %45, 12
  %47 = select i1 true, i32 %46, i32 0
  %48 = trunc i32 %47 to i8
  %49 = or i8 -32, %48
  store i8 %49, ptr %44, align 1
  %50 = getelementptr [4 x i8], ptr %buf, i64 0, i64 1
  %51 = load i32, ptr %r, align 4
  %52 = ashr i32 %51, 6
  %53 = select i1 true, i32 %52, i32 0
  %54 = trunc i32 %53 to i8
  %55 = and i8 %54, 63
  %56 = or i8 -128, %55
  store i8 %56, ptr %50, align 1
  %57 = getelementptr [4 x i8], ptr %buf, i64 0, i64 2
  %58 = load i32, ptr %r, align 4
  %59 = trunc i32 %58 to i8
  %60 = and i8 %59, 63
  %61 = or i8 -128, %60
  store i8 %61, ptr %57, align 1
  %62 = load [4 x i8], ptr %buf, align 1
  store [4 x i8] %62, ptr %1, align 1
  ret i64 3

if.done6:                                         ; preds = %if.done4
  %63 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %64 = load i32, ptr %r, align 4
  %65 = ashr i32 %64, 18
  %66 = select i1 true, i32 %65, i32 0
  %67 = trunc i32 %66 to i8
  %68 = or i8 -16, %67
  store i8 %68, ptr %63, align 1
  %69 = getelementptr [4 x i8], ptr %buf, i64 0, i64 1
  %70 = load i32, ptr %r, align 4
  %71 = ashr i32 %70, 12
  %72 = select i1 true, i32 %71, i32 0
  %73 = trunc i32 %72 to i8
  %74 = and i8 %73, 63
  %75 = or i8 -128, %74
  store i8 %75, ptr %69, align 1
  %76 = getelementptr [4 x i8], ptr %buf, i64 0, i64 2
  %77 = load i32, ptr %r, align 4
  %78 = ashr i32 %77, 6
  %79 = select i1 true, i32 %78, i32 0
  %80 = trunc i32 %79 to i8
  %81 = and i8 %80, 63
  %82 = or i8 -128, %81
  store i8 %82, ptr %76, align 1
  %83 = getelementptr [4 x i8], ptr %buf, i64 0, i64 3
  %84 = load i32, ptr %r, align 4
  %85 = trunc i32 %84 to i8
  %86 = and i8 %85, 63
  %87 = or i8 -128, %86
  store i8 %87, ptr %83, align 1
  %88 = load [4 x i8], ptr %buf, align 1
  store [4 x i8] %88, ptr %1, align 1
  ret i64 4
}

define void @"runtime::slice_expr_error_lo_hi"(ptr %0, i32 %1, i32 %2, i64 %3, i64 %4, i64 %5) {
decls:
  %6 = alloca %..string, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %6, ptr %0, i64 16, i1 false)
  store i32 %1, ptr %7, align 4
  store i32 %2, ptr %8, align 4
  store i64 %3, ptr %9, align 8
  store i64 %4, ptr %10, align 8
  store i64 %5, ptr %11, align 8
  %12 = icmp sle i64 0, %3
  %13 = zext i1 %12 to i8
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %15 = icmp sle i64 %3, %5
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %cmp.and1, label %if.done

cmp.and1:                                         ; preds = %cmp.and
  %18 = icmp sle i64 %3, %4
  %19 = zext i1 %18 to i8
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %cmp.and2, label %if.done

cmp.and2:                                         ; preds = %cmp.and1
  %21 = icmp sle i64 %4, %5
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and2
  ret void

if.done:                                          ; preds = %cmp.and2, %cmp.and1, %cmp.and, %entry
  call void @"runtime::slice_handle_error"(ptr %6, i32 %1, i32 %2, i64 %3, i64 %4, i64 %5)
  unreachable
}

define ptr @"runtime::memset"(ptr %0, i32 %1, i64 %2) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca i32, align 4
  %5 = alloca i64, align 8
  %b = alloca i8, align 1
  %p = alloca ptr, align 8
  %i = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store i32 %1, ptr %4, align 4
  store i64 %2, ptr %5, align 8
  %6 = icmp ne ptr %0, null
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %9 = icmp ne i64 %2, 0
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  %12 = trunc i32 %1 to i8
  store i8 %12, ptr %b, align 1
  store ptr %0, ptr %p, align 8
  br label %for.init

for.init:                                         ; preds = %if.then
  store i64 0, ptr %i, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %13 = load i64, ptr %i, align 8
  %14 = icmp slt i64 %13, %2
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %17 = load ptr, ptr %p, align 8
  %18 = load i64, ptr %i, align 8
  %19 = getelementptr i8, ptr %17, i64 %18
  %20 = load i8, ptr %b, align 1
  store i8 %20, ptr %19, align 1
  br label %for.post

for.post:                                         ; preds = %for.body
  %21 = load i64, ptr %i, align 8
  %22 = add i64 %21, 1
  store i64 %22, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  br label %if.done

if.done:                                          ; preds = %for.done, %cmp.and, %entry
  ret ptr %0
}

define ptr @"runtime::mem_copy_non_overlapping"(ptr %0, ptr %1, i64 %2) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store ptr %1, ptr %4, align 8
  store i64 %2, ptr %5, align 8
  %6 = icmp ne ptr %1, null
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %9 = icmp ne ptr %0, %1
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %cmp.and1, label %if.done

cmp.and1:                                         ; preds = %cmp.and
  %12 = icmp sgt i64 %2, 0
  %13 = zext i1 %12 to i8
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and1
  call void @llvm.memcpy.p0.p0.i64(ptr %0, ptr %1, i64 %2, i1 false)
  br label %if.done

if.done:                                          ; preds = %if.then, %cmp.and1, %cmp.and, %entry
  ret ptr %0
}

; Function Attrs: noinline
define i64 @"runtime::print_string"(ptr %0) #2 {
decls:
  %1 = alloca %..string, align 8
  %n = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %1, ptr %0, i64 16, i1 false)
  store i64 0, ptr %n, align 8
  store i64 0, ptr %2, align 8
  %4 = call i64 @"runtime::stderr_write"(ptr %1, ptr %2)
  %5 = load i64, ptr %2, align 8
  store i64 %5, ptr %n, align 8
  %6 = load i64, ptr %n, align 8
  store i64 %6, ptr %n, align 8
  ret i64 %6
}

define i8 @"runtime::arena_alloc"(ptr %0, i64 %1, i64 %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca ptr, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %size = alloca i64, align 8
  %prev_used = alloca i64, align 8
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca { { ptr, i64 }, i8 }, align 8
  %needed = alloca i64, align 8
  %block_size = alloca i64, align 8
  %10 = alloca %"runtime::Allocator", align 8
  %11 = alloca ptr, align 8
  %12 = alloca { ptr, i8 }, align 8
  %new_block = alloca ptr, align 8
  %13 = alloca { ptr, i64 }, align 8
  %14 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  store i64 %2, ptr %7, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %15 = sub i64 %2, 1
  %16 = and i64 %2, %15
  %17 = icmp eq i64 %16, 0
  %18 = zext i1 %17 to i8
  %19 = icmp ne i8 %18, 0
  call void @"runtime::assert"(i1 zeroext %19, ptr @"ggv$runtime::arena_alloc$1", ptr %3, ptr %__.context_ptr)
  store i64 %1, ptr %size, align 8
  %20 = load i64, ptr %size, align 8
  %21 = icmp eq i64 %20, 0
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %24 = load { ptr, i64 }, ptr %data, align 8
  %25 = load i8, ptr %err, align 1
  store { ptr, i64 } %24, ptr %data, align 8
  store i8 %25, ptr %err, align 1
  store { ptr, i64 } %24, ptr %4, align 8
  ret i8 %25

if.done:                                          ; preds = %entry
  %26 = load ptr, ptr %5, align 8
  %27 = getelementptr inbounds nuw %"runtime::Arena", ptr %26, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  %29 = icmp eq ptr %28, null
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.done
  br label %if.done2

if.else:                                          ; preds = %if.done
  %32 = load ptr, ptr %5, align 8
  %33 = getelementptr inbounds nuw %"runtime::Arena", ptr %32, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %34, i32 0, i32 3
  %36 = load i64, ptr %35, align 8
  br label %if.done2

if.done2:                                         ; preds = %if.else, %if.then1
  %37 = phi i64 [ 0, %if.then1 ], [ %36, %if.else ]
  store i64 %37, ptr %prev_used, align 8
  %38 = load ptr, ptr %5, align 8
  %39 = getelementptr inbounds nuw %"runtime::Arena", ptr %38, i32 0, i32 1
  %40 = load ptr, ptr %39, align 8
  %41 = load i64, ptr %size, align 8
  call void @llvm.memset.inline.p0.i64(ptr %8, i8 0, i64 16, i1 false)
  %42 = call i8 @"runtime::alloc_from_memory_block"(ptr %40, i64 %41, i64 %2, ptr %8, ptr %__.context_ptr)
  %43 = load { ptr, i64 }, ptr %8, align 8
  store { ptr, i64 } %43, ptr %data, align 8
  store i8 %42, ptr %err, align 1
  %44 = load i8, ptr %err, align 1
  %45 = icmp eq i8 %44, 1
  %46 = zext i1 %45 to i8
  %47 = icmp ne i8 %46, 0
  br i1 %47, label %if.then3, label %if.done8

if.then3:                                         ; preds = %if.done2
  %48 = load ptr, ptr %5, align 8
  %49 = getelementptr inbounds nuw %"runtime::Arena", ptr %48, i32 0, i32 4
  %50 = load i64, ptr %49, align 8
  %51 = icmp eq i64 %50, 0
  %52 = zext i1 %51 to i8
  %53 = icmp ne i8 %52, 0
  br i1 %53, label %if.then4, label %if.done5

if.then4:                                         ; preds = %if.then3
  %54 = load ptr, ptr %5, align 8
  %55 = getelementptr inbounds nuw %"runtime::Arena", ptr %54, i32 0, i32 4
  store i64 4194304, ptr %55, align 8
  br label %if.done5

if.done5:                                         ; preds = %if.then4, %if.then3
  %56 = load i64, ptr %size, align 8
  %57 = call i64 @"runtime::arena_alloc.align_forward_uint-0"(i64 %56, i64 %2)
  store i64 %57, ptr %needed, align 8
  %58 = load ptr, ptr %5, align 8
  %59 = getelementptr inbounds nuw %"runtime::Arena", ptr %58, i32 0, i32 4
  %60 = load i64, ptr %59, align 8
  %61 = load i64, ptr %needed, align 8
  %62 = icmp ugt i64 %61, %60
  %63 = select i1 %62, i64 %61, i64 %60
  store i64 %63, ptr %block_size, align 8
  %64 = load ptr, ptr %5, align 8
  %65 = getelementptr inbounds nuw %"runtime::Arena", ptr %64, i32 0, i32 0
  %66 = getelementptr inbounds nuw %"runtime::Allocator", ptr %65, i32 0, i32 0
  %67 = load ptr, ptr %66, align 8
  %68 = icmp eq ptr %67, null
  %69 = zext i1 %68 to i8
  %70 = icmp ne i8 %69, 0
  br i1 %70, label %if.then6, label %if.done7

if.then6:                                         ; preds = %if.done5
  %71 = load ptr, ptr %5, align 8
  %72 = getelementptr inbounds nuw %"runtime::Arena", ptr %71, i32 0, i32 0
  call void @llvm.memset.inline.p0.i64(ptr %10, i8 0, i64 16, i1 false)
  call void @"runtime::heap_allocator"(ptr sret(ptr) %10, ptr %__.context_ptr)
  %73 = load %"runtime::Allocator", ptr %10, align 8
  store %"runtime::Allocator" %73, ptr %72, align 8
  br label %if.done7

if.done7:                                         ; preds = %if.then6, %if.done5
  %74 = load ptr, ptr %5, align 8
  %75 = getelementptr inbounds nuw %"runtime::Arena", ptr %74, i32 0, i32 0
  %76 = load i64, ptr %block_size, align 8
  store ptr null, ptr %11, align 8
  %77 = call i8 @"runtime::memory_block_alloc"(ptr %75, i64 %76, i64 %2, ptr %3, ptr %11, ptr %__.context_ptr)
  %78 = load ptr, ptr %11, align 8
  %79 = icmp eq i8 %77, 0
  br i1 %79, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %if.done7
  store i8 %77, ptr %err, align 1
  %80 = load { ptr, i64 }, ptr %data, align 8
  %81 = load i8, ptr %err, align 1
  store { ptr, i64 } %80, ptr %data, align 8
  store i8 %81, ptr %err, align 1
  store { ptr, i64 } %80, ptr %4, align 8
  ret i8 %81

or_return.continue:                               ; preds = %if.done7
  store ptr %78, ptr %new_block, align 8
  %82 = load ptr, ptr %new_block, align 8
  %83 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %82, i32 0, i32 0
  %84 = load ptr, ptr %5, align 8
  %85 = getelementptr inbounds nuw %"runtime::Arena", ptr %84, i32 0, i32 1
  %86 = load ptr, ptr %85, align 8
  store ptr %86, ptr %83, align 8
  %87 = load ptr, ptr %5, align 8
  %88 = getelementptr inbounds nuw %"runtime::Arena", ptr %87, i32 0, i32 1
  %89 = load ptr, ptr %new_block, align 8
  store ptr %89, ptr %88, align 8
  %90 = load ptr, ptr %5, align 8
  %91 = getelementptr inbounds nuw %"runtime::Arena", ptr %90, i32 0, i32 3
  %92 = load ptr, ptr %new_block, align 8
  %93 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %92, i32 0, i32 4
  %94 = load i64, ptr %93, align 8
  %95 = load i64, ptr %91, align 8
  %96 = add i64 %95, %94
  store i64 %96, ptr %91, align 8
  store i64 0, ptr %prev_used, align 8
  %97 = load ptr, ptr %5, align 8
  %98 = getelementptr inbounds nuw %"runtime::Arena", ptr %97, i32 0, i32 1
  %99 = load ptr, ptr %98, align 8
  %100 = load i64, ptr %size, align 8
  call void @llvm.memset.inline.p0.i64(ptr %13, i8 0, i64 16, i1 false)
  %101 = call i8 @"runtime::alloc_from_memory_block"(ptr %99, i64 %100, i64 %2, ptr %13, ptr %__.context_ptr)
  %102 = load { ptr, i64 }, ptr %13, align 8
  store { ptr, i64 } %102, ptr %data, align 8
  store i8 %101, ptr %err, align 1
  br label %if.done8

if.done8:                                         ; preds = %or_return.continue, %if.done2
  %103 = load ptr, ptr %5, align 8
  %104 = getelementptr inbounds nuw %"runtime::Arena", ptr %103, i32 0, i32 2
  %105 = load ptr, ptr %5, align 8
  %106 = getelementptr inbounds nuw %"runtime::Arena", ptr %105, i32 0, i32 1
  %107 = load ptr, ptr %106, align 8
  %108 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %107, i32 0, i32 3
  %109 = load i64, ptr %108, align 8
  %110 = load i64, ptr %prev_used, align 8
  %111 = sub i64 %109, %110
  %112 = load i64, ptr %104, align 8
  %113 = add i64 %112, %111
  store i64 %113, ptr %104, align 8
  %114 = load { ptr, i64 }, ptr %data, align 8
  %115 = load i8, ptr %err, align 1
  store { ptr, i64 } %114, ptr %data, align 8
  store i8 %115, ptr %err, align 1
  store { ptr, i64 } %114, ptr %4, align 8
  ret i8 %115
}

; Function Attrs: alwaysinline
define i8 @"runtime::mem_alloc_bytes"(i64 %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) #1 {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca %"runtime::Allocator", align 8
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %6, align 8
  store i64 %1, ptr %7, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %8, ptr %2, i64 16, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  store i64 %1, ptr %5, align 8
  %11 = icmp sle i64 %1, 0
  %12 = zext i1 %11 to i8
  br i1 %11, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  br label %"runtime::is_power_of_two_int.exit"

if.done.i:                                        ; preds = %entry
  %13 = sub i64 %1, 1
  %14 = and i64 %1, %13
  %15 = icmp eq i64 %14, 0
  %16 = zext i1 %15 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  br label %"runtime::is_power_of_two_int.exit"

"runtime::is_power_of_two_int.exit":              ; preds = %if.done.i, %if.then.i
  %17 = phi i8 [ 0, %if.then.i ], [ %16, %if.done.i ]
  %18 = icmp ne i8 %17, 0
  call void @"runtime::assert"(i1 zeroext %18, ptr @"ggv$runtime::mem_alloc_bytes$1", ptr %3, ptr %__.context_ptr)
  %19 = icmp eq i64 %0, 0
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %"runtime::is_power_of_two_int.exit"
  %22 = getelementptr inbounds nuw %"runtime::Allocator", ptr %8, i32 0, i32 0
  %23 = load ptr, ptr %22, align 8
  %24 = icmp eq ptr %23, null
  %25 = zext i1 %24 to i8
  %26 = icmp ne i8 %25, 0
  br i1 %26, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %"runtime::is_power_of_two_int.exit"
  store { ptr, i64 } zeroinitializer, ptr %4, align 8
  ret i8 0

if.done:                                          ; preds = %cmp.or
  %27 = getelementptr inbounds nuw %"runtime::Allocator", ptr %8, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr inbounds nuw %"runtime::Allocator", ptr %8, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  call void @llvm.memset.inline.p0.i64(ptr %9, i8 0, i64 16, i1 false)
  %31 = call i8 %28(ptr %30, i8 0, i64 %0, i64 %1, ptr null, i64 0, ptr %3, ptr %9, ptr %__.context_ptr)
  %32 = load { ptr, i64 }, ptr %9, align 8
  store { ptr, i64 } %32, ptr %4, align 8
  ret i8 %31
}

define i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]text_analyzer::Filter,src:[]text_analyzer::Filter)->(:int)"(ptr %0, ptr %1) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca { ptr, i64 }, align 8
  %n = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %1, i64 16, i1 false)
  %4 = getelementptr inbounds nuw { ptr, i64 }, ptr %3, i32 0, i32 1
  %5 = load i64, ptr %4, align 8
  %6 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %8 = icmp slt i64 %7, %5
  %9 = select i1 %8, i64 %7, i64 %5
  store i64 %9, ptr %n, align 8
  %10 = load i64, ptr %n, align 8
  %11 = icmp sgt i64 %10, 0
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %14 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds nuw { ptr, i64 }, ptr %3, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = load i64, ptr %n, align 8
  %19 = mul i64 %18, 32
  call void @llvm.memmove.p0.p0.i64(ptr %15, ptr %17, i64 %19, i1 false)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %20 = load i64, ptr %n, align 8
  ret i64 %20
}

define i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]int,src:[]int)->(:int)"(ptr %0, ptr %1) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca { ptr, i64 }, align 8
  %n = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %1, i64 16, i1 false)
  %4 = getelementptr inbounds nuw { ptr, i64 }, ptr %3, i32 0, i32 1
  %5 = load i64, ptr %4, align 8
  %6 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %8 = icmp slt i64 %7, %5
  %9 = select i1 %8, i64 %7, i64 %5
  store i64 %9, ptr %n, align 8
  %10 = load i64, ptr %n, align 8
  %11 = icmp sgt i64 %10, 0
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %14 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds nuw { ptr, i64 }, ptr %3, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = load i64, ptr %n, align 8
  %19 = mul i64 %18, 8
  call void @llvm.memmove.p0.p0.i64(ptr %15, ptr %17, i64 %19, i1 false)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %20 = load i64, ptr %n, align 8
  ret i64 %20
}

define i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"(ptr %0, ptr %1) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca { ptr, i64 }, align 8
  %n = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %1, i64 16, i1 false)
  %4 = getelementptr inbounds nuw { ptr, i64 }, ptr %3, i32 0, i32 1
  %5 = load i64, ptr %4, align 8
  %6 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %8 = icmp slt i64 %7, %5
  %9 = select i1 %8, i64 %7, i64 %5
  store i64 %9, ptr %n, align 8
  %10 = load i64, ptr %n, align 8
  %11 = icmp sgt i64 %10, 0
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %14 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds nuw { ptr, i64 }, ptr %3, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = load i64, ptr %n, align 8
  %19 = mul i64 %18, 1
  call void @llvm.memmove.p0.p0.i64(ptr %15, ptr %17, i64 %19, i1 false)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %20 = load i64, ptr %n, align 8
  ret i64 %20
}

define i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]text_analyzer::Highlight,src:[]text_analyzer::Highlight)->(:int)"(ptr %0, ptr %1) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca { ptr, i64 }, align 8
  %n = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %1, i64 16, i1 false)
  %4 = getelementptr inbounds nuw { ptr, i64 }, ptr %3, i32 0, i32 1
  %5 = load i64, ptr %4, align 8
  %6 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %8 = icmp slt i64 %7, %5
  %9 = select i1 %8, i64 %7, i64 %5
  store i64 %9, ptr %n, align 8
  %10 = load i64, ptr %n, align 8
  %11 = icmp sgt i64 %10, 0
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %14 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds nuw { ptr, i64 }, ptr %3, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = load i64, ptr %n, align 8
  %19 = mul i64 %18, 32
  call void @llvm.memmove.p0.p0.i64(ptr %15, ptr %17, i64 %19, i1 false)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %20 = load i64, ptr %n, align 8
  ret i64 %20
}

define i64 @"runtime::copy_from_string:proc\22contextless\22(dst:[]u8,src:string)->(:int)"(ptr %0, ptr %1) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca %..string, align 8
  %n = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %1, i64 16, i1 false)
  %4 = getelementptr inbounds nuw %..string, ptr %3, i32 0, i32 1
  %5 = load i64, ptr %4, align 8
  %6 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %8 = icmp slt i64 %7, %5
  %9 = select i1 %8, i64 %7, i64 %5
  store i64 %9, ptr %n, align 8
  %10 = load i64, ptr %n, align 8
  %11 = icmp sgt i64 %10, 0
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %14 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds nuw %..string, ptr %3, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = load i64, ptr %n, align 8
  call void @llvm.memmove.p0.p0.i64(ptr %15, ptr %17, i64 %18, i1 false)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %19 = load i64, ptr %n, align 8
  ret i64 %19
}

; Function Attrs: noinline
define i64 @"runtime::print_byte"(i8 %0) #2 {
decls:
  %1 = alloca i8, align 1
  %n = alloca i64, align 8
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca [1 x i8], align 16
  %4 = alloca { ptr, i64 }, align 8
  %5 = alloca i64, align 8
  %6 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i8 %0, ptr %1, align 1
  store i64 0, ptr %n, align 8
  call void @llvm.memset.inline.p0.i64(ptr %2, i8 0, i64 16, i1 false)
  store [1 x i8] zeroinitializer, ptr %3, align 1
  %7 = getelementptr inbounds [1 x i8], ptr %3, i64 0, i64 0
  %8 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  store ptr %7, ptr %8, align 8
  %9 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 1
  store i64 1, ptr %9, align 8
  %10 = load { ptr, i64 }, ptr %4, align 8
  %11 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 0
  store i8 %0, ptr %13, align 1
  %14 = extractvalue { ptr, i64 } %10, 1
  %15 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  store ptr %12, ptr %15, align 8
  %16 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  store i64 %14, ptr %16, align 8
  store i64 0, ptr %5, align 8
  %17 = call i64 @"runtime::stderr_write"(ptr %2, ptr %5)
  %18 = load i64, ptr %5, align 8
  store i64 %18, ptr %n, align 8
  %19 = load i64, ptr %n, align 8
  store i64 %19, ptr %n, align 8
  ret i64 %19
}

define void @"runtime::matrix_bounds_check_error"(ptr %0, i32 %1, i32 %2, i64 %3, i64 %4, i64 %5, i64 %6) {
decls:
  %7 = alloca %..string, align 8
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %0, i64 16, i1 false)
  store i32 %1, ptr %8, align 4
  store i32 %2, ptr %9, align 4
  store i64 %3, ptr %10, align 8
  store i64 %4, ptr %11, align 8
  store i64 %5, ptr %12, align 8
  store i64 %6, ptr %13, align 8
  %14 = icmp ult i64 %3, %5
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %17 = icmp ult i64 %4, %6
  %18 = zext i1 %17 to i8
  %19 = icmp ne i8 %18, 0
  br i1 %19, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  ret void

if.done:                                          ; preds = %cmp.and, %entry
  call void @"runtime::matrix_bounds_check_error.handle_error-0"(ptr %7, i32 %1, i32 %2, i64 %3, i64 %4, i64 %5, i64 %6)
  unreachable
}

define ptr @"runtime::heap_alloc"(i64 %0, i1 zeroext %1) {
decls:
  %2 = alloca i64, align 8
  %3 = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  %4 = zext i1 %1 to i8
  store i8 %4, ptr %3, align 1
  %5 = icmp ne i8 %4, 0
  %6 = call ptr @"runtime::_heap_alloc"(i64 %0, i1 zeroext %5)
  ret ptr %6
}

; Function Attrs: noinline
define void @"runtime::print_encoded_rune"(i32 %0) #2 {
decls:
  %1 = alloca i32, align 4
  %n0 = alloca i8, align 1
  %n1 = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %1, align 4
  %2 = call i64 @"runtime::print_byte"(i8 39)
  switch i32 %0, label %switch.default.body [
    i32 7, label %switch.case.body
    i32 8, label %switch.case.body1
    i32 27, label %switch.case.body2
    i32 12, label %switch.case.body3
    i32 10, label %switch.case.body4
    i32 13, label %switch.case.body5
    i32 9, label %switch.case.body6
    i32 11, label %switch.case.body7
  ]

switch.case.body:                                 ; preds = %entry
  %3 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_encoded_rune$1")
  br label %switch.done

switch.case.body1:                                ; preds = %entry
  %4 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_encoded_rune$2")
  br label %switch.done

switch.case.body2:                                ; preds = %entry
  %5 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_encoded_rune$3")
  br label %switch.done

switch.case.body3:                                ; preds = %entry
  %6 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_encoded_rune$4")
  br label %switch.done

switch.case.body4:                                ; preds = %entry
  %7 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_encoded_rune$5")
  br label %switch.done

switch.case.body5:                                ; preds = %entry
  %8 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_encoded_rune$6")
  br label %switch.done

switch.case.body6:                                ; preds = %entry
  %9 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_encoded_rune$7")
  br label %switch.done

switch.case.body7:                                ; preds = %entry
  %10 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_encoded_rune$8")
  br label %switch.done

switch.default.body:                              ; preds = %entry
  %11 = icmp sle i32 %0, 0
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %if.then, label %if.else

if.then:                                          ; preds = %switch.default.body
  %14 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_encoded_rune$9")
  br label %if.done10

if.else:                                          ; preds = %switch.default.body
  %15 = icmp slt i32 %0, 32
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %if.then8, label %if.else9

if.then8:                                         ; preds = %if.else
  %18 = trunc i32 %0 to i8
  %19 = lshr i8 %18, 4
  %20 = select i1 true, i8 %19, i8 0
  %21 = trunc i32 %0 to i8
  %22 = and i8 %21, 15
  store i8 %20, ptr %n0, align 1
  store i8 %22, ptr %n1, align 1
  %23 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_encoded_rune$10")
  %24 = load ptr, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %25 = load i64, ptr getelementptr (%..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", i64 0, i32 1), align 8
  %26 = load i8, ptr %n0, align 1
  %27 = zext i8 %26 to i64
  call void @"runtime::bounds_check_error"(ptr @"ggv$runtime::print_encoded_rune$11", i32 164, i32 35, i64 %27, i64 %25)
  %28 = getelementptr i8, ptr %24, i64 %27
  %29 = load i8, ptr %28, align 1
  %30 = call i64 @"runtime::print_byte"(i8 %29)
  %31 = load ptr, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %32 = load i64, ptr getelementptr (%..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", i64 0, i32 1), align 8
  %33 = load i8, ptr %n1, align 1
  %34 = zext i8 %33 to i64
  call void @"runtime::bounds_check_error"(ptr @"ggv$runtime::print_encoded_rune$12", i32 165, i32 35, i64 %34, i64 %32)
  %35 = getelementptr i8, ptr %31, i64 %34
  %36 = load i8, ptr %35, align 1
  %37 = call i64 @"runtime::print_byte"(i8 %36)
  br label %if.done

if.else9:                                         ; preds = %if.else
  %38 = call i64 @"runtime::print_rune"(i32 %0)
  br label %if.done

if.done:                                          ; preds = %if.else9, %if.then8
  br label %if.done10

if.done10:                                        ; preds = %if.done, %if.then
  br label %switch.done

switch.done:                                      ; preds = %if.done10, %switch.case.body7, %switch.case.body6, %switch.case.body5, %switch.case.body4, %switch.case.body3, %switch.case.body2, %switch.case.body1, %switch.case.body
  %39 = call i64 @"runtime::print_byte"(i8 39)
  ret void
}

; Function Attrs: alwaysinline
define i8 @"runtime::mem_alloc"(i64 %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) #1 {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca %"runtime::Allocator", align 8
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %6, align 8
  store i64 %1, ptr %7, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %8, ptr %2, i64 16, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  store i64 %1, ptr %5, align 8
  %11 = icmp sle i64 %1, 0
  %12 = zext i1 %11 to i8
  br i1 %11, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  br label %"runtime::is_power_of_two_int.exit"

if.done.i:                                        ; preds = %entry
  %13 = sub i64 %1, 1
  %14 = and i64 %1, %13
  %15 = icmp eq i64 %14, 0
  %16 = zext i1 %15 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  br label %"runtime::is_power_of_two_int.exit"

"runtime::is_power_of_two_int.exit":              ; preds = %if.done.i, %if.then.i
  %17 = phi i8 [ 0, %if.then.i ], [ %16, %if.done.i ]
  %18 = icmp ne i8 %17, 0
  call void @"runtime::assert"(i1 zeroext %18, ptr @"ggv$runtime::mem_alloc$1", ptr %3, ptr %__.context_ptr)
  %19 = icmp eq i64 %0, 0
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %"runtime::is_power_of_two_int.exit"
  %22 = getelementptr inbounds nuw %"runtime::Allocator", ptr %8, i32 0, i32 0
  %23 = load ptr, ptr %22, align 8
  %24 = icmp eq ptr %23, null
  %25 = zext i1 %24 to i8
  %26 = icmp ne i8 %25, 0
  br i1 %26, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %"runtime::is_power_of_two_int.exit"
  store { ptr, i64 } zeroinitializer, ptr %4, align 8
  ret i8 0

if.done:                                          ; preds = %cmp.or
  %27 = getelementptr inbounds nuw %"runtime::Allocator", ptr %8, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr inbounds nuw %"runtime::Allocator", ptr %8, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  call void @llvm.memset.inline.p0.i64(ptr %9, i8 0, i64 16, i1 false)
  %31 = call i8 %28(ptr %30, i8 0, i64 %0, i64 %1, ptr null, i64 0, ptr %3, ptr %9, ptr %__.context_ptr)
  %32 = load { ptr, i64 }, ptr %9, align 8
  store { ptr, i64 } %32, ptr %4, align 8
  ret i8 %31
}

define ptr @"runtime::heap_resize"(ptr %0, i64 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = call ptr @"runtime::_heap_resize"(ptr %0, i64 %1)
  ret ptr %4
}

define void @"runtime::heap_free"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  call void @"runtime::_heap_free"(ptr %0)
  ret void
}

; Function Attrs: alwaysinline
define i8 @"runtime::mem_alloc_non_zeroed"(i64 %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) #1 {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca %"runtime::Allocator", align 8
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %6, align 8
  store i64 %1, ptr %7, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %8, ptr %2, i64 16, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  store i64 %1, ptr %5, align 8
  %11 = icmp sle i64 %1, 0
  %12 = zext i1 %11 to i8
  br i1 %11, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  br label %"runtime::is_power_of_two_int.exit"

if.done.i:                                        ; preds = %entry
  %13 = sub i64 %1, 1
  %14 = and i64 %1, %13
  %15 = icmp eq i64 %14, 0
  %16 = zext i1 %15 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  br label %"runtime::is_power_of_two_int.exit"

"runtime::is_power_of_two_int.exit":              ; preds = %if.done.i, %if.then.i
  %17 = phi i8 [ 0, %if.then.i ], [ %16, %if.done.i ]
  %18 = icmp ne i8 %17, 0
  call void @"runtime::assert"(i1 zeroext %18, ptr @"ggv$runtime::mem_alloc_non_zeroed$1", ptr %3, ptr %__.context_ptr)
  %19 = icmp eq i64 %0, 0
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %"runtime::is_power_of_two_int.exit"
  %22 = getelementptr inbounds nuw %"runtime::Allocator", ptr %8, i32 0, i32 0
  %23 = load ptr, ptr %22, align 8
  %24 = icmp eq ptr %23, null
  %25 = zext i1 %24 to i8
  %26 = icmp ne i8 %25, 0
  br i1 %26, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %"runtime::is_power_of_two_int.exit"
  store { ptr, i64 } zeroinitializer, ptr %4, align 8
  ret i8 0

if.done:                                          ; preds = %cmp.or
  %27 = getelementptr inbounds nuw %"runtime::Allocator", ptr %8, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr inbounds nuw %"runtime::Allocator", ptr %8, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  call void @llvm.memset.inline.p0.i64(ptr %9, i8 0, i64 16, i1 false)
  %31 = call i8 %28(ptr %30, i8 6, i64 %0, i64 %1, ptr null, i64 0, ptr %3, ptr %9, ptr %__.context_ptr)
  %32 = load { ptr, i64 }, ptr %9, align 8
  store { ptr, i64 } %32, ptr %4, align 8
  ret i8 %31
}

; Function Attrs: noinline
define i64 @"runtime::print_rune"(i32 %0) #2 {
decls:
  %1 = alloca i32, align 4
  %2 = alloca [4 x i8], align 1
  %3 = alloca { [4 x i8], i64 }, align 8
  %b = alloca [4 x i8], align 1
  %n = alloca i64, align 8
  %4 = alloca { ptr, i64 }, align 8
  %5 = alloca i64, align 8
  %6 = alloca { i64, i64 }, align 8
  %m = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %1, align 4
  %7 = icmp slt i32 %0, 128
  %8 = zext i1 %7 to i8
  %9 = icmp ne i8 %8, 0
  br i1 %9, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %10 = trunc i32 %0 to i8
  %11 = call i64 @"runtime::print_byte"(i8 %10)
  ret i64 %11

if.done:                                          ; preds = %entry
  call void @llvm.memset.inline.p0.i64(ptr %2, i8 0, i64 4, i1 false)
  %12 = call i64 @"runtime::encode_rune"(i32 %0, ptr %2)
  %13 = load [4 x i8], ptr %2, align 1
  store [4 x i8] %13, ptr %b, align 1
  store i64 %12, ptr %n, align 8
  %14 = load i64, ptr %n, align 8
  %15 = getelementptr [4 x i8], ptr %b, i64 0, i64 0
  %16 = getelementptr i8, ptr %15, i64 0
  %17 = sub i64 %14, 0
  %18 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  store ptr %16, ptr %18, align 8
  %19 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 1
  store i64 %17, ptr %19, align 8
  store i64 0, ptr %5, align 8
  %20 = call i64 @"runtime::stderr_write"(ptr %4, ptr %5)
  %21 = load i64, ptr %5, align 8
  store i64 %21, ptr %m, align 8
  %22 = load i64, ptr %m, align 8
  ret i64 %22
}

; Function Attrs: alwaysinline
define i8 @"runtime::mem_free"(ptr %0, ptr %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) #1 {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca %"runtime::Allocator", align 8
  %5 = alloca { ptr, i64 }, align 8
  %6 = alloca { { ptr, i64 }, i8 }, align 8
  %err = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %1, i64 16, i1 false)
  %7 = icmp eq ptr %0, null
  %8 = zext i1 %7 to i8
  %9 = icmp ne i8 %8, 0
  br i1 %9, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %10 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  %12 = icmp eq ptr %11, null
  %13 = zext i1 %12 to i8
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  ret i8 0

if.done:                                          ; preds = %cmp.or
  %15 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 0
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  call void @llvm.memset.inline.p0.i64(ptr %5, i8 0, i64 16, i1 false)
  %19 = call i8 %16(ptr %18, i8 1, i64 0, i64 0, ptr %0, i64 0, ptr %2, ptr %5, ptr %__.context_ptr)
  store i8 %19, ptr %err, align 1
  %20 = load i8, ptr %err, align 1
  ret i8 %20
}

; Function Attrs: noinline
define void @"runtime::print_u64"(i64 %0) #2 {
decls:
  %1 = alloca i64, align 8
  %a = alloca [129 x i8], align 1
  %i = alloca i64, align 8
  %b = alloca i64, align 8
  %u = alloca i64, align 8
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca i64, align 8
  %4 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  call void @llvm.memset.p0.i64(ptr %a, i8 0, i64 129, i1 false)
  store i64 129, ptr %i, align 8
  store i64 10, ptr %b, align 8
  store i64 %0, ptr %u, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.body, %entry
  %5 = load i64, ptr %u, align 8
  %6 = load i64, ptr %b, align 8
  %7 = icmp uge i64 %5, %6
  %8 = zext i1 %7 to i8
  %9 = icmp ne i8 %8, 0
  br i1 %9, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %10 = load i64, ptr %i, align 8
  %11 = sub i64 %10, 1
  store i64 %11, ptr %i, align 8
  %12 = load i64, ptr %i, align 8
  %13 = getelementptr [129 x i8], ptr %a, i64 0, i64 %12
  %14 = load ptr, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %15 = load i64, ptr %u, align 8
  %16 = load i64, ptr %b, align 8
  %17 = urem i64 %15, %16
  %18 = getelementptr i8, ptr %14, i64 %17
  %19 = load i8, ptr %18, align 1
  store i8 %19, ptr %13, align 1
  %20 = load i64, ptr %b, align 8
  %21 = load i64, ptr %u, align 8
  %22 = udiv i64 %21, %20
  store i64 %22, ptr %u, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %23 = load i64, ptr %i, align 8
  %24 = sub i64 %23, 1
  store i64 %24, ptr %i, align 8
  %25 = load i64, ptr %i, align 8
  %26 = getelementptr [129 x i8], ptr %a, i64 0, i64 %25
  %27 = load ptr, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %28 = load i64, ptr %u, align 8
  %29 = load i64, ptr %b, align 8
  %30 = urem i64 %28, %29
  %31 = getelementptr i8, ptr %27, i64 %30
  %32 = load i8, ptr %31, align 1
  store i8 %32, ptr %26, align 1
  %33 = load i64, ptr %i, align 8
  %34 = getelementptr [129 x i8], ptr %a, i64 0, i64 0
  %35 = getelementptr i8, ptr %34, i64 %33
  %36 = sub i64 129, %33
  %37 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  store ptr %35, ptr %37, align 8
  %38 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  store i64 %36, ptr %38, align 8
  store i64 0, ptr %3, align 8
  %39 = call i64 @"runtime::stderr_write"(ptr %2, ptr %3)
  ret void
}

; Function Attrs: alwaysinline
define i8 @"runtime::mem_free_with_size"(ptr %0, i64 %1, ptr %2, ptr %3, ptr noalias nocapture nonnull %__.context_ptr) #1 {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %6 = alloca %"runtime::Allocator", align 8
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca { { ptr, i64 }, i8 }, align 8
  %err = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %4, align 8
  store i64 %1, ptr %5, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %6, ptr %2, i64 16, i1 false)
  %9 = icmp eq ptr %0, null
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %12 = getelementptr inbounds nuw %"runtime::Allocator", ptr %6, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = icmp eq ptr %13, null
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  ret i8 0

if.done:                                          ; preds = %cmp.or
  %17 = getelementptr inbounds nuw %"runtime::Allocator", ptr %6, i32 0, i32 0
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr inbounds nuw %"runtime::Allocator", ptr %6, i32 0, i32 1
  %20 = load ptr, ptr %19, align 8
  call void @llvm.memset.inline.p0.i64(ptr %7, i8 0, i64 16, i1 false)
  %21 = call i8 %18(ptr %20, i8 1, i64 0, i64 0, ptr %0, i64 %1, ptr %3, ptr %7, ptr %__.context_ptr)
  store i8 %21, ptr %err, align 1
  %22 = load i8, ptr %err, align 1
  ret i8 %22
}

; Function Attrs: noinline
define void @"runtime::print_i64"(i64 %0) #2 {
decls:
  %1 = alloca i64, align 8
  %u = alloca i64, align 8
  %neg = alloca i8, align 1
  %a = alloca [129 x i8], align 1
  %i = alloca i64, align 8
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca i64, align 8
  %4 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  store i64 %0, ptr %u, align 8
  %5 = load i64, ptr %u, align 8
  %6 = icmp slt i64 %5, 0
  %7 = zext i1 %6 to i8
  store i8 %7, ptr %neg, align 1
  %8 = load i64, ptr %u, align 8
  %9 = icmp slt i64 %8, 0
  %10 = sub i64 0, %8
  %11 = select i1 %9, i64 %10, i64 %8
  store i64 %11, ptr %u, align 8
  call void @llvm.memset.p0.i64(ptr %a, i8 0, i64 129, i1 false)
  store i64 129, ptr %i, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.body, %entry
  %12 = load i64, ptr %u, align 8
  %13 = icmp sge i64 %12, 10
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %16 = load i64, ptr %i, align 8
  %17 = sub i64 %16, 1
  store i64 %17, ptr %i, align 8
  %18 = load i64, ptr %i, align 8
  %19 = getelementptr [129 x i8], ptr %a, i64 0, i64 %18
  %20 = load ptr, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %21 = load i64, ptr %u, align 8
  %22 = srem i64 %21, 10
  %23 = getelementptr i8, ptr %20, i64 %22
  %24 = load i8, ptr %23, align 1
  store i8 %24, ptr %19, align 1
  %25 = load i64, ptr %u, align 8
  %26 = sdiv i64 %25, 10
  store i64 %26, ptr %u, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %27 = load i64, ptr %i, align 8
  %28 = sub i64 %27, 1
  store i64 %28, ptr %i, align 8
  %29 = load i64, ptr %i, align 8
  %30 = getelementptr [129 x i8], ptr %a, i64 0, i64 %29
  %31 = load ptr, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %32 = load i64, ptr %u, align 8
  %33 = srem i64 %32, 10
  %34 = getelementptr i8, ptr %31, i64 %33
  %35 = load i8, ptr %34, align 1
  store i8 %35, ptr %30, align 1
  %36 = load i8, ptr %neg, align 1
  %37 = icmp ne i8 %36, 0
  br i1 %37, label %if.then, label %if.done

if.then:                                          ; preds = %for.done
  %38 = load i64, ptr %i, align 8
  %39 = sub i64 %38, 1
  store i64 %39, ptr %i, align 8
  %40 = load i64, ptr %i, align 8
  %41 = getelementptr [129 x i8], ptr %a, i64 0, i64 %40
  store i8 45, ptr %41, align 1
  br label %if.done

if.done:                                          ; preds = %if.then, %for.done
  %42 = load i64, ptr %i, align 8
  %43 = getelementptr [129 x i8], ptr %a, i64 0, i64 0
  %44 = getelementptr i8, ptr %43, i64 %42
  %45 = sub i64 129, %42
  %46 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  store ptr %44, ptr %46, align 8
  %47 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  store i64 %45, ptr %47, align 8
  store i64 0, ptr %3, align 8
  %48 = call i64 @"runtime::stderr_write"(ptr %2, ptr %3)
  ret void
}

define void @"runtime::arena_free_last_memory_block"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %free_block = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  br label %if.init

if.init:                                          ; preds = %entry
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr inbounds nuw %"runtime::Arena", ptr %3, i32 0, i32 1
  %5 = load ptr, ptr %4, align 8
  store ptr %5, ptr %free_block, align 8
  %6 = load ptr, ptr %free_block, align 8
  %7 = icmp ne ptr %6, null
  %8 = zext i1 %7 to i8
  %9 = icmp ne i8 %8, 0
  br i1 %9, label %if.then, label %if.done

if.then:                                          ; preds = %if.init
  %10 = load ptr, ptr %2, align 8
  %11 = getelementptr inbounds nuw %"runtime::Arena", ptr %10, i32 0, i32 1
  %12 = load ptr, ptr %free_block, align 8
  %13 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %12, i32 0, i32 0
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %11, align 8
  %15 = load ptr, ptr %2, align 8
  %16 = getelementptr inbounds nuw %"runtime::Arena", ptr %15, i32 0, i32 3
  %17 = load ptr, ptr %free_block, align 8
  %18 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %17, i32 0, i32 4
  %19 = load i64, ptr %18, align 8
  %20 = load i64, ptr %16, align 8
  %21 = sub i64 %20, %19
  store i64 %21, ptr %16, align 8
  %22 = load ptr, ptr %free_block, align 8
  call void @"runtime::memory_block_dealloc"(ptr %22, ptr %1, ptr %__.context_ptr)
  br label %if.done

if.done:                                          ; preds = %if.then, %if.init
  ret void
}

define void @"runtime::type_assertion_check"(i1 zeroext %0, ptr %1, i32 %2, i32 %3, i64 %4, i64 %5) {
decls:
  %6 = alloca i8, align 1
  %7 = alloca %..string, align 8
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  %12 = zext i1 %0 to i8
  store i8 %12, ptr %6, align 1
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %1, i64 16, i1 false)
  store i32 %2, ptr %8, align 4
  store i32 %3, ptr %9, align 4
  store i64 %4, ptr %10, align 8
  store i64 %5, ptr %11, align 8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  call void @"runtime::type_assertion_check.handle_error-0"(ptr %7, i32 %2, i32 %3, i64 %4, i64 %5)
  unreachable
}

; Function Attrs: noinline
define void @"runtime::print_caller_location"(ptr %0) #2 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %1 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %0, i32 0, i32 0
  %2 = call i64 @"runtime::print_string"(ptr %1)
  %3 = call i64 @"runtime::print_byte"(i8 40)
  %4 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %0, i32 0, i32 1
  %5 = load i32, ptr %4, align 4
  %6 = sext i32 %5 to i64
  call void @"runtime::print_u64"(i64 %6)
  %7 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %0, i32 0, i32 2
  %8 = load i32, ptr %7, align 4
  %9 = icmp ne i32 %8, 0
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %12 = call i64 @"runtime::print_byte"(i8 58)
  %13 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %0, i32 0, i32 2
  %14 = load i32, ptr %13, align 4
  %15 = sext i32 %14 to i64
  call void @"runtime::print_u64"(i64 %15)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %16 = call i64 @"runtime::print_byte"(i8 41)
  ret void
}

define void @"runtime::arena_free_all"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.body, %entry
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr inbounds nuw %"runtime::Arena", ptr %3, i32 0, i32 1
  %5 = load ptr, ptr %4, align 8
  %6 = icmp ne ptr %5, null
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %cmp.and, label %for.done

cmp.and:                                          ; preds = %for.loop
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr inbounds nuw %"runtime::Arena", ptr %9, i32 0, i32 1
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %11, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = icmp ne ptr %13, null
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %for.body, label %for.done

for.body:                                         ; preds = %cmp.and
  call void @"runtime::arena_free_last_memory_block"(ptr %0, ptr %1, ptr %__.context_ptr)
  br label %for.loop

for.done:                                         ; preds = %cmp.and, %for.loop
  %17 = load ptr, ptr %2, align 8
  %18 = getelementptr inbounds nuw %"runtime::Arena", ptr %17, i32 0, i32 1
  %19 = load ptr, ptr %18, align 8
  %20 = icmp ne ptr %19, null
  %21 = zext i1 %20 to i8
  %22 = icmp ne i8 %21, 0
  br i1 %22, label %if.then, label %if.done

if.then:                                          ; preds = %for.done
  %23 = load ptr, ptr %2, align 8
  %24 = getelementptr inbounds nuw %"runtime::Arena", ptr %23, i32 0, i32 1
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %25, i32 0, i32 2
  %27 = load ptr, ptr %26, align 8
  %28 = load ptr, ptr %2, align 8
  %29 = getelementptr inbounds nuw %"runtime::Arena", ptr %28, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %30, i32 0, i32 3
  %32 = load i64, ptr %31, align 8
  call void @llvm.memset.p0.i64(ptr %27, i8 0, i64 %32, i1 false)
  %33 = load ptr, ptr %2, align 8
  %34 = getelementptr inbounds nuw %"runtime::Arena", ptr %33, i32 0, i32 1
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %35, i32 0, i32 3
  store i64 0, ptr %36, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %for.done
  %37 = load ptr, ptr %2, align 8
  %38 = getelementptr inbounds nuw %"runtime::Arena", ptr %37, i32 0, i32 2
  store i64 0, ptr %38, align 8
  ret void
}

; Function Attrs: alwaysinline
define i64 @"runtime::map_cell_index_dynamic"(i64 %0, ptr noalias %1, i64 %2) #1 {
decls:
  %3 = alloca i64, align 8
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %elements_per_cell = alloca i64, align 8
  %size_of_cell = alloca i64, align 8
  %cell_index = alloca i64, align 8
  %data_index = alloca i64, align 8
  %size_of_type = alloca i64, align 8
  %cell_index2 = alloca i64, align 8
  %data_index3 = alloca i64, align 8
  %size_of_type4 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %3, align 8
  store ptr %1, ptr %4, align 8
  store i64 %2, ptr %5, align 8
  %6 = load ptr, ptr %4, align 8
  %7 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %6, i32 0, i32 3
  %8 = load i64, ptr %7, align 8
  store i64 %8, ptr %elements_per_cell, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %9, i32 0, i32 2
  %11 = load i64, ptr %10, align 8
  store i64 %11, ptr %size_of_cell, align 8
  %12 = load i64, ptr %elements_per_cell, align 8
  switch i64 %12, label %switch.default.body [
    i64 1, label %switch.case.body
    i64 2, label %switch.case.body1
  ]

switch.case.body:                                 ; preds = %entry
  %13 = load i64, ptr %size_of_cell, align 8
  %14 = mul i64 %2, %13
  %15 = add i64 %0, %14
  ret i64 %15

switch.case.body1:                                ; preds = %entry
  %16 = lshr i64 %2, 1
  %17 = select i1 true, i64 %16, i64 0
  store i64 %17, ptr %cell_index, align 8
  %18 = and i64 %2, 1
  store i64 %18, ptr %data_index, align 8
  %19 = load ptr, ptr %4, align 8
  %20 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %19, i32 0, i32 0
  %21 = load i64, ptr %20, align 8
  store i64 %21, ptr %size_of_type, align 8
  %22 = load i64, ptr %cell_index, align 8
  %23 = load i64, ptr %size_of_cell, align 8
  %24 = mul i64 %22, %23
  %25 = add i64 %0, %24
  %26 = load i64, ptr %data_index, align 8
  %27 = load i64, ptr %size_of_type, align 8
  %28 = mul i64 %26, %27
  %29 = add i64 %25, %28
  ret i64 %29

switch.default.body:                              ; preds = %entry
  %30 = load i64, ptr %elements_per_cell, align 8
  %31 = udiv i64 %2, %30
  store i64 %31, ptr %cell_index2, align 8
  %32 = load i64, ptr %elements_per_cell, align 8
  %33 = urem i64 %2, %32
  store i64 %33, ptr %data_index3, align 8
  %34 = load ptr, ptr %4, align 8
  %35 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %34, i32 0, i32 0
  %36 = load i64, ptr %35, align 8
  store i64 %36, ptr %size_of_type4, align 8
  %37 = load i64, ptr %cell_index2, align 8
  %38 = load i64, ptr %size_of_cell, align 8
  %39 = mul i64 %37, %38
  %40 = add i64 %0, %39
  %41 = load i64, ptr %data_index3, align 8
  %42 = load i64, ptr %size_of_type4, align 8
  %43 = mul i64 %41, %42
  %44 = add i64 %40, %43
  ret i64 %44

switch.done:                                      ; No predecessors!
  unreachable
}

; Function Attrs: alwaysinline
define i8 @"runtime::_mem_resize"(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, i1 zeroext %5, ptr %6, ptr noalias nonnull %7, ptr noalias nocapture nonnull %__.context_ptr) #1 {
decls:
  %8 = alloca i64, align 8
  %9 = alloca ptr, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca %"runtime::Allocator", align 8
  %14 = alloca i8, align 1
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %15 = alloca { ptr, i64 }, align 8
  %16 = alloca { { ptr, i64 }, i8 }, align 8
  %17 = alloca { ptr, i64 }, align 8
  %18 = alloca { { ptr, i64 }, i8 }, align 8
  %19 = alloca { ptr, i64 }, align 8
  %20 = alloca { { ptr, i64 }, i8 }, align 8
  %21 = alloca ptr, align 8
  %22 = alloca { ptr, i64 }, align 8
  %23 = alloca { ptr, i64 }, align 8
  %24 = alloca { { ptr, i64 }, i8 }, align 8
  %25 = alloca { ptr, i64 }, align 8
  %26 = alloca { { ptr, i64 }, i8 }, align 8
  %27 = alloca { ptr, i64 }, align 8
  %28 = alloca { { ptr, i64 }, i8 }, align 8
  %29 = alloca { ptr, i64 }, align 8
  %30 = alloca { { ptr, i64 }, i8 }, align 8
  %31 = alloca ptr, align 8
  %32 = alloca { ptr, i64 }, align 8
  %33 = alloca { ptr, i64 }, align 8
  %34 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %9, align 8
  store i64 %1, ptr %10, align 8
  store i64 %2, ptr %11, align 8
  store i64 %3, ptr %12, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %13, ptr %4, i64 16, i1 false)
  %35 = zext i1 %5 to i8
  store i8 %35, ptr %14, align 1
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  store i64 %3, ptr %8, align 8
  %36 = icmp sle i64 %3, 0
  %37 = zext i1 %36 to i8
  br i1 %36, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  br label %"runtime::is_power_of_two_int.exit"

if.done.i:                                        ; preds = %entry
  %38 = sub i64 %3, 1
  %39 = and i64 %3, %38
  %40 = icmp eq i64 %39, 0
  %41 = zext i1 %40 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  br label %"runtime::is_power_of_two_int.exit"

"runtime::is_power_of_two_int.exit":              ; preds = %if.done.i, %if.then.i
  %42 = phi i8 [ 0, %if.then.i ], [ %41, %if.done.i ]
  %43 = icmp ne i8 %42, 0
  call void @"runtime::assert"(i1 zeroext %43, ptr @"ggv$runtime::_mem_resize$1", ptr %6, ptr %__.context_ptr)
  %44 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 0
  %45 = load ptr, ptr %44, align 8
  %46 = icmp eq ptr %45, null
  %47 = zext i1 %46 to i8
  %48 = icmp ne i8 %47, 0
  br i1 %48, label %if.then, label %if.done

if.then:                                          ; preds = %"runtime::is_power_of_two_int.exit"
  store { ptr, i64 } zeroinitializer, ptr %data, align 8
  store i8 0, ptr %err, align 1
  store { ptr, i64 } zeroinitializer, ptr %7, align 8
  ret i8 0

if.done:                                          ; preds = %"runtime::is_power_of_two_int.exit"
  %49 = icmp eq i64 %2, 0
  %50 = zext i1 %49 to i8
  %51 = icmp ne i8 %50, 0
  br i1 %51, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.done
  %52 = icmp ne ptr %0, null
  %53 = zext i1 %52 to i8
  %54 = icmp ne i8 %53, 0
  br i1 %54, label %if.then2, label %if.done3

if.then2:                                         ; preds = %if.then1
  %55 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 0
  %56 = load ptr, ptr %55, align 8
  %57 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 1
  %58 = load ptr, ptr %57, align 8
  call void @llvm.memset.inline.p0.i64(ptr %15, i8 0, i64 16, i1 false)
  %59 = call i8 %56(ptr %58, i8 1, i64 0, i64 0, ptr %0, i64 %1, ptr %6, ptr %15, ptr %__.context_ptr)
  store i8 %59, ptr %err, align 1
  %60 = load { ptr, i64 }, ptr %data, align 8
  %61 = load i8, ptr %err, align 1
  store { ptr, i64 } %60, ptr %data, align 8
  store i8 %61, ptr %err, align 1
  store { ptr, i64 } %60, ptr %7, align 8
  ret i8 %61

if.done3:                                         ; preds = %if.then1
  %62 = load { ptr, i64 }, ptr %data, align 8
  %63 = load i8, ptr %err, align 1
  store { ptr, i64 } %62, ptr %data, align 8
  store i8 %63, ptr %err, align 1
  store { ptr, i64 } %62, ptr %7, align 8
  ret i8 %63

if.else:                                          ; preds = %if.done
  %64 = icmp eq ptr %0, null
  %65 = zext i1 %64 to i8
  %66 = icmp ne i8 %65, 0
  br i1 %66, label %if.then4, label %if.else8

if.then4:                                         ; preds = %if.else
  %67 = icmp ne i8 %35, 0
  br i1 %67, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.then4
  %68 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  %70 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  call void @llvm.memset.inline.p0.i64(ptr %17, i8 0, i64 16, i1 false)
  %72 = call i8 %69(ptr %71, i8 0, i64 %2, i64 %3, ptr null, i64 0, ptr %6, ptr %17, ptr %__.context_ptr)
  %73 = load { ptr, i64 }, ptr %17, align 8
  store { ptr, i64 } %73, ptr %data, align 8
  store i8 %72, ptr %err, align 1
  store { ptr, i64 } %73, ptr %7, align 8
  ret i8 %72

if.else6:                                         ; preds = %if.then4
  %74 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 0
  %75 = load ptr, ptr %74, align 8
  %76 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 1
  %77 = load ptr, ptr %76, align 8
  call void @llvm.memset.inline.p0.i64(ptr %19, i8 0, i64 16, i1 false)
  %78 = call i8 %75(ptr %77, i8 6, i64 %2, i64 %3, ptr null, i64 0, ptr %6, ptr %19, ptr %__.context_ptr)
  %79 = load { ptr, i64 }, ptr %19, align 8
  store { ptr, i64 } %79, ptr %data, align 8
  store i8 %78, ptr %err, align 1
  store { ptr, i64 } %79, ptr %7, align 8
  ret i8 %78

if.done7:                                         ; No predecessors!
  br label %if.done11

if.else8:                                         ; preds = %if.else
  %80 = icmp eq i64 %1, %2
  %81 = zext i1 %80 to i8
  %82 = icmp ne i8 %81, 0
  br i1 %82, label %cmp.and, label %if.done10

cmp.and:                                          ; preds = %if.else8
  %83 = ptrtoint ptr %0 to i64
  %84 = urem i64 %83, %3
  %85 = icmp eq i64 %84, 0
  %86 = zext i1 %85 to i8
  %87 = icmp ne i8 %86, 0
  br i1 %87, label %if.then9, label %if.done10

if.then9:                                         ; preds = %cmp.and
  store ptr %0, ptr %21, align 8
  %88 = load ptr, ptr %21, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::_mem_resize$2", i32 200, i32 24, i64 0, i64 %1)
  %89 = getelementptr i8, ptr %88, i64 0
  %90 = sub i64 %1, 0
  %91 = getelementptr inbounds nuw { ptr, i64 }, ptr %22, i32 0, i32 0
  %92 = getelementptr inbounds nuw { ptr, i64 }, ptr %22, i32 0, i32 1
  store ptr %89, ptr %91, align 8
  store i64 %90, ptr %92, align 8
  %93 = load { ptr, i64 }, ptr %22, align 8
  store { ptr, i64 } %93, ptr %data, align 8
  %94 = load { ptr, i64 }, ptr %data, align 8
  %95 = load i8, ptr %err, align 1
  store { ptr, i64 } %94, ptr %data, align 8
  store i8 %95, ptr %err, align 1
  store { ptr, i64 } %94, ptr %7, align 8
  ret i8 %95

if.done10:                                        ; preds = %cmp.and, %if.else8
  br label %if.done11

if.done11:                                        ; preds = %if.done10, %if.done7
  br label %if.done12

if.done12:                                        ; preds = %if.done11
  %96 = icmp ne i8 %35, 0
  br i1 %96, label %if.then13, label %if.else14

if.then13:                                        ; preds = %if.done12
  %97 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 0
  %98 = load ptr, ptr %97, align 8
  %99 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 1
  %100 = load ptr, ptr %99, align 8
  call void @llvm.memset.inline.p0.i64(ptr %23, i8 0, i64 16, i1 false)
  %101 = call i8 %98(ptr %100, i8 3, i64 %2, i64 %3, ptr %0, i64 %1, ptr %6, ptr %23, ptr %__.context_ptr)
  %102 = load { ptr, i64 }, ptr %23, align 8
  store { ptr, i64 } %102, ptr %data, align 8
  store i8 %101, ptr %err, align 1
  br label %if.done15

if.else14:                                        ; preds = %if.done12
  %103 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 0
  %104 = load ptr, ptr %103, align 8
  %105 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 1
  %106 = load ptr, ptr %105, align 8
  call void @llvm.memset.inline.p0.i64(ptr %25, i8 0, i64 16, i1 false)
  %107 = call i8 %104(ptr %106, i8 7, i64 %2, i64 %3, ptr %0, i64 %1, ptr %6, ptr %25, ptr %__.context_ptr)
  %108 = load { ptr, i64 }, ptr %25, align 8
  store { ptr, i64 } %108, ptr %data, align 8
  store i8 %107, ptr %err, align 1
  br label %if.done15

if.done15:                                        ; preds = %if.else14, %if.then13
  %109 = load i8, ptr %err, align 1
  %110 = icmp eq i8 %109, 4
  %111 = zext i1 %110 to i8
  %112 = icmp ne i8 %111, 0
  br i1 %112, label %if.then16, label %if.done22

if.then16:                                        ; preds = %if.done15
  %113 = icmp ne i8 %35, 0
  br i1 %113, label %if.then17, label %if.else18

if.then17:                                        ; preds = %if.then16
  %114 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 0
  %115 = load ptr, ptr %114, align 8
  %116 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 1
  %117 = load ptr, ptr %116, align 8
  call void @llvm.memset.inline.p0.i64(ptr %27, i8 0, i64 16, i1 false)
  %118 = call i8 %115(ptr %117, i8 0, i64 %2, i64 %3, ptr null, i64 0, ptr %6, ptr %27, ptr %__.context_ptr)
  %119 = load { ptr, i64 }, ptr %27, align 8
  store { ptr, i64 } %119, ptr %data, align 8
  store i8 %118, ptr %err, align 1
  br label %if.done19

if.else18:                                        ; preds = %if.then16
  %120 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 0
  %121 = load ptr, ptr %120, align 8
  %122 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 1
  %123 = load ptr, ptr %122, align 8
  call void @llvm.memset.inline.p0.i64(ptr %29, i8 0, i64 16, i1 false)
  %124 = call i8 %121(ptr %123, i8 6, i64 %2, i64 %3, ptr null, i64 0, ptr %6, ptr %29, ptr %__.context_ptr)
  %125 = load { ptr, i64 }, ptr %29, align 8
  store { ptr, i64 } %125, ptr %data, align 8
  store i8 %124, ptr %err, align 1
  br label %if.done19

if.done19:                                        ; preds = %if.else18, %if.then17
  %126 = load i8, ptr %err, align 1
  %127 = icmp ne i8 %126, 0
  %128 = zext i1 %127 to i8
  %129 = icmp ne i8 %128, 0
  br i1 %129, label %if.then20, label %if.done21

if.then20:                                        ; preds = %if.done19
  %130 = load { ptr, i64 }, ptr %data, align 8
  %131 = load i8, ptr %err, align 1
  store { ptr, i64 } %130, ptr %data, align 8
  store i8 %131, ptr %err, align 1
  store { ptr, i64 } %130, ptr %7, align 8
  ret i8 %131

if.done21:                                        ; preds = %if.done19
  store ptr %0, ptr %31, align 8
  %132 = load ptr, ptr %31, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::_mem_resize$3", i32 218, i32 28, i64 0, i64 %1)
  %133 = getelementptr i8, ptr %132, i64 0
  %134 = sub i64 %1, 0
  %135 = getelementptr inbounds nuw { ptr, i64 }, ptr %32, i32 0, i32 0
  %136 = getelementptr inbounds nuw { ptr, i64 }, ptr %32, i32 0, i32 1
  store ptr %133, ptr %135, align 8
  store i64 %134, ptr %136, align 8
  %137 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"(ptr %data, ptr %32)
  %138 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 0
  %139 = load ptr, ptr %138, align 8
  %140 = getelementptr inbounds nuw %"runtime::Allocator", ptr %13, i32 0, i32 1
  %141 = load ptr, ptr %140, align 8
  call void @llvm.memset.inline.p0.i64(ptr %33, i8 0, i64 16, i1 false)
  %142 = call i8 %139(ptr %141, i8 1, i64 0, i64 0, ptr %0, i64 %1, ptr %6, ptr %33, ptr %__.context_ptr)
  store i8 %142, ptr %err, align 1
  br label %if.done22

if.done22:                                        ; preds = %if.done21, %if.done15
  %143 = load { ptr, i64 }, ptr %data, align 8
  %144 = load i8, ptr %err, align 1
  store { ptr, i64 } %143, ptr %data, align 8
  store i8 %144, ptr %err, align 1
  store { ptr, i64 } %143, ptr %7, align 8
  ret i8 %144
}

define void @"runtime::type_assertion_check2"(i1 zeroext %0, ptr %1, i32 %2, i32 %3, i64 %4, i64 %5, ptr %6) {
decls:
  %7 = alloca i8, align 1
  %8 = alloca %..string, align 8
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  %14 = zext i1 %0 to i8
  store i8 %14, ptr %7, align 1
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %8, ptr %1, i64 16, i1 false)
  store i32 %2, ptr %9, align 4
  store i32 %3, ptr %10, align 4
  store i64 %4, ptr %11, align 8
  store i64 %5, ptr %12, align 8
  store ptr %6, ptr %13, align 8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  call void @"runtime::type_assertion_check2.handle_error-1"(ptr %8, i32 %2, i32 %3, i64 %4, i64 %5, ptr %6)
  unreachable
}

; Function Attrs: noinline
define void @"runtime::print_typeid"(i64 %0) #2 {
decls:
  %1 = alloca i64, align 8
  %ti = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = icmp eq i64 %0, 0
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_typeid$1")
  br label %if.done

if.else:                                          ; preds = %entry
  %6 = call ptr @"runtime::__type_info_of"(i64 %0)
  store ptr %6, ptr %ti, align 8
  %7 = load ptr, ptr %ti, align 8
  call void @"runtime::print_type"(ptr %7)
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  ret void
}

define void @"runtime::arena_destroy"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %free_block = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.body, %entry
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr inbounds nuw %"runtime::Arena", ptr %3, i32 0, i32 1
  %5 = load ptr, ptr %4, align 8
  %6 = icmp ne ptr %5, null
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr inbounds nuw %"runtime::Arena", ptr %9, i32 0, i32 1
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %free_block, align 8
  %12 = load ptr, ptr %2, align 8
  %13 = getelementptr inbounds nuw %"runtime::Arena", ptr %12, i32 0, i32 1
  %14 = load ptr, ptr %free_block, align 8
  %15 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %14, i32 0, i32 0
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %13, align 8
  %17 = load ptr, ptr %2, align 8
  %18 = getelementptr inbounds nuw %"runtime::Arena", ptr %17, i32 0, i32 3
  %19 = load ptr, ptr %free_block, align 8
  %20 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %19, i32 0, i32 4
  %21 = load i64, ptr %20, align 8
  %22 = load i64, ptr %18, align 8
  %23 = sub i64 %22, %21
  store i64 %23, ptr %18, align 8
  %24 = load ptr, ptr %free_block, align 8
  call void @"runtime::memory_block_dealloc"(ptr %24, ptr %1, ptr %__.context_ptr)
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %25 = load ptr, ptr %2, align 8
  %26 = getelementptr inbounds nuw %"runtime::Arena", ptr %25, i32 0, i32 2
  store i64 0, ptr %26, align 8
  %27 = load ptr, ptr %2, align 8
  %28 = getelementptr inbounds nuw %"runtime::Arena", ptr %27, i32 0, i32 3
  store i64 0, ptr %28, align 8
  ret void
}

; Function Attrs: noinline optsize
define void @"runtime::print_type"(ptr %0) #3 {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca [72 x i8], align 8
  %3 = alloca { %"runtime::Type_Info_Parameters", i8 }, align 8
  %t = alloca %"runtime::Type_Info_Parameters", align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %t29 = alloca ptr, align 8
  %i = alloca i64, align 8
  %count = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %name = alloca %..string, align 8
  %i40 = alloca i64, align 8
  %t43 = alloca ptr, align 8
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %name72 = alloca %..string, align 8
  %i73 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %variant = alloca ptr, align 8
  %i84 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca i64, align 8
  %name91 = alloca %..string, align 8
  %i92 = alloca i64, align 8
  %15 = alloca ptr, align 8
  %16 = alloca [40 x i8], align 8
  %elem = alloca { [9 x i64], i64 }, align 8
  %17 = alloca { ptr, i64 }, align 8
  %18 = alloca i64, align 8
  %19 = alloca i64, align 8
  %name104 = alloca %..string, align 8
  %i105 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %20 = icmp eq ptr %0, null
  %21 = zext i1 %20 to i8
  %22 = icmp ne i8 %21, 0
  br i1 %22, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %23 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$1")
  ret void

if.done:                                          ; preds = %entry
  %24 = load ptr, ptr %1, align 8
  %25 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %24, i32 0, i32 5
  %26 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %25, i32 0, i32 1
  %27 = load i64, ptr %26, align 8
  switch i64 %27, label %typeswitch.done111 [
    i64 1, label %typeswitch.body
    i64 2, label %typeswitch.body1
    i64 3, label %typeswitch.body8
    i64 4, label %typeswitch.body9
    i64 5, label %typeswitch.body10
    i64 6, label %typeswitch.body11
    i64 7, label %typeswitch.body12
    i64 8, label %typeswitch.body13
    i64 9, label %typeswitch.body18
    i64 10, label %typeswitch.body19
    i64 11, label %typeswitch.body20
    i64 12, label %typeswitch.body24
    i64 26, label %typeswitch.body25
    i64 13, label %typeswitch.body26
    i64 18, label %typeswitch.body35
    i64 14, label %typeswitch.body49
    i64 15, label %typeswitch.body50
    i64 16, label %typeswitch.body53
    i64 17, label %typeswitch.body54
    i64 22, label %typeswitch.body55
    i64 19, label %typeswitch.body56
    i64 20, label %typeswitch.body77
    i64 21, label %typeswitch.body88
    i64 23, label %typeswitch.body96
    i64 27, label %typeswitch.body101
    i64 24, label %typeswitch.body109
    i64 25, label %typeswitch.body110
  ]

typeswitch.body:                                  ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 48, i1 false)
  %28 = getelementptr inbounds nuw %"runtime::Type_Info_Named", ptr %2, i32 0, i32 0
  %29 = call i64 @"runtime::print_string"(ptr %28)
  br label %typeswitch.done111

typeswitch.body1:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 2, i1 false)
  %30 = load ptr, ptr %1, align 8
  %31 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %30, i32 0, i32 4
  %32 = load i64, ptr %31, align 8
  %33 = icmp eq i64 %32, 3143511548502526014
  br i1 %33, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %typeswitch.body1
  %34 = icmp eq i64 %32, 4128981603702996129
  br i1 %34, label %switch.case.body3, label %switch.case.next2

switch.case.body:                                 ; preds = %typeswitch.body1
  %35 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$2")
  br label %switch.done

switch.case.next2:                                ; preds = %switch.case.next
  %36 = icmp eq i64 %32, -5248816158460668987
  br i1 %36, label %switch.case.body5, label %switch.case.next4

switch.case.body3:                                ; preds = %switch.case.next
  %37 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$3")
  br label %switch.done

switch.case.next4:                                ; preds = %switch.case.next2
  br label %switch.default.body

switch.case.body5:                                ; preds = %switch.case.next2
  %38 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$4")
  br label %switch.done

switch.default.body:                              ; preds = %switch.case.next4
  %39 = getelementptr inbounds nuw %"runtime::Type_Info_Integer", ptr %2, i32 0, i32 0
  %40 = load i8, ptr %39, align 1
  %41 = icmp ne i8 %40, 0
  br i1 %41, label %if.then6, label %if.else

if.then6:                                         ; preds = %switch.default.body
  br label %if.done7

if.else:                                          ; preds = %switch.default.body
  br label %if.done7

if.done7:                                         ; preds = %if.else, %if.then6
  %42 = phi i8 [ 105, %if.then6 ], [ 117, %if.else ]
  %43 = call i64 @"runtime::print_byte"(i8 %42)
  %44 = load ptr, ptr %1, align 8
  %45 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %44, i32 0, i32 0
  %46 = load i64, ptr %45, align 8
  %47 = mul i64 8, %46
  call void @"runtime::print_u64"(i64 %47)
  br label %switch.done

switch.done:                                      ; preds = %if.done7, %switch.case.body5, %switch.case.body3, %switch.case.body
  br label %typeswitch.done111

typeswitch.body8:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 0, i1 false)
  %48 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$5")
  br label %typeswitch.done111

typeswitch.body9:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 1, i1 false)
  %49 = call i64 @"runtime::print_byte"(i8 102)
  %50 = load ptr, ptr %1, align 8
  %51 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %50, i32 0, i32 0
  %52 = load i64, ptr %51, align 8
  %53 = mul i64 8, %52
  call void @"runtime::print_u64"(i64 %53)
  br label %typeswitch.done111

typeswitch.body10:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 0, i1 false)
  %54 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$6")
  %55 = load ptr, ptr %1, align 8
  %56 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %55, i32 0, i32 0
  %57 = load i64, ptr %56, align 8
  %58 = mul i64 8, %57
  call void @"runtime::print_u64"(i64 %58)
  br label %typeswitch.done111

typeswitch.body11:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 0, i1 false)
  %59 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$7")
  %60 = load ptr, ptr %1, align 8
  %61 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %60, i32 0, i32 0
  %62 = load i64, ptr %61, align 8
  %63 = mul i64 8, %62
  call void @"runtime::print_u64"(i64 %63)
  br label %typeswitch.done111

typeswitch.body12:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 1, i1 false)
  %64 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$8")
  br label %typeswitch.done111

typeswitch.body13:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 0, i1 false)
  %65 = load ptr, ptr %1, align 8
  %66 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %65, i32 0, i32 4
  %67 = load i64, ptr %66, align 8
  %68 = icmp eq i64 %67, -3661474206510476099
  br i1 %68, label %switch.case.body15, label %switch.case.next14

switch.case.next14:                               ; preds = %typeswitch.body13
  br label %switch.default.body16

switch.case.body15:                               ; preds = %typeswitch.body13
  %69 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$9")
  br label %switch.done17

switch.default.body16:                            ; preds = %switch.case.next14
  %70 = call i64 @"runtime::print_byte"(i8 98)
  %71 = load ptr, ptr %1, align 8
  %72 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %71, i32 0, i32 0
  %73 = load i64, ptr %72, align 8
  %74 = mul i64 8, %73
  call void @"runtime::print_u64"(i64 %74)
  br label %switch.done17

switch.done17:                                    ; preds = %switch.default.body16, %switch.case.body15
  br label %typeswitch.done111

typeswitch.body18:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 0, i1 false)
  %75 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$10")
  br label %typeswitch.done111

typeswitch.body19:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 0, i1 false)
  %76 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$11")
  br label %typeswitch.done111

typeswitch.body20:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 8, i1 false)
  %77 = getelementptr inbounds nuw %"runtime::Type_Info_Pointer", ptr %2, i32 0, i32 0
  %78 = load ptr, ptr %77, align 8
  %79 = icmp eq ptr %78, null
  %80 = zext i1 %79 to i8
  %81 = icmp ne i8 %80, 0
  br i1 %81, label %if.then21, label %if.else22

if.then21:                                        ; preds = %typeswitch.body20
  %82 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$12")
  br label %if.done23

if.else22:                                        ; preds = %typeswitch.body20
  %83 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$13")
  %84 = getelementptr inbounds nuw %"runtime::Type_Info_Pointer", ptr %2, i32 0, i32 0
  %85 = load ptr, ptr %84, align 8
  call void @"runtime::print_type"(ptr %85)
  br label %if.done23

if.done23:                                        ; preds = %if.else22, %if.then21
  br label %typeswitch.done111

typeswitch.body24:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 8, i1 false)
  %86 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$14")
  %87 = getelementptr inbounds nuw %"runtime::Type_Info_Multi_Pointer", ptr %2, i32 0, i32 0
  %88 = load ptr, ptr %87, align 8
  call void @"runtime::print_type"(ptr %88)
  br label %typeswitch.done111

typeswitch.body25:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 8, i1 false)
  %89 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$15")
  %90 = getelementptr inbounds nuw %"runtime::Type_Info_Soa_Pointer", ptr %2, i32 0, i32 0
  %91 = load ptr, ptr %90, align 8
  call void @"runtime::print_type"(ptr %91)
  br label %typeswitch.done111

typeswitch.body26:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 24, i1 false)
  %92 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$16")
  %93 = getelementptr inbounds nuw %"runtime::Type_Info_Procedure", ptr %2, i32 0, i32 0
  %94 = load ptr, ptr %93, align 8
  %95 = icmp eq ptr %94, null
  %96 = zext i1 %95 to i8
  %97 = icmp ne i8 %96, 0
  br i1 %97, label %if.then27, label %if.else28

if.then27:                                        ; preds = %typeswitch.body26
  %98 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$17")
  br label %if.done32

if.else28:                                        ; preds = %typeswitch.body26
  %99 = getelementptr inbounds nuw %"runtime::Type_Info_Procedure", ptr %2, i32 0, i32 0
  %100 = load ptr, ptr %99, align 8
  %101 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %100, i32 0, i32 5
  call void @llvm.memset.p0.i64(ptr %3, i8 0, i64 33, i1 false)
  %102 = getelementptr inbounds nuw { %"runtime::Type_Info_Parameters", i8 }, ptr %3, i32 0, i32 0
  %103 = getelementptr inbounds nuw { %"runtime::Type_Info_Parameters", i8 }, ptr %3, i32 0, i32 1
  %104 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %101, i32 0, i32 1
  %105 = load i64, ptr %104, align 8
  %106 = icmp eq i64 %105, 18
  br i1 %106, label %union_cast.ok, label %union_cast.end

union_cast.ok:                                    ; preds = %if.else28
  %107 = load %"runtime::Type_Info_Parameters", ptr %101, align 8
  store %"runtime::Type_Info_Parameters" %107, ptr %102, align 8
  store i8 1, ptr %103, align 1
  br label %union_cast.end

union_cast.end:                                   ; preds = %union_cast.ok, %if.else28
  %108 = getelementptr inbounds nuw { %"runtime::Type_Info_Parameters", i8 }, ptr %3, i32 0, i32 1
  %109 = load i8, ptr %108, align 1
  %110 = icmp ne i8 %109, 0
  call void @"runtime::type_assertion_check2"(i1 zeroext %110, ptr @"ggv$runtime::print_type$18", i32 327, i32 9, i64 -8076902416644092719, i64 -4545763294955837399, ptr %101)
  %111 = getelementptr inbounds nuw { %"runtime::Type_Info_Parameters", i8 }, ptr %3, i32 0, i32 0
  %112 = load %"runtime::Type_Info_Parameters", ptr %111, align 8
  store %"runtime::Type_Info_Parameters" %112, ptr %t, align 8
  %113 = call i64 @"runtime::print_byte"(i8 40)
  %114 = getelementptr inbounds nuw %"runtime::Type_Info_Parameters", ptr %t, i32 0, i32 0
  %115 = getelementptr inbounds nuw { ptr, i64 }, ptr %114, i32 0, i32 1
  %116 = load i64, ptr %115, align 8
  store i64 %116, ptr %4, align 8
  store i64 -1, ptr %5, align 8
  br label %for.index.loop

for.index.loop:                                   ; preds = %if.done31, %union_cast.end
  %117 = load i64, ptr %5, align 8
  %118 = add i64 %117, 1
  store i64 %118, ptr %5, align 8
  %119 = load i64, ptr %4, align 8
  %120 = icmp slt i64 %118, %119
  br i1 %120, label %for.index.body, label %for.index.done

for.index.body:                                   ; preds = %for.index.loop
  %121 = load i64, ptr %5, align 8
  %122 = getelementptr inbounds nuw { ptr, i64 }, ptr %114, i32 0, i32 0
  %123 = load ptr, ptr %122, align 8
  %124 = getelementptr ptr, ptr %123, i64 %121
  %125 = load ptr, ptr %124, align 8
  store ptr %125, ptr %t29, align 8
  store i64 %121, ptr %i, align 8
  %126 = load i64, ptr %i, align 8
  %127 = icmp sgt i64 %126, 0
  %128 = zext i1 %127 to i8
  %129 = icmp ne i8 %128, 0
  br i1 %129, label %if.then30, label %if.done31

if.then30:                                        ; preds = %for.index.body
  %130 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$19")
  br label %if.done31

if.done31:                                        ; preds = %if.then30, %for.index.body
  %131 = load ptr, ptr %t29, align 8
  call void @"runtime::print_type"(ptr %131)
  br label %for.index.loop

for.index.done:                                   ; preds = %for.index.loop
  %132 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$20")
  br label %if.done32

if.done32:                                        ; preds = %for.index.done, %if.then27
  %133 = getelementptr inbounds nuw %"runtime::Type_Info_Procedure", ptr %2, i32 0, i32 1
  %134 = load ptr, ptr %133, align 8
  %135 = icmp ne ptr %134, null
  %136 = zext i1 %135 to i8
  %137 = icmp ne i8 %136, 0
  br i1 %137, label %if.then33, label %if.done34

if.then33:                                        ; preds = %if.done32
  %138 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$21")
  %139 = getelementptr inbounds nuw %"runtime::Type_Info_Procedure", ptr %2, i32 0, i32 1
  %140 = load ptr, ptr %139, align 8
  call void @"runtime::print_type"(ptr %140)
  br label %if.done34

if.done34:                                        ; preds = %if.then33, %if.done32
  br label %typeswitch.done111

typeswitch.body35:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 32, i1 false)
  %141 = getelementptr inbounds nuw %"runtime::Type_Info_Parameters", ptr %2, i32 0, i32 1
  %142 = getelementptr inbounds nuw { ptr, i64 }, ptr %141, i32 0, i32 1
  %143 = load i64, ptr %142, align 8
  store i64 %143, ptr %count, align 8
  %144 = load i64, ptr %count, align 8
  %145 = icmp ne i64 %144, 1
  %146 = zext i1 %145 to i8
  %147 = icmp ne i8 %146, 0
  br i1 %147, label %if.then36, label %if.done37

if.then36:                                        ; preds = %typeswitch.body35
  %148 = call i64 @"runtime::print_byte"(i8 40)
  br label %if.done37

if.done37:                                        ; preds = %if.then36, %typeswitch.body35
  %149 = getelementptr inbounds nuw %"runtime::Type_Info_Parameters", ptr %2, i32 0, i32 1
  %150 = getelementptr inbounds nuw { ptr, i64 }, ptr %149, i32 0, i32 1
  %151 = load i64, ptr %150, align 8
  store i64 %151, ptr %6, align 8
  store i64 -1, ptr %7, align 8
  br label %for.index.loop38

for.index.loop38:                                 ; preds = %if.done45, %if.done37
  %152 = load i64, ptr %7, align 8
  %153 = add i64 %152, 1
  store i64 %153, ptr %7, align 8
  %154 = load i64, ptr %6, align 8
  %155 = icmp slt i64 %153, %154
  br i1 %155, label %for.index.body39, label %for.index.done46

for.index.body39:                                 ; preds = %for.index.loop38
  %156 = load i64, ptr %7, align 8
  %157 = getelementptr inbounds nuw { ptr, i64 }, ptr %149, i32 0, i32 0
  %158 = load ptr, ptr %157, align 8
  %159 = getelementptr %..string, ptr %158, i64 %156
  %160 = load %..string, ptr %159, align 8
  store %..string %160, ptr %name, align 8
  store i64 %156, ptr %i40, align 8
  %161 = load i64, ptr %i40, align 8
  %162 = icmp sgt i64 %161, 0
  %163 = zext i1 %162 to i8
  %164 = icmp ne i8 %163, 0
  br i1 %164, label %if.then41, label %if.done42

if.then41:                                        ; preds = %for.index.body39
  %165 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$22")
  br label %if.done42

if.done42:                                        ; preds = %if.then41, %for.index.body39
  %166 = getelementptr inbounds nuw %"runtime::Type_Info_Parameters", ptr %2, i32 0, i32 0
  %167 = getelementptr inbounds nuw { ptr, i64 }, ptr %166, i32 0, i32 0
  %168 = load ptr, ptr %167, align 8
  %169 = load i64, ptr %i40, align 8
  %170 = getelementptr inbounds nuw { ptr, i64 }, ptr %166, i32 0, i32 1
  %171 = load i64, ptr %170, align 8
  call void @"runtime::bounds_check_error"(ptr @"ggv$runtime::print_type$23", i32 345, i32 20, i64 %169, i64 %171)
  %172 = getelementptr ptr, ptr %168, i64 %169
  %173 = load ptr, ptr %172, align 8
  store ptr %173, ptr %t43, align 8
  %174 = getelementptr inbounds nuw %..string, ptr %name, i32 0, i32 1
  %175 = load i64, ptr %174, align 8
  %176 = icmp sgt i64 %175, 0
  %177 = zext i1 %176 to i8
  %178 = icmp ne i8 %177, 0
  br i1 %178, label %if.then44, label %if.done45

if.then44:                                        ; preds = %if.done42
  %179 = call i64 @"runtime::print_string"(ptr %name)
  %180 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$24")
  br label %if.done45

if.done45:                                        ; preds = %if.then44, %if.done42
  %181 = load ptr, ptr %t43, align 8
  call void @"runtime::print_type"(ptr %181)
  br label %for.index.loop38

for.index.done46:                                 ; preds = %for.index.loop38
  %182 = load i64, ptr %count, align 8
  %183 = icmp ne i64 %182, 1
  %184 = zext i1 %183 to i8
  %185 = icmp ne i8 %184, 0
  br i1 %185, label %if.then47, label %if.done48

if.then47:                                        ; preds = %for.index.done46
  %186 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$25")
  br label %if.done48

if.done48:                                        ; preds = %if.then47, %for.index.done46
  br label %typeswitch.done111

typeswitch.body49:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 24, i1 false)
  %187 = call i64 @"runtime::print_byte"(i8 91)
  %188 = getelementptr inbounds nuw %"runtime::Type_Info_Array", ptr %2, i32 0, i32 2
  %189 = load i64, ptr %188, align 8
  call void @"runtime::print_u64"(i64 %189)
  %190 = call i64 @"runtime::print_byte"(i8 93)
  %191 = getelementptr inbounds nuw %"runtime::Type_Info_Array", ptr %2, i32 0, i32 0
  %192 = load ptr, ptr %191, align 8
  call void @"runtime::print_type"(ptr %192)
  br label %typeswitch.done111

typeswitch.body50:                                ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 56, i1 false)
  %193 = getelementptr inbounds nuw %"runtime::Type_Info_Enumerated_Array", ptr %2, i32 0, i32 6
  %194 = load i8, ptr %193, align 1
  %195 = icmp ne i8 %194, 0
  br i1 %195, label %if.then51, label %if.done52

if.then51:                                        ; preds = %typeswitch.body50
  %196 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$26")
  br label %if.done52

if.done52:                                        ; preds = %if.then51, %typeswitch.body50
  %197 = call i64 @"runtime::print_byte"(i8 91)
  %198 = getelementptr inbounds nuw %"runtime::Type_Info_Enumerated_Array", ptr %2, i32 0, i32 1
  %199 = load ptr, ptr %198, align 8
  call void @"runtime::print_type"(ptr %199)
  %200 = call i64 @"runtime::print_byte"(i8 93)
  %201 = getelementptr inbounds nuw %"runtime::Type_Info_Enumerated_Array", ptr %2, i32 0, i32 0
  %202 = load ptr, ptr %201, align 8
  call void @"runtime::print_type"(ptr %202)
  br label %typeswitch.done111

typeswitch.body53:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 16, i1 false)
  %203 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$27")
  %204 = getelementptr inbounds nuw %"runtime::Type_Info_Dynamic_Array", ptr %2, i32 0, i32 0
  %205 = load ptr, ptr %204, align 8
  call void @"runtime::print_type"(ptr %205)
  br label %typeswitch.done111

typeswitch.body54:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 16, i1 false)
  %206 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$28")
  %207 = getelementptr inbounds nuw %"runtime::Type_Info_Slice", ptr %2, i32 0, i32 0
  %208 = load ptr, ptr %207, align 8
  call void @"runtime::print_type"(ptr %208)
  br label %typeswitch.done111

typeswitch.body55:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 24, i1 false)
  %209 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$29")
  %210 = getelementptr inbounds nuw %"runtime::Type_Info_Map", ptr %2, i32 0, i32 0
  %211 = load ptr, ptr %210, align 8
  call void @"runtime::print_type"(ptr %211)
  %212 = call i64 @"runtime::print_byte"(i8 93)
  %213 = getelementptr inbounds nuw %"runtime::Type_Info_Map", ptr %2, i32 0, i32 1
  %214 = load ptr, ptr %213, align 8
  call void @"runtime::print_type"(ptr %214)
  br label %typeswitch.done111

typeswitch.body56:                                ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 72, i1 false)
  %215 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 7
  %216 = load i8, ptr %215, align 1
  switch i8 %216, label %switch.done61 [
    i8 0, label %switch.case.body57
    i8 1, label %switch.case.body58
    i8 2, label %switch.case.body59
    i8 3, label %switch.case.body60
  ]

switch.case.body57:                               ; preds = %typeswitch.body56
  br label %switch.done61

switch.case.body58:                               ; preds = %typeswitch.body56
  %217 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$30")
  %218 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 9
  %219 = load i32, ptr %218, align 4
  %220 = sext i32 %219 to i64
  call void @"runtime::print_u64"(i64 %220)
  %221 = call i64 @"runtime::print_byte"(i8 93)
  %222 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 11
  %223 = load ptr, ptr %222, align 8
  call void @"runtime::print_type"(ptr %223)
  ret void

switch.case.body59:                               ; preds = %typeswitch.body56
  %224 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$31")
  %225 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 11
  %226 = load ptr, ptr %225, align 8
  call void @"runtime::print_type"(ptr %226)
  ret void

switch.case.body60:                               ; preds = %typeswitch.body56
  %227 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$32")
  %228 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 11
  %229 = load ptr, ptr %228, align 8
  call void @"runtime::print_type"(ptr %229)
  ret void

switch.done61:                                    ; preds = %switch.case.body57, %typeswitch.body56
  %230 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$33")
  %231 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 6
  %232 = load i8, ptr %231, align 1
  %233 = and i8 %232, 1
  %234 = icmp ne i8 %233, 0
  %235 = zext i1 %234 to i8
  %236 = icmp ne i8 %235, 0
  br i1 %236, label %if.then62, label %if.done63

if.then62:                                        ; preds = %switch.done61
  %237 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$34")
  br label %if.done63

if.done63:                                        ; preds = %if.then62, %switch.done61
  %238 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 6
  %239 = load i8, ptr %238, align 1
  %240 = and i8 %239, 2
  %241 = icmp ne i8 %240, 0
  %242 = zext i1 %241 to i8
  %243 = icmp ne i8 %242, 0
  br i1 %243, label %if.then64, label %if.done65

if.then64:                                        ; preds = %if.done63
  %244 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$35")
  br label %if.done65

if.done65:                                        ; preds = %if.then64, %if.done63
  %245 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 6
  %246 = load i8, ptr %245, align 1
  %247 = and i8 %246, 4
  %248 = icmp ne i8 %247, 0
  %249 = zext i1 %248 to i8
  %250 = icmp ne i8 %249, 0
  br i1 %250, label %if.then66, label %if.done67

if.then66:                                        ; preds = %if.done65
  %251 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$36")
  br label %if.done67

if.done67:                                        ; preds = %if.then66, %if.done65
  %252 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 6
  %253 = load i8, ptr %252, align 1
  %254 = and i8 %253, 8
  %255 = icmp ne i8 %254, 0
  %256 = zext i1 %255 to i8
  %257 = icmp ne i8 %256, 0
  br i1 %257, label %if.then68, label %if.done69

if.then68:                                        ; preds = %if.done67
  %258 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$37")
  %259 = load ptr, ptr %1, align 8
  %260 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %259, i32 0, i32 1
  %261 = load i64, ptr %260, align 8
  call void @"runtime::print_u64"(i64 %261)
  %262 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$38")
  br label %if.done69

if.done69:                                        ; preds = %if.then68, %if.done67
  %263 = call i64 @"runtime::print_byte"(i8 123)
  %264 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 1
  %265 = load ptr, ptr %264, align 8
  %266 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 5
  %267 = load i32, ptr %266, align 4
  %268 = sext i32 %267 to i64
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::print_type$39", i32 413, i32 28, i64 0, i64 %268)
  %269 = getelementptr %..string, ptr %265, i64 0
  %270 = sub i64 %268, 0
  %271 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 0
  %272 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 1
  store ptr %269, ptr %271, align 8
  store i64 %270, ptr %272, align 8
  %273 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 1
  %274 = load i64, ptr %273, align 8
  store i64 %274, ptr %9, align 8
  store i64 -1, ptr %10, align 8
  br label %for.index.loop70

for.index.loop70:                                 ; preds = %if.done75, %if.done69
  %275 = load i64, ptr %10, align 8
  %276 = add i64 %275, 1
  store i64 %276, ptr %10, align 8
  %277 = load i64, ptr %9, align 8
  %278 = icmp slt i64 %276, %277
  br i1 %278, label %for.index.body71, label %for.index.done76

for.index.body71:                                 ; preds = %for.index.loop70
  %279 = load i64, ptr %10, align 8
  %280 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 0
  %281 = load ptr, ptr %280, align 8
  %282 = getelementptr %..string, ptr %281, i64 %279
  %283 = load %..string, ptr %282, align 8
  store %..string %283, ptr %name72, align 8
  store i64 %279, ptr %i73, align 8
  %284 = load i64, ptr %i73, align 8
  %285 = icmp sgt i64 %284, 0
  %286 = zext i1 %285 to i8
  %287 = icmp ne i8 %286, 0
  br i1 %287, label %if.then74, label %if.done75

if.then74:                                        ; preds = %for.index.body71
  %288 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$40")
  br label %if.done75

if.done75:                                        ; preds = %if.then74, %for.index.body71
  %289 = call i64 @"runtime::print_string"(ptr %name72)
  %290 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$41")
  %291 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 0
  %292 = load ptr, ptr %291, align 8
  %293 = load i64, ptr %i73, align 8
  %294 = getelementptr ptr, ptr %292, i64 %293
  %295 = load ptr, ptr %294, align 8
  call void @"runtime::print_type"(ptr %295)
  br label %for.index.loop70

for.index.done76:                                 ; preds = %for.index.loop70
  %296 = call i64 @"runtime::print_byte"(i8 125)
  br label %typeswitch.done111

typeswitch.body77:                                ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 48, i1 false)
  %297 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$42")
  %298 = getelementptr inbounds nuw %"runtime::Type_Info_Union", ptr %2, i32 0, i32 4
  %299 = load i8, ptr %298, align 1
  %300 = icmp ne i8 %299, 0
  br i1 %300, label %if.then78, label %if.done79

if.then78:                                        ; preds = %typeswitch.body77
  %301 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$43")
  %302 = load ptr, ptr %1, align 8
  %303 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %302, i32 0, i32 1
  %304 = load i64, ptr %303, align 8
  call void @"runtime::print_u64"(i64 %304)
  %305 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$44")
  br label %if.done79

if.done79:                                        ; preds = %if.then78, %typeswitch.body77
  %306 = getelementptr inbounds nuw %"runtime::Type_Info_Union", ptr %2, i32 0, i32 5
  %307 = load i8, ptr %306, align 1
  %308 = icmp ne i8 %307, 0
  br i1 %308, label %if.then80, label %if.done81

if.then80:                                        ; preds = %if.done79
  %309 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$45")
  br label %if.done81

if.done81:                                        ; preds = %if.then80, %if.done79
  %310 = call i64 @"runtime::print_byte"(i8 123)
  %311 = getelementptr inbounds nuw %"runtime::Type_Info_Union", ptr %2, i32 0, i32 0
  %312 = getelementptr inbounds nuw { ptr, i64 }, ptr %311, i32 0, i32 1
  %313 = load i64, ptr %312, align 8
  store i64 %313, ptr %11, align 8
  store i64 -1, ptr %12, align 8
  br label %for.index.loop82

for.index.loop82:                                 ; preds = %if.done86, %if.done81
  %314 = load i64, ptr %12, align 8
  %315 = add i64 %314, 1
  store i64 %315, ptr %12, align 8
  %316 = load i64, ptr %11, align 8
  %317 = icmp slt i64 %315, %316
  br i1 %317, label %for.index.body83, label %for.index.done87

for.index.body83:                                 ; preds = %for.index.loop82
  %318 = load i64, ptr %12, align 8
  %319 = getelementptr inbounds nuw { ptr, i64 }, ptr %311, i32 0, i32 0
  %320 = load ptr, ptr %319, align 8
  %321 = getelementptr ptr, ptr %320, i64 %318
  %322 = load ptr, ptr %321, align 8
  store ptr %322, ptr %variant, align 8
  store i64 %318, ptr %i84, align 8
  %323 = load i64, ptr %i84, align 8
  %324 = icmp sgt i64 %323, 0
  %325 = zext i1 %324 to i8
  %326 = icmp ne i8 %325, 0
  br i1 %326, label %if.then85, label %if.done86

if.then85:                                        ; preds = %for.index.body83
  %327 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$46")
  br label %if.done86

if.done86:                                        ; preds = %if.then85, %for.index.body83
  %328 = load ptr, ptr %variant, align 8
  call void @"runtime::print_type"(ptr %328)
  br label %for.index.loop82

for.index.done87:                                 ; preds = %for.index.loop82
  %329 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$47")
  br label %typeswitch.done111

typeswitch.body88:                                ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 40, i1 false)
  %330 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$48")
  %331 = getelementptr inbounds nuw %"runtime::Type_Info_Enum", ptr %2, i32 0, i32 0
  %332 = load ptr, ptr %331, align 8
  call void @"runtime::print_type"(ptr %332)
  %333 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$49")
  %334 = getelementptr inbounds nuw %"runtime::Type_Info_Enum", ptr %2, i32 0, i32 1
  %335 = getelementptr inbounds nuw { ptr, i64 }, ptr %334, i32 0, i32 1
  %336 = load i64, ptr %335, align 8
  store i64 %336, ptr %13, align 8
  store i64 -1, ptr %14, align 8
  br label %for.index.loop89

for.index.loop89:                                 ; preds = %if.done94, %typeswitch.body88
  %337 = load i64, ptr %14, align 8
  %338 = add i64 %337, 1
  store i64 %338, ptr %14, align 8
  %339 = load i64, ptr %13, align 8
  %340 = icmp slt i64 %338, %339
  br i1 %340, label %for.index.body90, label %for.index.done95

for.index.body90:                                 ; preds = %for.index.loop89
  %341 = load i64, ptr %14, align 8
  %342 = getelementptr inbounds nuw { ptr, i64 }, ptr %334, i32 0, i32 0
  %343 = load ptr, ptr %342, align 8
  %344 = getelementptr %..string, ptr %343, i64 %341
  %345 = load %..string, ptr %344, align 8
  store %..string %345, ptr %name91, align 8
  store i64 %341, ptr %i92, align 8
  %346 = load i64, ptr %i92, align 8
  %347 = icmp sgt i64 %346, 0
  %348 = zext i1 %347 to i8
  %349 = icmp ne i8 %348, 0
  br i1 %349, label %if.then93, label %if.done94

if.then93:                                        ; preds = %for.index.body90
  %350 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$50")
  br label %if.done94

if.done94:                                        ; preds = %if.then93, %for.index.body90
  %351 = call i64 @"runtime::print_string"(ptr %name91)
  br label %for.index.loop89

for.index.done95:                                 ; preds = %for.index.loop89
  %352 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$51")
  br label %typeswitch.done111

typeswitch.body96:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 32, i1 false)
  %353 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$52")
  %354 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 0
  %355 = load ptr, ptr %354, align 8
  %356 = call ptr @"runtime::type_info_base"(ptr %355)
  store ptr %356, ptr %15, align 8
  %357 = load ptr, ptr %15, align 8
  %358 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %357, i32 0, i32 5
  %359 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %358, i32 0, i32 1
  %360 = load i64, ptr %359, align 8
  switch i64 %360, label %typeswitch.default.body [
    i64 21, label %typeswitch.body97
    i64 3, label %typeswitch.body98
  ]

typeswitch.body97:                                ; preds = %typeswitch.body96
  call void @llvm.memcpy.p0.p0.i64(ptr %16, ptr %358, i64 40, i1 false)
  %361 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 0
  %362 = load ptr, ptr %361, align 8
  call void @"runtime::print_type"(ptr %362)
  br label %typeswitch.done

typeswitch.body98:                                ; preds = %typeswitch.body96
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %16, ptr %358, i64 0, i1 false)
  %363 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 2
  %364 = load i64, ptr %363, align 8
  %365 = trunc i64 %364 to i32
  call void @"runtime::print_encoded_rune"(i32 %365)
  %366 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$53")
  %367 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 3
  %368 = load i64, ptr %367, align 8
  %369 = trunc i64 %368 to i32
  call void @"runtime::print_encoded_rune"(i32 %369)
  br label %typeswitch.done

typeswitch.default.body:                          ; preds = %typeswitch.body96
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %elem, ptr align 1 %358, i64 80, i1 false)
  %370 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 2
  %371 = load i64, ptr %370, align 8
  call void @"runtime::print_i64"(i64 %371)
  %372 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$54")
  %373 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 3
  %374 = load i64, ptr %373, align 8
  call void @"runtime::print_i64"(i64 %374)
  br label %typeswitch.done

typeswitch.done:                                  ; preds = %typeswitch.default.body, %typeswitch.body98, %typeswitch.body97
  %375 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 1
  %376 = load ptr, ptr %375, align 8
  %377 = icmp ne ptr %376, null
  %378 = zext i1 %377 to i8
  %379 = icmp ne i8 %378, 0
  br i1 %379, label %if.then99, label %if.done100

if.then99:                                        ; preds = %typeswitch.done
  %380 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$55")
  %381 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 1
  %382 = load ptr, ptr %381, align 8
  call void @"runtime::print_type"(ptr %382)
  br label %if.done100

if.done100:                                       ; preds = %if.then99, %typeswitch.done
  %383 = call i64 @"runtime::print_byte"(i8 93)
  br label %typeswitch.done111

typeswitch.body101:                               ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 56, i1 false)
  %384 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$56")
  %385 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Field", ptr %2, i32 0, i32 0
  %386 = load ptr, ptr %385, align 8
  call void @"runtime::print_type"(ptr %386)
  %387 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$57")
  %388 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Field", ptr %2, i32 0, i32 1
  %389 = load ptr, ptr %388, align 8
  %390 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Field", ptr %2, i32 0, i32 6
  %391 = load i64, ptr %390, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::print_type$58", i32 473, i32 28, i64 0, i64 %391)
  %392 = getelementptr %..string, ptr %389, i64 0
  %393 = sub i64 %391, 0
  %394 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 0
  %395 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 1
  store ptr %392, ptr %394, align 8
  store i64 %393, ptr %395, align 8
  %396 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 1
  %397 = load i64, ptr %396, align 8
  store i64 %397, ptr %18, align 8
  store i64 -1, ptr %19, align 8
  br label %for.index.loop102

for.index.loop102:                                ; preds = %if.done107, %typeswitch.body101
  %398 = load i64, ptr %19, align 8
  %399 = add i64 %398, 1
  store i64 %399, ptr %19, align 8
  %400 = load i64, ptr %18, align 8
  %401 = icmp slt i64 %399, %400
  br i1 %401, label %for.index.body103, label %for.index.done108

for.index.body103:                                ; preds = %for.index.loop102
  %402 = load i64, ptr %19, align 8
  %403 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 0
  %404 = load ptr, ptr %403, align 8
  %405 = getelementptr %..string, ptr %404, i64 %402
  %406 = load %..string, ptr %405, align 8
  store %..string %406, ptr %name104, align 8
  store i64 %402, ptr %i105, align 8
  %407 = load i64, ptr %i105, align 8
  %408 = icmp sgt i64 %407, 0
  %409 = zext i1 %408 to i8
  %410 = icmp ne i8 %409, 0
  br i1 %410, label %if.then106, label %if.done107

if.then106:                                       ; preds = %for.index.body103
  %411 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$59")
  br label %if.done107

if.done107:                                       ; preds = %if.then106, %for.index.body103
  %412 = call i64 @"runtime::print_string"(ptr %name104)
  %413 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$60")
  %414 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Field", ptr %2, i32 0, i32 2
  %415 = load ptr, ptr %414, align 8
  %416 = load i64, ptr %i105, align 8
  %417 = getelementptr ptr, ptr %415, i64 %416
  %418 = load ptr, ptr %417, align 8
  call void @"runtime::print_type"(ptr %418)
  %419 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$61")
  %420 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Field", ptr %2, i32 0, i32 3
  %421 = load ptr, ptr %420, align 8
  %422 = load i64, ptr %i105, align 8
  %423 = getelementptr i64, ptr %421, i64 %422
  %424 = load i64, ptr %423, align 8
  call void @"runtime::print_u64"(i64 %424)
  br label %for.index.loop102

for.index.done108:                                ; preds = %for.index.loop102
  %425 = call i64 @"runtime::print_byte"(i8 125)
  br label %typeswitch.done111

typeswitch.body109:                               ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 24, i1 false)
  %426 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$62")
  %427 = getelementptr inbounds nuw %"runtime::Type_Info_Simd_Vector", ptr %2, i32 0, i32 2
  %428 = load i64, ptr %427, align 8
  call void @"runtime::print_u64"(i64 %428)
  %429 = call i64 @"runtime::print_byte"(i8 93)
  %430 = getelementptr inbounds nuw %"runtime::Type_Info_Simd_Vector", ptr %2, i32 0, i32 0
  %431 = load ptr, ptr %430, align 8
  call void @"runtime::print_type"(ptr %431)
  br label %typeswitch.done111

typeswitch.body110:                               ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 48, i1 false)
  %432 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$63")
  %433 = getelementptr inbounds nuw %"runtime::Type_Info_Matrix", ptr %2, i32 0, i32 3
  %434 = load i64, ptr %433, align 8
  call void @"runtime::print_u64"(i64 %434)
  %435 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$64")
  %436 = getelementptr inbounds nuw %"runtime::Type_Info_Matrix", ptr %2, i32 0, i32 4
  %437 = load i64, ptr %436, align 8
  call void @"runtime::print_u64"(i64 %437)
  %438 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::print_type$65")
  %439 = getelementptr inbounds nuw %"runtime::Type_Info_Matrix", ptr %2, i32 0, i32 0
  %440 = load ptr, ptr %439, align 8
  call void @"runtime::print_type"(ptr %440)
  br label %typeswitch.done111

typeswitch.done111:                               ; preds = %typeswitch.body110, %typeswitch.body109, %for.index.done108, %if.done100, %for.index.done95, %for.index.done87, %for.index.done76, %typeswitch.body55, %typeswitch.body54, %typeswitch.body53, %if.done52, %typeswitch.body49, %if.done48, %if.done34, %typeswitch.body25, %typeswitch.body24, %if.done23, %typeswitch.body19, %typeswitch.body18, %switch.done17, %typeswitch.body12, %typeswitch.body11, %typeswitch.body10, %typeswitch.body9, %typeswitch.body8, %switch.done, %typeswitch.body, %if.done
  ret void
}

define i8 @"runtime::arena_allocator_proc"(ptr %0, i8 %1, i64 %2, i64 %3, ptr %4, i64 %5, ptr %6, ptr noalias nonnull %7, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %8 = alloca ptr, align 8
  %9 = alloca i8, align 1
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i64, align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %arena = alloca ptr, align 8
  %size = alloca i64, align 8
  %alignment = alloca i64, align 8
  %old_size = alloca i64, align 8
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { { ptr, i64 }, i8 }, align 8
  %old_data = alloca ptr, align 8
  %16 = alloca { ptr, i64 }, align 8
  %17 = alloca { { ptr, i64 }, i8 }, align 8
  %18 = alloca { ptr, i64 }, align 8
  %19 = alloca { ptr, i64 }, align 8
  %block = alloca ptr, align 8
  %start = alloca i64, align 8
  %old_end = alloca i64, align 8
  %new_end = alloca i64, align 8
  %20 = alloca { ptr, i64 }, align 8
  %21 = alloca { ptr, i64 }, align 8
  %22 = alloca { { ptr, i64 }, i8 }, align 8
  %new_memory = alloca { ptr, i64 }, align 8
  %23 = alloca { ptr, i64 }, align 8
  %set = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %8, align 8
  store i8 %1, ptr %9, align 1
  store i64 %2, ptr %10, align 8
  store i64 %3, ptr %11, align 8
  store ptr %4, ptr %12, align 8
  store i64 %5, ptr %13, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  store ptr %0, ptr %arena, align 8
  store i64 %2, ptr %size, align 8
  store i64 %3, ptr %alignment, align 8
  store i64 %5, ptr %old_size, align 8
  switch i8 %1, label %switch.done22 [
    i8 0, label %switch.case.body
    i8 6, label %switch.case.body
    i8 1, label %switch.case.body1
    i8 2, label %switch.case.body2
    i8 3, label %switch.case.body3
    i8 7, label %switch.case.body3
    i8 4, label %switch.case.body18
    i8 5, label %switch.case.body21
  ]

switch.case.body:                                 ; preds = %entry, %entry
  %24 = load ptr, ptr %arena, align 8
  %25 = load i64, ptr %size, align 8
  %26 = load i64, ptr %alignment, align 8
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false)
  %27 = call i8 @"runtime::arena_alloc"(ptr %24, i64 %25, i64 %26, ptr %6, ptr %14, ptr %__.context_ptr)
  %28 = load { ptr, i64 }, ptr %14, align 8
  store { ptr, i64 } %28, ptr %data, align 8
  store i8 %27, ptr %err, align 1
  store { ptr, i64 } %28, ptr %7, align 8
  ret i8 %27

switch.case.body1:                                ; preds = %entry
  store i8 4, ptr %err, align 1
  br label %switch.done22

switch.case.body2:                                ; preds = %entry
  %29 = load ptr, ptr %arena, align 8
  call void @"runtime::arena_free_all"(ptr %29, ptr %6, ptr %__.context_ptr)
  br label %switch.done22

switch.case.body3:                                ; preds = %entry, %entry
  store ptr %4, ptr %old_data, align 8
  %30 = load ptr, ptr %old_data, align 8
  %31 = icmp eq ptr %30, null
  %32 = zext i1 %31 to i8
  %33 = icmp eq i8 1, %32
  br i1 %33, label %switch.case.body4, label %switch.case.next

switch.case.next:                                 ; preds = %switch.case.body3
  %34 = load i64, ptr %size, align 8
  %35 = load i64, ptr %old_size, align 8
  %36 = icmp eq i64 %34, %35
  %37 = zext i1 %36 to i8
  %38 = icmp eq i8 1, %37
  br i1 %38, label %switch.case.body6, label %switch.case.next5

switch.case.body4:                                ; preds = %switch.case.body3
  %39 = load ptr, ptr %arena, align 8
  %40 = load i64, ptr %size, align 8
  %41 = load i64, ptr %alignment, align 8
  call void @llvm.memset.inline.p0.i64(ptr %16, i8 0, i64 16, i1 false)
  %42 = call i8 @"runtime::arena_alloc"(ptr %39, i64 %40, i64 %41, ptr %6, ptr %16, ptr %__.context_ptr)
  %43 = load { ptr, i64 }, ptr %16, align 8
  store { ptr, i64 } %43, ptr %data, align 8
  store i8 %42, ptr %err, align 1
  store { ptr, i64 } %43, ptr %7, align 8
  ret i8 %42

switch.case.next5:                                ; preds = %switch.case.next
  %44 = load i64, ptr %size, align 8
  %45 = icmp eq i64 %44, 0
  %46 = zext i1 %45 to i8
  %47 = icmp eq i8 1, %46
  br i1 %47, label %switch.case.body8, label %switch.case.next7

switch.case.body6:                                ; preds = %switch.case.next
  %48 = load ptr, ptr %old_data, align 8
  %49 = load i64, ptr %size, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::arena_allocator_proc$1", i32 215, i32 19, i64 0, i64 %49)
  %50 = getelementptr i8, ptr %48, i64 0
  %51 = sub i64 %49, 0
  %52 = getelementptr inbounds nuw { ptr, i64 }, ptr %18, i32 0, i32 0
  %53 = getelementptr inbounds nuw { ptr, i64 }, ptr %18, i32 0, i32 1
  store ptr %50, ptr %52, align 8
  store i64 %51, ptr %53, align 8
  %54 = load { ptr, i64 }, ptr %18, align 8
  store { ptr, i64 } %54, ptr %data, align 8
  %55 = load { ptr, i64 }, ptr %data, align 8
  %56 = load i8, ptr %err, align 1
  store { ptr, i64 } %55, ptr %data, align 8
  store i8 %56, ptr %err, align 1
  store { ptr, i64 } %55, ptr %7, align 8
  ret i8 %56

switch.case.next7:                                ; preds = %switch.case.next5
  %57 = load ptr, ptr %old_data, align 8
  %58 = ptrtoint ptr %57 to i64
  %59 = load i64, ptr %alignment, align 8
  %60 = sub i64 %59, 1
  %61 = and i64 %58, %60
  %62 = icmp eq i64 %61, 0
  %63 = zext i1 %62 to i8
  %64 = icmp eq i8 1, %63
  br i1 %64, label %switch.case.body10, label %switch.case.next9

switch.case.body8:                                ; preds = %switch.case.next5
  store i8 4, ptr %err, align 1
  %65 = load { ptr, i64 }, ptr %data, align 8
  %66 = load i8, ptr %err, align 1
  store { ptr, i64 } %65, ptr %data, align 8
  store i8 %66, ptr %err, align 1
  store { ptr, i64 } %65, ptr %7, align 8
  ret i8 %66

switch.case.next9:                                ; preds = %switch.case.next7
  br label %switch.done

switch.case.body10:                               ; preds = %switch.case.next7
  %67 = load i64, ptr %size, align 8
  %68 = load i64, ptr %old_size, align 8
  %69 = icmp ult i64 %67, %68
  %70 = zext i1 %69 to i8
  %71 = icmp ne i8 %70, 0
  br i1 %71, label %if.then, label %if.done

if.then:                                          ; preds = %switch.case.body10
  %72 = load ptr, ptr %old_data, align 8
  %73 = load i64, ptr %size, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::arena_allocator_proc$2", i32 223, i32 20, i64 0, i64 %73)
  %74 = getelementptr i8, ptr %72, i64 0
  %75 = sub i64 %73, 0
  %76 = getelementptr inbounds nuw { ptr, i64 }, ptr %19, i32 0, i32 0
  %77 = getelementptr inbounds nuw { ptr, i64 }, ptr %19, i32 0, i32 1
  store ptr %74, ptr %76, align 8
  store i64 %75, ptr %77, align 8
  %78 = load { ptr, i64 }, ptr %19, align 8
  store { ptr, i64 } %78, ptr %data, align 8
  %79 = load { ptr, i64 }, ptr %data, align 8
  %80 = load i8, ptr %err, align 1
  store { ptr, i64 } %79, ptr %data, align 8
  store i8 %80, ptr %err, align 1
  store { ptr, i64 } %79, ptr %7, align 8
  ret i8 %80

if.done:                                          ; preds = %switch.case.body10
  br label %if.init

if.init:                                          ; preds = %if.done
  %81 = load ptr, ptr %arena, align 8
  %82 = getelementptr inbounds nuw %"runtime::Arena", ptr %81, i32 0, i32 1
  %83 = load ptr, ptr %82, align 8
  store ptr %83, ptr %block, align 8
  %84 = load ptr, ptr %block, align 8
  %85 = icmp ne ptr %84, null
  %86 = zext i1 %85 to i8
  %87 = icmp ne i8 %86, 0
  br i1 %87, label %if.then11, label %if.done15

if.then11:                                        ; preds = %if.init
  %88 = ptrtoint ptr %4 to i64
  %89 = load ptr, ptr %block, align 8
  %90 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %89, i32 0, i32 2
  %91 = load ptr, ptr %90, align 8
  %92 = ptrtoint ptr %91 to i64
  %93 = sub i64 %88, %92
  store i64 %93, ptr %start, align 8
  %94 = load i64, ptr %start, align 8
  %95 = load i64, ptr %old_size, align 8
  %96 = add i64 %94, %95
  store i64 %96, ptr %old_end, align 8
  %97 = load i64, ptr %start, align 8
  %98 = load i64, ptr %size, align 8
  %99 = add i64 %97, %98
  store i64 %99, ptr %new_end, align 8
  %100 = load i64, ptr %start, align 8
  %101 = load i64, ptr %old_end, align 8
  %102 = icmp ult i64 %100, %101
  %103 = zext i1 %102 to i8
  %104 = icmp ne i8 %103, 0
  br i1 %104, label %cmp.and, label %if.done14

cmp.and:                                          ; preds = %if.then11
  %105 = load i64, ptr %old_end, align 8
  %106 = load ptr, ptr %block, align 8
  %107 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %106, i32 0, i32 3
  %108 = load i64, ptr %107, align 8
  %109 = icmp eq i64 %105, %108
  %110 = zext i1 %109 to i8
  %111 = icmp ne i8 %110, 0
  br i1 %111, label %cmp.and12, label %if.done14

cmp.and12:                                        ; preds = %cmp.and
  %112 = load i64, ptr %new_end, align 8
  %113 = load ptr, ptr %block, align 8
  %114 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %113, i32 0, i32 4
  %115 = load i64, ptr %114, align 8
  %116 = icmp ule i64 %112, %115
  %117 = zext i1 %116 to i8
  %118 = icmp ne i8 %117, 0
  br i1 %118, label %if.then13, label %if.done14

if.then13:                                        ; preds = %cmp.and12
  %119 = load ptr, ptr %block, align 8
  %120 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %119, i32 0, i32 3
  %121 = load i64, ptr %new_end, align 8
  store i64 %121, ptr %120, align 8
  %122 = load ptr, ptr %block, align 8
  %123 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %122, i32 0, i32 2
  %124 = load ptr, ptr %123, align 8
  %125 = load i64, ptr %start, align 8
  %126 = load i64, ptr %new_end, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::arena_allocator_proc$3", i32 234, i32 23, i64 %125, i64 %126)
  %127 = getelementptr i8, ptr %124, i64 %125
  %128 = sub i64 %126, %125
  %129 = getelementptr inbounds nuw { ptr, i64 }, ptr %20, i32 0, i32 0
  %130 = getelementptr inbounds nuw { ptr, i64 }, ptr %20, i32 0, i32 1
  store ptr %127, ptr %129, align 8
  store i64 %128, ptr %130, align 8
  %131 = load { ptr, i64 }, ptr %20, align 8
  store { ptr, i64 } %131, ptr %data, align 8
  %132 = load { ptr, i64 }, ptr %data, align 8
  %133 = load i8, ptr %err, align 1
  store { ptr, i64 } %132, ptr %data, align 8
  store i8 %133, ptr %err, align 1
  store { ptr, i64 } %132, ptr %7, align 8
  ret i8 %133

if.done14:                                        ; preds = %cmp.and12, %cmp.and, %if.then11
  br label %if.done15

if.done15:                                        ; preds = %if.done14, %if.init
  br label %switch.done

switch.done:                                      ; preds = %switch.case.next9, %if.done15
  %134 = load ptr, ptr %arena, align 8
  %135 = load i64, ptr %size, align 8
  %136 = load i64, ptr %alignment, align 8
  call void @llvm.memset.inline.p0.i64(ptr %21, i8 0, i64 16, i1 false)
  %137 = call i8 @"runtime::arena_alloc"(ptr %134, i64 %135, i64 %136, ptr %6, ptr %21, ptr %__.context_ptr)
  %138 = load { ptr, i64 }, ptr %21, align 8
  %139 = icmp eq i8 %137, 0
  br i1 %139, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %switch.done
  store i8 %137, ptr %err, align 1
  %140 = load { ptr, i64 }, ptr %data, align 8
  %141 = load i8, ptr %err, align 1
  store { ptr, i64 } %140, ptr %data, align 8
  store i8 %141, ptr %err, align 1
  store { ptr, i64 } %140, ptr %7, align 8
  ret i8 %141

or_return.continue:                               ; preds = %switch.done
  store { ptr, i64 } %138, ptr %new_memory, align 8
  %142 = getelementptr inbounds nuw { ptr, i64 }, ptr %new_memory, i32 0, i32 0
  %143 = load ptr, ptr %142, align 8
  %144 = icmp eq ptr %143, null
  %145 = zext i1 %144 to i8
  %146 = icmp ne i8 %145, 0
  br i1 %146, label %if.then16, label %if.done17

if.then16:                                        ; preds = %or_return.continue
  %147 = load { ptr, i64 }, ptr %data, align 8
  %148 = load i8, ptr %err, align 1
  store { ptr, i64 } %147, ptr %data, align 8
  store i8 %148, ptr %err, align 1
  store { ptr, i64 } %147, ptr %7, align 8
  ret i8 %148

if.done17:                                        ; preds = %or_return.continue
  %149 = load ptr, ptr %old_data, align 8
  %150 = load i64, ptr %old_size, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::arena_allocator_proc$4", i32 245, i32 28, i64 0, i64 %150)
  %151 = getelementptr i8, ptr %149, i64 0
  %152 = sub i64 %150, 0
  %153 = getelementptr inbounds nuw { ptr, i64 }, ptr %23, i32 0, i32 0
  %154 = getelementptr inbounds nuw { ptr, i64 }, ptr %23, i32 0, i32 1
  store ptr %151, ptr %153, align 8
  store i64 %152, ptr %154, align 8
  %155 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"(ptr %new_memory, ptr %23)
  %156 = load { ptr, i64 }, ptr %new_memory, align 8
  store { ptr, i64 } %156, ptr %data, align 8
  store i8 0, ptr %err, align 1
  store { ptr, i64 } %156, ptr %7, align 8
  ret i8 0

switch.case.body18:                               ; preds = %entry
  store ptr %4, ptr %set, align 8
  %157 = load ptr, ptr %set, align 8
  %158 = icmp ne ptr %157, null
  %159 = zext i1 %158 to i8
  %160 = icmp ne i8 %159, 0
  br i1 %160, label %if.then19, label %if.done20

if.then19:                                        ; preds = %switch.case.body18
  %161 = load ptr, ptr %set, align 8
  store i8 93, ptr %161, align 1
  br label %if.done20

if.done20:                                        ; preds = %if.then19, %switch.case.body18
  br label %switch.done22

switch.case.body21:                               ; preds = %entry
  store i8 4, ptr %err, align 1
  br label %switch.done22

switch.done22:                                    ; preds = %switch.case.body21, %if.done20, %switch.case.body2, %switch.case.body1, %entry
  %162 = load { ptr, i64 }, ptr %data, align 8
  %163 = load i8, ptr %err, align 1
  store { ptr, i64 } %162, ptr %data, align 8
  store i8 %163, ptr %err, align 1
  store { ptr, i64 } %162, ptr %7, align 8
  ret i8 %163
}

define void @"runtime::clear_dynamic_array:proc\22contextless\22(array:^[dynamic]text_analyzer::Highlight)"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp ne ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store ptr %0, ptr %2, align 8
  %6 = load ptr, ptr %2, align 8
  %7 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %6, i32 0, i32 1
  store i64 0, ptr %7, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  ret void
}

define void @"runtime::clear_dynamic_array:proc\22contextless\22(array:^[dynamic]text_analyzer::Filter)"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp ne ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store ptr %0, ptr %2, align 8
  %6 = load ptr, ptr %2, align 8
  %7 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %6, i32 0, i32 1
  store i64 0, ptr %7, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  ret void
}

define void @"runtime::clear_dynamic_array:proc\22contextless\22(array:^[dynamic]string)"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp ne ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store ptr %0, ptr %2, align 8
  %6 = load ptr, ptr %2, align 8
  %7 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %6, i32 0, i32 1
  store i64 0, ptr %7, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  ret void
}

define void @"runtime::clear_dynamic_array:proc\22contextless\22(array:^[dynamic]int)"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp ne ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store ptr %0, ptr %2, align 8
  %6 = load ptr, ptr %2, align 8
  %7 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %6, i32 0, i32 1
  store i64 0, ptr %7, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  ret void
}

define void @"runtime::clear_map:proc\22contextless\22(m:^map[int]bool)"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca ptr, align 8
  %6 = alloca i64, align 8
  %hs.i = alloca ptr, align 8
  %7 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %7, align 8
  %8 = icmp eq ptr %0, null
  %9 = zext i1 %8 to i8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  call void @llvm.experimental.noalias.scope.decl(metadata !15)
  call void @llvm.experimental.noalias.scope.decl(metadata !18)
  call void @llvm.lifetime.start.p0(i64 8, ptr %1)
  call void @llvm.lifetime.start.p0(i64 8, ptr %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %hs.i)
  store ptr %0, ptr %1, align 8, !noalias !20
  store ptr @"ggv$map_info-9128505474150644346", ptr %2, align 8, !noalias !20
  %11 = load ptr, ptr %1, align 8, !noalias !20
  %12 = load i64, ptr %11, align 8
  %13 = icmp eq i64 %12, 0
  %14 = zext i1 %13 to i8
  br i1 %13, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %if.done
  call void @llvm.lifetime.end.p0(i64 8, ptr %1)
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %hs.i)
  br label %"runtime::map_clear_dynamic.exit"

if.done.i:                                        ; preds = %if.done
  store i64 0, ptr %3, align 8, !noalias !20
  store i64 0, ptr %4, align 8, !noalias !20
  store ptr null, ptr %5, align 8, !noalias !20
  store i64 0, ptr %6, align 8, !noalias !20
  %15 = call i64 @"runtime::map_kvh_data_dynamic"(ptr %0, ptr @"ggv$map_info-9128505474150644346", ptr %3, ptr %4, ptr %5, ptr %6)
  %16 = load ptr, ptr %5, align 8, !noalias !20
  store ptr %16, ptr %hs.i, align 8, !noalias !20
  %17 = load ptr, ptr %hs.i, align 8, !noalias !20
  %18 = load i64, ptr %0, align 8, !alias.scope !15, !noalias !18
  %19 = icmp eq i64 %18, 0
  %20 = zext i1 %19 to i8
  br i1 %19, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %if.done.i
  br label %"runtime::map_cap.exit.i"

if.else.i.i:                                      ; preds = %if.done.i
  %21 = load i64, ptr %0, align 8, !alias.scope !15, !noalias !18
  %22 = and i64 %21, 63
  %23 = shl i64 1, %22
  br label %"runtime::map_cap.exit.i"

"runtime::map_cap.exit.i":                        ; preds = %if.else.i.i, %if.then.i.i
  %24 = phi i64 [ 0, %if.then.i.i ], [ %23, %if.else.i.i ]
  %25 = mul i64 %24, 8
  call void @llvm.memset.p0.i64(ptr %17, i8 0, i64 %25, i1 false)
  %26 = load ptr, ptr %1, align 8, !noalias !20
  %27 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %26, i32 0, i32 1
  store i64 0, ptr %27, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr %1)
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %hs.i)
  br label %"runtime::map_clear_dynamic.exit"

"runtime::map_clear_dynamic.exit":                ; preds = %"runtime::map_cap.exit.i", %if.then.i
  ret void
}

define i8 @"runtime::mem_resize"(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, ptr %5, ptr noalias nonnull %6, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %7 = alloca i64, align 8
  %8 = alloca ptr, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca %"runtime::Allocator", align 8
  %13 = alloca i8, align 1
  %data.i = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { ptr, i64 }, align 8
  %16 = alloca ptr, align 8
  %17 = alloca { ptr, i64 }, align 8
  %18 = alloca { ptr, i64 }, align 8
  %19 = alloca { ptr, i64 }, align 8
  %20 = alloca ptr, align 8
  %21 = alloca { ptr, i64 }, align 8
  %22 = alloca { ptr, i64 }, align 8
  %23 = alloca i64, align 8
  %24 = alloca ptr, align 8
  %25 = alloca i64, align 8
  %26 = alloca i64, align 8
  %27 = alloca i64, align 8
  %28 = alloca %"runtime::Allocator", align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %29 = alloca { ptr, i64 }, align 8
  %30 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %24, align 8
  store i64 %1, ptr %25, align 8
  store i64 %2, ptr %26, align 8
  store i64 %3, ptr %27, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %28, ptr %4, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  call void @llvm.lifetime.start.p0(i64 8, ptr %23)
  store i64 %3, ptr %23, align 8
  %31 = icmp sle i64 %3, 0
  %32 = zext i1 %31 to i8
  br i1 %31, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %23)
  br label %"runtime::is_power_of_two_int.exit"

if.done.i:                                        ; preds = %entry
  %33 = sub i64 %3, 1
  %34 = and i64 %3, %33
  %35 = icmp eq i64 %34, 0
  %36 = zext i1 %35 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %23)
  br label %"runtime::is_power_of_two_int.exit"

"runtime::is_power_of_two_int.exit":              ; preds = %if.done.i, %if.then.i
  %37 = phi i8 [ 0, %if.then.i ], [ %36, %if.done.i ]
  %38 = icmp ne i8 %37, 0
  call void @"runtime::assert"(i1 zeroext %38, ptr @"ggv$runtime::mem_resize$1", ptr %5, ptr %__.context_ptr)
  call void @llvm.memset.inline.p0.i64(ptr %29, i8 0, i64 16, i1 false)
  call void @llvm.experimental.noalias.scope.decl(metadata !21)
  call void @llvm.experimental.noalias.scope.decl(metadata !24)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 16, ptr %12)
  call void @llvm.lifetime.start.p0(i64 1, ptr %13)
  call void @llvm.lifetime.start.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %14)
  call void @llvm.lifetime.start.p0(i64 16, ptr %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr %16)
  call void @llvm.lifetime.start.p0(i64 16, ptr %17)
  call void @llvm.lifetime.start.p0(i64 16, ptr %18)
  call void @llvm.lifetime.start.p0(i64 16, ptr %19)
  call void @llvm.lifetime.start.p0(i64 8, ptr %20)
  call void @llvm.lifetime.start.p0(i64 16, ptr %21)
  call void @llvm.lifetime.start.p0(i64 16, ptr %22)
  store ptr %0, ptr %8, align 8, !noalias !26
  store i64 %1, ptr %9, align 8, !noalias !26
  store i64 %2, ptr %10, align 8, !noalias !26
  store i64 %3, ptr %11, align 8, !noalias !26
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %12, ptr %28, i64 16, i1 false), !noalias !26
  store i8 1, ptr %13, align 1, !noalias !26
  call void @llvm.memset.inline.p0.i64(ptr %data.i, i8 0, i64 16, i1 false), !noalias !26
  store i8 0, ptr %err.i, align 1, !noalias !26
  call void @llvm.lifetime.start.p0(i64 8, ptr %7), !noalias !26
  store i64 %3, ptr %7, align 8, !noalias !26
  %39 = icmp sle i64 %3, 0
  %40 = zext i1 %39 to i8
  br i1 %39, label %if.then.i.i, label %if.done.i.i

if.then.i.i:                                      ; preds = %"runtime::is_power_of_two_int.exit"
  call void @llvm.lifetime.end.p0(i64 8, ptr %7), !noalias !26
  br label %"runtime::is_power_of_two_int.exit.i"

if.done.i.i:                                      ; preds = %"runtime::is_power_of_two_int.exit"
  %41 = sub i64 %3, 1
  %42 = and i64 %3, %41
  %43 = icmp eq i64 %42, 0
  %44 = zext i1 %43 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %7), !noalias !26
  br label %"runtime::is_power_of_two_int.exit.i"

"runtime::is_power_of_two_int.exit.i":            ; preds = %if.done.i.i, %if.then.i.i
  %45 = phi i8 [ 0, %if.then.i.i ], [ %44, %if.done.i.i ]
  %46 = icmp ne i8 %45, 0
  call void @"runtime::assert"(i1 zeroext %46, ptr @"ggv$runtime::_mem_resize$1", ptr %5, ptr nonnull %__.context_ptr), !noalias !21
  %47 = load ptr, ptr %12, align 8, !noalias !26
  %48 = icmp eq ptr %47, null
  %49 = zext i1 %48 to i8
  br i1 %48, label %if.then.i2, label %if.done.i1

if.then.i2:                                       ; preds = %"runtime::is_power_of_two_int.exit.i"
  store { ptr, i64 } zeroinitializer, ptr %data.i, align 8, !noalias !26
  store i8 0, ptr %err.i, align 1, !noalias !26
  store { ptr, i64 } zeroinitializer, ptr %29, align 8, !alias.scope !21, !noalias !24
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

if.done.i1:                                       ; preds = %"runtime::is_power_of_two_int.exit.i"
  %50 = icmp eq i64 %2, 0
  %51 = zext i1 %50 to i8
  br i1 %50, label %if.then1.i, label %if.else.i

if.then1.i:                                       ; preds = %if.done.i1
  %52 = icmp ne ptr %0, null
  %53 = zext i1 %52 to i8
  br i1 %52, label %if.then2.i, label %if.done3.i

if.then2.i:                                       ; preds = %if.then1.i
  %54 = load ptr, ptr %12, align 8, !noalias !26
  %55 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %56 = load ptr, ptr %55, align 8, !noalias !26
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false), !noalias !26
  %57 = call i8 %54(ptr %56, i8 1, i64 0, i64 0, ptr %0, i64 %1, ptr %5, ptr %14, ptr nonnull %__.context_ptr), !noalias !21
  store i8 %57, ptr %err.i, align 1, !noalias !26
  %58 = load { ptr, i64 }, ptr %data.i, align 8, !noalias !26
  %59 = load i8, ptr %err.i, align 1, !noalias !26
  store { ptr, i64 } %58, ptr %data.i, align 8, !noalias !26
  store i8 %59, ptr %err.i, align 1, !noalias !26
  store { ptr, i64 } %58, ptr %29, align 8, !alias.scope !21, !noalias !24
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

if.done3.i:                                       ; preds = %if.then1.i
  %60 = load { ptr, i64 }, ptr %data.i, align 8, !noalias !26
  %61 = load i8, ptr %err.i, align 1, !noalias !26
  store { ptr, i64 } %60, ptr %data.i, align 8, !noalias !26
  store i8 %61, ptr %err.i, align 1, !noalias !26
  store { ptr, i64 } %60, ptr %29, align 8, !alias.scope !21, !noalias !24
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

if.else.i:                                        ; preds = %if.done.i1
  %62 = icmp eq ptr %0, null
  %63 = zext i1 %62 to i8
  br i1 %62, label %if.then4.i, label %if.else8.i

if.then4.i:                                       ; preds = %if.else.i
  %64 = load ptr, ptr %12, align 8, !noalias !26
  %65 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %66 = load ptr, ptr %65, align 8, !noalias !26
  call void @llvm.memset.inline.p0.i64(ptr %15, i8 0, i64 16, i1 false), !noalias !26
  %67 = call i8 %64(ptr %66, i8 0, i64 %2, i64 %3, ptr null, i64 0, ptr %5, ptr %15, ptr nonnull %__.context_ptr), !noalias !21
  %68 = load { ptr, i64 }, ptr %15, align 8, !noalias !26
  store { ptr, i64 } %68, ptr %data.i, align 8, !noalias !26
  store i8 %67, ptr %err.i, align 1, !noalias !26
  store { ptr, i64 } %68, ptr %29, align 8, !alias.scope !21, !noalias !24
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

if.else8.i:                                       ; preds = %if.else.i
  %69 = icmp eq i64 %1, %2
  %70 = zext i1 %69 to i8
  br i1 %69, label %cmp.and.i, label %if.done10.i

cmp.and.i:                                        ; preds = %if.else8.i
  %71 = ptrtoint ptr %0 to i64
  %72 = urem i64 %71, %3
  %73 = icmp eq i64 %72, 0
  %74 = zext i1 %73 to i8
  br i1 %73, label %if.then9.i, label %if.done10.i

if.then9.i:                                       ; preds = %cmp.and.i
  store ptr %0, ptr %16, align 8, !noalias !26
  %75 = load ptr, ptr %16, align 8, !noalias !26
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::_mem_resize$2", i32 200, i32 24, i64 0, i64 %1), !noalias !26
  %76 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 1
  store ptr %75, ptr %17, align 8, !noalias !26
  store i64 %1, ptr %76, align 8, !noalias !26
  %77 = load { ptr, i64 }, ptr %17, align 8, !noalias !26
  store { ptr, i64 } %77, ptr %data.i, align 8, !noalias !26
  %78 = load { ptr, i64 }, ptr %data.i, align 8, !noalias !26
  %79 = load i8, ptr %err.i, align 1, !noalias !26
  store { ptr, i64 } %78, ptr %data.i, align 8, !noalias !26
  store i8 %79, ptr %err.i, align 1, !noalias !26
  store { ptr, i64 } %78, ptr %29, align 8, !alias.scope !21, !noalias !24
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

if.done10.i:                                      ; preds = %cmp.and.i, %if.else8.i
  %80 = load ptr, ptr %12, align 8, !noalias !26
  %81 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %82 = load ptr, ptr %81, align 8, !noalias !26
  call void @llvm.memset.inline.p0.i64(ptr %18, i8 0, i64 16, i1 false), !noalias !26
  %83 = call i8 %80(ptr %82, i8 3, i64 %2, i64 %3, ptr %0, i64 %1, ptr %5, ptr %18, ptr nonnull %__.context_ptr), !noalias !21
  %84 = load { ptr, i64 }, ptr %18, align 8, !noalias !26
  store { ptr, i64 } %84, ptr %data.i, align 8, !noalias !26
  store i8 %83, ptr %err.i, align 1, !noalias !26
  %85 = load i8, ptr %err.i, align 1, !noalias !26
  %86 = icmp eq i8 %85, 4
  %87 = zext i1 %86 to i8
  br i1 %86, label %if.then16.i, label %if.done22.i

if.then16.i:                                      ; preds = %if.done10.i
  %88 = load ptr, ptr %12, align 8, !noalias !26
  %89 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %90 = load ptr, ptr %89, align 8, !noalias !26
  call void @llvm.memset.inline.p0.i64(ptr %19, i8 0, i64 16, i1 false), !noalias !26
  %91 = call i8 %88(ptr %90, i8 0, i64 %2, i64 %3, ptr null, i64 0, ptr %5, ptr %19, ptr nonnull %__.context_ptr), !noalias !21
  %92 = load { ptr, i64 }, ptr %19, align 8, !noalias !26
  store { ptr, i64 } %92, ptr %data.i, align 8, !noalias !26
  store i8 %91, ptr %err.i, align 1, !noalias !26
  %93 = load i8, ptr %err.i, align 1, !noalias !26
  %94 = icmp ne i8 %93, 0
  %95 = zext i1 %94 to i8
  br i1 %94, label %if.then20.i, label %if.done21.i

if.then20.i:                                      ; preds = %if.then16.i
  %96 = load { ptr, i64 }, ptr %data.i, align 8, !noalias !26
  %97 = load i8, ptr %err.i, align 1, !noalias !26
  store { ptr, i64 } %96, ptr %data.i, align 8, !noalias !26
  store i8 %97, ptr %err.i, align 1, !noalias !26
  store { ptr, i64 } %96, ptr %29, align 8, !alias.scope !21, !noalias !24
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

if.done21.i:                                      ; preds = %if.then16.i
  store ptr %0, ptr %20, align 8, !noalias !26
  %98 = load ptr, ptr %20, align 8, !noalias !26
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::_mem_resize$3", i32 218, i32 28, i64 0, i64 %1), !noalias !21
  %99 = getelementptr inbounds nuw { ptr, i64 }, ptr %21, i32 0, i32 1
  store ptr %98, ptr %21, align 8, !noalias !26
  store i64 %1, ptr %99, align 8, !noalias !26
  %100 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"(ptr %data.i, ptr %21), !noalias !21
  %101 = load ptr, ptr %12, align 8, !noalias !26
  %102 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %103 = load ptr, ptr %102, align 8, !noalias !26
  call void @llvm.memset.inline.p0.i64(ptr %22, i8 0, i64 16, i1 false), !noalias !26
  %104 = call i8 %101(ptr %103, i8 1, i64 0, i64 0, ptr %0, i64 %1, ptr %5, ptr %22, ptr nonnull %__.context_ptr), !noalias !21
  store i8 %104, ptr %err.i, align 1, !noalias !26
  br label %if.done22.i

if.done22.i:                                      ; preds = %if.done21.i, %if.done10.i
  %105 = load { ptr, i64 }, ptr %data.i, align 8, !noalias !26
  %106 = load i8, ptr %err.i, align 1, !noalias !26
  store { ptr, i64 } %105, ptr %data.i, align 8, !noalias !26
  store i8 %106, ptr %err.i, align 1, !noalias !26
  store { ptr, i64 } %105, ptr %29, align 8, !alias.scope !21, !noalias !24
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

"runtime::_mem_resize.exit":                      ; preds = %if.done22.i, %if.then20.i, %if.then9.i, %if.then4.i, %if.done3.i, %if.then2.i, %if.then.i2
  %107 = phi i8 [ 0, %if.then.i2 ], [ %59, %if.then2.i ], [ %61, %if.done3.i ], [ %67, %if.then4.i ], [ %79, %if.then9.i ], [ %97, %if.then20.i ], [ %106, %if.done22.i ]
  %108 = load { ptr, i64 }, ptr %29, align 8
  store { ptr, i64 } %108, ptr %data, align 8
  store i8 %107, ptr %err, align 1
  store { ptr, i64 } %108, ptr %6, align 8
  ret i8 %107
}

; Function Attrs: alwaysinline
define void @"runtime::make_slice_error_loc"(ptr %0, i64 %1) #1 {
decls:
  %2 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %1, ptr %2, align 8
  %3 = icmp sle i64 0, %1
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  call void @"runtime::make_slice_error_loc.handle_error-0"(ptr %0, i64 %1)
  unreachable
}

define i8 @"runtime::non_zero_mem_resize"(ptr %0, i64 %1, i64 %2, i64 %3, ptr %4, ptr %5, ptr noalias nonnull %6, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %7 = alloca i64, align 8
  %8 = alloca ptr, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca %"runtime::Allocator", align 8
  %13 = alloca i8, align 1
  %data.i = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { ptr, i64 }, align 8
  %16 = alloca ptr, align 8
  %17 = alloca { ptr, i64 }, align 8
  %18 = alloca { ptr, i64 }, align 8
  %19 = alloca { ptr, i64 }, align 8
  %20 = alloca ptr, align 8
  %21 = alloca { ptr, i64 }, align 8
  %22 = alloca { ptr, i64 }, align 8
  %23 = alloca i64, align 8
  %24 = alloca ptr, align 8
  %25 = alloca i64, align 8
  %26 = alloca i64, align 8
  %27 = alloca i64, align 8
  %28 = alloca %"runtime::Allocator", align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %29 = alloca { ptr, i64 }, align 8
  %30 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %24, align 8
  store i64 %1, ptr %25, align 8
  store i64 %2, ptr %26, align 8
  store i64 %3, ptr %27, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %28, ptr %4, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  call void @llvm.lifetime.start.p0(i64 8, ptr %23)
  store i64 %3, ptr %23, align 8
  %31 = icmp sle i64 %3, 0
  %32 = zext i1 %31 to i8
  br i1 %31, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %23)
  br label %"runtime::is_power_of_two_int.exit"

if.done.i:                                        ; preds = %entry
  %33 = sub i64 %3, 1
  %34 = and i64 %3, %33
  %35 = icmp eq i64 %34, 0
  %36 = zext i1 %35 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %23)
  br label %"runtime::is_power_of_two_int.exit"

"runtime::is_power_of_two_int.exit":              ; preds = %if.done.i, %if.then.i
  %37 = phi i8 [ 0, %if.then.i ], [ %36, %if.done.i ]
  %38 = icmp ne i8 %37, 0
  call void @"runtime::assert"(i1 zeroext %38, ptr @"ggv$runtime::non_zero_mem_resize$1", ptr %5, ptr %__.context_ptr)
  call void @llvm.memset.inline.p0.i64(ptr %29, i8 0, i64 16, i1 false)
  call void @llvm.experimental.noalias.scope.decl(metadata !27)
  call void @llvm.experimental.noalias.scope.decl(metadata !30)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 16, ptr %12)
  call void @llvm.lifetime.start.p0(i64 1, ptr %13)
  call void @llvm.lifetime.start.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %14)
  call void @llvm.lifetime.start.p0(i64 16, ptr %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr %16)
  call void @llvm.lifetime.start.p0(i64 16, ptr %17)
  call void @llvm.lifetime.start.p0(i64 16, ptr %18)
  call void @llvm.lifetime.start.p0(i64 16, ptr %19)
  call void @llvm.lifetime.start.p0(i64 8, ptr %20)
  call void @llvm.lifetime.start.p0(i64 16, ptr %21)
  call void @llvm.lifetime.start.p0(i64 16, ptr %22)
  store ptr %0, ptr %8, align 8, !noalias !32
  store i64 %1, ptr %9, align 8, !noalias !32
  store i64 %2, ptr %10, align 8, !noalias !32
  store i64 %3, ptr %11, align 8, !noalias !32
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %12, ptr %28, i64 16, i1 false), !noalias !32
  store i8 0, ptr %13, align 1, !noalias !32
  call void @llvm.memset.inline.p0.i64(ptr %data.i, i8 0, i64 16, i1 false), !noalias !32
  store i8 0, ptr %err.i, align 1, !noalias !32
  call void @llvm.lifetime.start.p0(i64 8, ptr %7), !noalias !32
  store i64 %3, ptr %7, align 8, !noalias !32
  %39 = icmp sle i64 %3, 0
  %40 = zext i1 %39 to i8
  br i1 %39, label %if.then.i.i, label %if.done.i.i

if.then.i.i:                                      ; preds = %"runtime::is_power_of_two_int.exit"
  call void @llvm.lifetime.end.p0(i64 8, ptr %7), !noalias !32
  br label %"runtime::is_power_of_two_int.exit.i"

if.done.i.i:                                      ; preds = %"runtime::is_power_of_two_int.exit"
  %41 = sub i64 %3, 1
  %42 = and i64 %3, %41
  %43 = icmp eq i64 %42, 0
  %44 = zext i1 %43 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %7), !noalias !32
  br label %"runtime::is_power_of_two_int.exit.i"

"runtime::is_power_of_two_int.exit.i":            ; preds = %if.done.i.i, %if.then.i.i
  %45 = phi i8 [ 0, %if.then.i.i ], [ %44, %if.done.i.i ]
  %46 = icmp ne i8 %45, 0
  call void @"runtime::assert"(i1 zeroext %46, ptr @"ggv$runtime::_mem_resize$1", ptr %5, ptr nonnull %__.context_ptr), !noalias !27
  %47 = load ptr, ptr %12, align 8, !noalias !32
  %48 = icmp eq ptr %47, null
  %49 = zext i1 %48 to i8
  br i1 %48, label %if.then.i2, label %if.done.i1

if.then.i2:                                       ; preds = %"runtime::is_power_of_two_int.exit.i"
  store { ptr, i64 } zeroinitializer, ptr %data.i, align 8, !noalias !32
  store i8 0, ptr %err.i, align 1, !noalias !32
  store { ptr, i64 } zeroinitializer, ptr %29, align 8, !alias.scope !27, !noalias !30
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

if.done.i1:                                       ; preds = %"runtime::is_power_of_two_int.exit.i"
  %50 = icmp eq i64 %2, 0
  %51 = zext i1 %50 to i8
  br i1 %50, label %if.then1.i, label %if.else.i

if.then1.i:                                       ; preds = %if.done.i1
  %52 = icmp ne ptr %0, null
  %53 = zext i1 %52 to i8
  br i1 %52, label %if.then2.i, label %if.done3.i

if.then2.i:                                       ; preds = %if.then1.i
  %54 = load ptr, ptr %12, align 8, !noalias !32
  %55 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %56 = load ptr, ptr %55, align 8, !noalias !32
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false), !noalias !32
  %57 = call i8 %54(ptr %56, i8 1, i64 0, i64 0, ptr %0, i64 %1, ptr %5, ptr %14, ptr nonnull %__.context_ptr), !noalias !27
  store i8 %57, ptr %err.i, align 1, !noalias !32
  %58 = load { ptr, i64 }, ptr %data.i, align 8, !noalias !32
  %59 = load i8, ptr %err.i, align 1, !noalias !32
  store { ptr, i64 } %58, ptr %data.i, align 8, !noalias !32
  store i8 %59, ptr %err.i, align 1, !noalias !32
  store { ptr, i64 } %58, ptr %29, align 8, !alias.scope !27, !noalias !30
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

if.done3.i:                                       ; preds = %if.then1.i
  %60 = load { ptr, i64 }, ptr %data.i, align 8, !noalias !32
  %61 = load i8, ptr %err.i, align 1, !noalias !32
  store { ptr, i64 } %60, ptr %data.i, align 8, !noalias !32
  store i8 %61, ptr %err.i, align 1, !noalias !32
  store { ptr, i64 } %60, ptr %29, align 8, !alias.scope !27, !noalias !30
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

if.else.i:                                        ; preds = %if.done.i1
  %62 = icmp eq ptr %0, null
  %63 = zext i1 %62 to i8
  br i1 %62, label %if.then4.i, label %if.else8.i

if.then4.i:                                       ; preds = %if.else.i
  %64 = load ptr, ptr %12, align 8, !noalias !32
  %65 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %66 = load ptr, ptr %65, align 8, !noalias !32
  call void @llvm.memset.inline.p0.i64(ptr %15, i8 0, i64 16, i1 false), !noalias !32
  %67 = call i8 %64(ptr %66, i8 6, i64 %2, i64 %3, ptr null, i64 0, ptr %5, ptr %15, ptr nonnull %__.context_ptr), !noalias !27
  %68 = load { ptr, i64 }, ptr %15, align 8, !noalias !32
  store { ptr, i64 } %68, ptr %data.i, align 8, !noalias !32
  store i8 %67, ptr %err.i, align 1, !noalias !32
  store { ptr, i64 } %68, ptr %29, align 8, !alias.scope !27, !noalias !30
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

if.else8.i:                                       ; preds = %if.else.i
  %69 = icmp eq i64 %1, %2
  %70 = zext i1 %69 to i8
  br i1 %69, label %cmp.and.i, label %if.done10.i

cmp.and.i:                                        ; preds = %if.else8.i
  %71 = ptrtoint ptr %0 to i64
  %72 = urem i64 %71, %3
  %73 = icmp eq i64 %72, 0
  %74 = zext i1 %73 to i8
  br i1 %73, label %if.then9.i, label %if.done10.i

if.then9.i:                                       ; preds = %cmp.and.i
  store ptr %0, ptr %16, align 8, !noalias !32
  %75 = load ptr, ptr %16, align 8, !noalias !32
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::_mem_resize$2", i32 200, i32 24, i64 0, i64 %1), !noalias !32
  %76 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 1
  store ptr %75, ptr %17, align 8, !noalias !32
  store i64 %1, ptr %76, align 8, !noalias !32
  %77 = load { ptr, i64 }, ptr %17, align 8, !noalias !32
  store { ptr, i64 } %77, ptr %data.i, align 8, !noalias !32
  %78 = load { ptr, i64 }, ptr %data.i, align 8, !noalias !32
  %79 = load i8, ptr %err.i, align 1, !noalias !32
  store { ptr, i64 } %78, ptr %data.i, align 8, !noalias !32
  store i8 %79, ptr %err.i, align 1, !noalias !32
  store { ptr, i64 } %78, ptr %29, align 8, !alias.scope !27, !noalias !30
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

if.done10.i:                                      ; preds = %cmp.and.i, %if.else8.i
  %80 = load ptr, ptr %12, align 8, !noalias !32
  %81 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %82 = load ptr, ptr %81, align 8, !noalias !32
  call void @llvm.memset.inline.p0.i64(ptr %18, i8 0, i64 16, i1 false), !noalias !32
  %83 = call i8 %80(ptr %82, i8 7, i64 %2, i64 %3, ptr %0, i64 %1, ptr %5, ptr %18, ptr nonnull %__.context_ptr), !noalias !27
  %84 = load { ptr, i64 }, ptr %18, align 8, !noalias !32
  store { ptr, i64 } %84, ptr %data.i, align 8, !noalias !32
  store i8 %83, ptr %err.i, align 1, !noalias !32
  %85 = load i8, ptr %err.i, align 1, !noalias !32
  %86 = icmp eq i8 %85, 4
  %87 = zext i1 %86 to i8
  br i1 %86, label %if.then16.i, label %if.done22.i

if.then16.i:                                      ; preds = %if.done10.i
  %88 = load ptr, ptr %12, align 8, !noalias !32
  %89 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %90 = load ptr, ptr %89, align 8, !noalias !32
  call void @llvm.memset.inline.p0.i64(ptr %19, i8 0, i64 16, i1 false), !noalias !32
  %91 = call i8 %88(ptr %90, i8 6, i64 %2, i64 %3, ptr null, i64 0, ptr %5, ptr %19, ptr nonnull %__.context_ptr), !noalias !27
  %92 = load { ptr, i64 }, ptr %19, align 8, !noalias !32
  store { ptr, i64 } %92, ptr %data.i, align 8, !noalias !32
  store i8 %91, ptr %err.i, align 1, !noalias !32
  %93 = load i8, ptr %err.i, align 1, !noalias !32
  %94 = icmp ne i8 %93, 0
  %95 = zext i1 %94 to i8
  br i1 %94, label %if.then20.i, label %if.done21.i

if.then20.i:                                      ; preds = %if.then16.i
  %96 = load { ptr, i64 }, ptr %data.i, align 8, !noalias !32
  %97 = load i8, ptr %err.i, align 1, !noalias !32
  store { ptr, i64 } %96, ptr %data.i, align 8, !noalias !32
  store i8 %97, ptr %err.i, align 1, !noalias !32
  store { ptr, i64 } %96, ptr %29, align 8, !alias.scope !27, !noalias !30
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

if.done21.i:                                      ; preds = %if.then16.i
  store ptr %0, ptr %20, align 8, !noalias !32
  %98 = load ptr, ptr %20, align 8, !noalias !32
  call void @"runtime::multi_pointer_slice_expr_error"(ptr @"ggv$runtime::_mem_resize$3", i32 218, i32 28, i64 0, i64 %1), !noalias !27
  %99 = getelementptr inbounds nuw { ptr, i64 }, ptr %21, i32 0, i32 1
  store ptr %98, ptr %21, align 8, !noalias !32
  store i64 %1, ptr %99, align 8, !noalias !32
  %100 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"(ptr %data.i, ptr %21), !noalias !27
  %101 = load ptr, ptr %12, align 8, !noalias !32
  %102 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %103 = load ptr, ptr %102, align 8, !noalias !32
  call void @llvm.memset.inline.p0.i64(ptr %22, i8 0, i64 16, i1 false), !noalias !32
  %104 = call i8 %101(ptr %103, i8 1, i64 0, i64 0, ptr %0, i64 %1, ptr %5, ptr %22, ptr nonnull %__.context_ptr), !noalias !27
  store i8 %104, ptr %err.i, align 1, !noalias !32
  br label %if.done22.i

if.done22.i:                                      ; preds = %if.done21.i, %if.done10.i
  %105 = load { ptr, i64 }, ptr %data.i, align 8, !noalias !32
  %106 = load i8, ptr %err.i, align 1, !noalias !32
  store { ptr, i64 } %105, ptr %data.i, align 8, !noalias !32
  store i8 %106, ptr %err.i, align 1, !noalias !32
  store { ptr, i64 } %105, ptr %29, align 8, !alias.scope !27, !noalias !30
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  call void @llvm.lifetime.end.p0(i64 16, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %21)
  call void @llvm.lifetime.end.p0(i64 16, ptr %22)
  br label %"runtime::_mem_resize.exit"

"runtime::_mem_resize.exit":                      ; preds = %if.done22.i, %if.then20.i, %if.then9.i, %if.then4.i, %if.done3.i, %if.then2.i, %if.then.i2
  %107 = phi i8 [ 0, %if.then.i2 ], [ %59, %if.then2.i ], [ %61, %if.done3.i ], [ %67, %if.then4.i ], [ %79, %if.then9.i ], [ %97, %if.then20.i ], [ %106, %if.done22.i ]
  %108 = load { ptr, i64 }, ptr %29, align 8
  store { ptr, i64 } %108, ptr %data, align 8
  store i8 %107, ptr %err, align 1
  store { ptr, i64 } %108, ptr %6, align 8
  ret i8 %107
}

; Function Attrs: alwaysinline
define void @"runtime::make_dynamic_array_error_loc"(ptr %0, i64 %1, i64 %2) #1 {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %1, ptr %3, align 8
  store i64 %2, ptr %4, align 8
  %5 = icmp sle i64 0, %1
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %8 = icmp sle i64 %1, %2
  %9 = zext i1 %8 to i8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  ret void

if.done:                                          ; preds = %cmp.and, %entry
  call void @"runtime::make_dynamic_array_error_loc.handle_error-0"(ptr %0, i64 %1, i64 %2)
  unreachable
}

define i8 @"runtime::memory_equal"(ptr %0, ptr %1, i64 %2) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %a = alloca ptr, align 8
  %b = alloca ptr, align 8
  %n = alloca i64, align 8
  %i = alloca i64, align 8
  %m = alloca i64, align 8
  %load_a = alloca <16 x i8>, align 16
  %load_b = alloca <16 x i8>, align 16
  %ne = alloca <16 x i8>, align 16
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store ptr %1, ptr %4, align 8
  store i64 %2, ptr %5, align 8
  %8 = icmp eq i64 %2, 0
  %9 = zext i1 %8 to i8
  %10 = icmp eq i8 1, %9
  br i1 %10, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %entry
  %11 = icmp eq ptr %0, %1
  %12 = zext i1 %11 to i8
  %13 = icmp eq i8 1, %12
  br i1 %13, label %switch.case.body2, label %switch.case.next1

switch.case.body:                                 ; preds = %entry
  ret i8 1

switch.case.next1:                                ; preds = %switch.case.next
  br label %switch.done

switch.case.body2:                                ; preds = %switch.case.next
  ret i8 1

switch.done:                                      ; preds = %switch.case.next1
  store ptr %0, ptr %a, align 8
  store ptr %1, ptr %b, align 8
  store i64 %2, ptr %n, align 8
  store i64 0, ptr %i, align 8
  store i64 0, ptr %m, align 8
  %14 = load i64, ptr %n, align 8
  %15 = icmp uge i64 %14, 8
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %if.then, label %if.done10

if.then:                                          ; preds = %switch.done
  %18 = load i64, ptr %n, align 8
  %19 = load i64, ptr %i, align 8
  %20 = sub i64 %18, %19
  %21 = udiv i64 %20, 16
  %22 = mul i64 %21, 16
  store i64 %22, ptr %m, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %if.then
  %23 = load i64, ptr %i, align 8
  %24 = load i64, ptr %m, align 8
  %25 = icmp ult i64 %23, %24
  %26 = zext i1 %25 to i8
  %27 = icmp ne i8 %26, 0
  br i1 %27, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %28 = load ptr, ptr %a, align 8
  %29 = load i64, ptr %i, align 8
  %30 = getelementptr i8, ptr %28, i64 %29
  %31 = load <16 x i8>, ptr %30, align 1
  store <16 x i8> %31, ptr %load_a, align 16
  %32 = load ptr, ptr %b, align 8
  %33 = load i64, ptr %i, align 8
  %34 = getelementptr i8, ptr %32, i64 %33
  %35 = load <16 x i8>, ptr %34, align 1
  store <16 x i8> %35, ptr %load_b, align 16
  %36 = load <16 x i8>, ptr %load_a, align 16
  %37 = load <16 x i8>, ptr %load_b, align 16
  %38 = icmp ne <16 x i8> %36, %37
  %39 = sext <16 x i1> %38 to <16 x i8>
  store <16 x i8> %39, ptr %ne, align 16
  %40 = load <16 x i8>, ptr %ne, align 16
  %41 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %40)
  %42 = icmp ne i8 %41, 0
  %43 = zext i1 %42 to i8
  %44 = icmp ne i8 %43, 0
  br i1 %44, label %if.then3, label %if.done

if.then3:                                         ; preds = %for.body
  ret i8 0

if.done:                                          ; preds = %for.body
  br label %for.post

for.post:                                         ; preds = %if.done
  %45 = load i64, ptr %i, align 8
  %46 = add i64 %45, 16
  store i64 %46, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %47 = load i64, ptr %n, align 8
  %48 = load i64, ptr %i, align 8
  %49 = sub i64 %47, %48
  %50 = udiv i64 %49, 8
  %51 = mul i64 %50, 8
  store i64 %51, ptr %m, align 8
  br label %for.loop4

for.loop4:                                        ; preds = %for.post8, %for.done
  %52 = load i64, ptr %i, align 8
  %53 = load i64, ptr %m, align 8
  %54 = icmp ult i64 %52, %53
  %55 = zext i1 %54 to i8
  %56 = icmp ne i8 %55, 0
  br i1 %56, label %for.body5, label %for.done9

for.body5:                                        ; preds = %for.loop4
  %57 = load ptr, ptr %a, align 8
  %58 = load i64, ptr %i, align 8
  %59 = getelementptr i8, ptr %57, i64 %58
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %6, ptr %59, i64 8, i1 false)
  %60 = load i64, ptr %6, align 8
  %61 = load ptr, ptr %b, align 8
  %62 = load i64, ptr %i, align 8
  %63 = getelementptr i8, ptr %61, i64 %62
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %63, i64 8, i1 false)
  %64 = load i64, ptr %7, align 8
  %65 = icmp ne i64 %60, %64
  %66 = zext i1 %65 to i8
  %67 = icmp ne i8 %66, 0
  br i1 %67, label %if.then6, label %if.done7

if.then6:                                         ; preds = %for.body5
  ret i8 0

if.done7:                                         ; preds = %for.body5
  br label %for.post8

for.post8:                                        ; preds = %if.done7
  %68 = load i64, ptr %i, align 8
  %69 = add i64 %68, 8
  store i64 %69, ptr %i, align 8
  br label %for.loop4

for.done9:                                        ; preds = %for.loop4
  br label %if.done10

if.done10:                                        ; preds = %for.done9, %switch.done
  br label %for.loop11

for.loop11:                                       ; preds = %for.post15, %if.done10
  %70 = load i64, ptr %i, align 8
  %71 = load i64, ptr %n, align 8
  %72 = icmp ult i64 %70, %71
  %73 = zext i1 %72 to i8
  %74 = icmp ne i8 %73, 0
  br i1 %74, label %for.body12, label %for.done16

for.body12:                                       ; preds = %for.loop11
  %75 = load ptr, ptr %a, align 8
  %76 = load i64, ptr %i, align 8
  %77 = getelementptr i8, ptr %75, i64 %76
  %78 = load i8, ptr %77, align 1
  %79 = load ptr, ptr %b, align 8
  %80 = load i64, ptr %i, align 8
  %81 = getelementptr i8, ptr %79, i64 %80
  %82 = load i8, ptr %81, align 1
  %83 = icmp ne i8 %78, %82
  %84 = zext i1 %83 to i8
  %85 = icmp ne i8 %84, 0
  br i1 %85, label %if.then13, label %if.done14

if.then13:                                        ; preds = %for.body12
  ret i8 0

if.done14:                                        ; preds = %for.body12
  br label %for.post15

for.post15:                                       ; preds = %if.done14
  %86 = load i64, ptr %i, align 8
  %87 = add i64 %86, 1
  store i64 %87, ptr %i, align 8
  br label %for.loop11

for.done16:                                       ; preds = %for.loop11
  ret i8 1
}

define i8 @"runtime::delete_string"(ptr %0, ptr %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 8
  %6 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  %7 = alloca %..string, align 8
  %8 = alloca %"runtime::Allocator", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %8, ptr %1, i64 16, i1 false)
  %9 = getelementptr inbounds nuw %..string, ptr %7, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr inbounds nuw %..string, ptr %7, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !33)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 16, ptr %5)
  call void @llvm.lifetime.start.p0(i64 16, ptr %6)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %10, ptr %3, align 8, !noalias !33
  store i64 %12, ptr %4, align 8, !noalias !33
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %8, i64 16, i1 false), !noalias !33
  %13 = icmp eq ptr %10, null
  %14 = zext i1 %13 to i8
  br i1 %13, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %entry
  %15 = load ptr, ptr %5, align 8, !noalias !33
  %16 = icmp eq ptr %15, null
  %17 = zext i1 %16 to i8
  br i1 %16, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 16, ptr %6)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %18 = load ptr, ptr %5, align 8, !noalias !33
  %19 = getelementptr inbounds nuw %"runtime::Allocator", ptr %5, i32 0, i32 1
  %20 = load ptr, ptr %19, align 8, !noalias !33
  call void @llvm.memset.inline.p0.i64(ptr %6, i8 0, i64 16, i1 false), !noalias !33
  %21 = call i8 %18(ptr %20, i8 1, i64 0, i64 0, ptr %10, i64 %12, ptr %2, ptr %6, ptr nonnull %__.context_ptr)
  store i8 %21, ptr %err.i, align 1, !noalias !33
  %22 = load i8, ptr %err.i, align 1, !noalias !33
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 16, ptr %6)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

"runtime::mem_free_with_size.exit":               ; preds = %if.done.i, %if.then.i
  %23 = phi i8 [ 0, %if.then.i ], [ %22, %if.done.i ]
  ret i8 %23
}

define void @"runtime::arena_temp_begin"(ptr noalias sret(%"runtime::Arena_Temp") %agg.result, ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %temp = alloca %"runtime::Arena_Temp", align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  call void @llvm.memset.inline.p0.i64(ptr %temp, i8 0, i64 24, i1 false)
  %3 = icmp ne ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  call void @"runtime::assert"(i1 zeroext %5, ptr @"ggv$runtime::arena_temp_begin$1", ptr %1, ptr %__.context_ptr)
  %6 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %temp, i32 0, i32 0
  store ptr %0, ptr %6, align 8
  %7 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %temp, i32 0, i32 1
  %8 = load ptr, ptr %2, align 8
  %9 = getelementptr inbounds nuw %"runtime::Arena", ptr %8, i32 0, i32 1
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %7, align 8
  %11 = load ptr, ptr %2, align 8
  %12 = getelementptr inbounds nuw %"runtime::Arena", ptr %11, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  %14 = icmp ne ptr %13, null
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %17 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %temp, i32 0, i32 2
  %18 = load ptr, ptr %2, align 8
  %19 = getelementptr inbounds nuw %"runtime::Arena", ptr %18, i32 0, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %20, i32 0, i32 3
  %22 = load i64, ptr %21, align 8
  store i64 %22, ptr %17, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %23 = load ptr, ptr %2, align 8
  %24 = getelementptr inbounds nuw %"runtime::Arena", ptr %23, i32 0, i32 5
  %25 = load i64, ptr %24, align 8
  %26 = add i64 %25, 1
  store i64 %26, ptr %24, align 8
  %27 = load %"runtime::Arena_Temp", ptr %temp, align 8
  store %"runtime::Arena_Temp" %27, ptr %temp, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %agg.result, ptr %temp, i64 24, i1 false)
  ret void
}

define void @"runtime::arena_temp_end"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %arena = alloca ptr, align 8
  %memory_block_found = alloca i8, align 1
  %block = alloca ptr, align 8
  %block9 = alloca ptr, align 8
  %amount_to_zero = alloca i64, align 8
  %2 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  %3 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 0
  %4 = load ptr, ptr %3, align 8
  %5 = icmp eq ptr %4, null
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %8 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 1
  %9 = load ptr, ptr %8, align 8
  %10 = icmp eq ptr %9, null
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  call void @"runtime::assert"(i1 zeroext %12, ptr @"ggv$runtime::arena_temp_end$1", ptr @"scl$[arena_temp_end8667]", ptr %__.context_ptr)
  %13 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 2
  %14 = load i64, ptr %13, align 8
  %15 = icmp eq i64 %14, 0
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  call void @"runtime::assert"(i1 zeroext %17, ptr @"ggv$runtime::arena_temp_end$2", ptr @"scl$[arena_temp_end8696]", ptr %__.context_ptr)
  ret void

if.done:                                          ; preds = %entry
  %18 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 0
  %19 = load ptr, ptr %18, align 8
  store ptr %19, ptr %arena, align 8
  %20 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 1
  %21 = load ptr, ptr %20, align 8
  %22 = icmp ne ptr %21, null
  %23 = zext i1 %22 to i8
  %24 = icmp ne i8 %23, 0
  br i1 %24, label %if.then1, label %if.done12

if.then1:                                         ; preds = %if.done
  store i8 0, ptr %memory_block_found, align 1
  br label %for.init

for.init:                                         ; preds = %if.then1
  %25 = load ptr, ptr %arena, align 8
  %26 = getelementptr inbounds nuw %"runtime::Arena", ptr %25, i32 0, i32 1
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %block, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %28 = load ptr, ptr %block, align 8
  %29 = icmp ne ptr %28, null
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %32 = load ptr, ptr %block, align 8
  %33 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = icmp eq ptr %32, %34
  %36 = zext i1 %35 to i8
  %37 = icmp ne i8 %36, 0
  br i1 %37, label %if.then2, label %if.done3

if.then2:                                         ; preds = %for.body
  store i8 1, ptr %memory_block_found, align 1
  br label %for.done

unreachable:                                      ; No predecessors!
  br label %if.done3

if.done3:                                         ; preds = %unreachable, %for.body
  br label %for.post

for.post:                                         ; preds = %if.done3
  %38 = load ptr, ptr %block, align 8
  %39 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %38, i32 0, i32 0
  %40 = load ptr, ptr %39, align 8
  store ptr %40, ptr %block, align 8
  br label %for.loop

for.done:                                         ; preds = %if.then2, %for.loop
  %41 = load i8, ptr %memory_block_found, align 1
  %42 = icmp ne i8 %41, 0
  br i1 %42, label %if.done5, label %if.then4

if.then4:                                         ; preds = %for.done
  %43 = load ptr, ptr %arena, align 8
  %44 = getelementptr inbounds nuw %"runtime::Arena", ptr %43, i32 0, i32 1
  %45 = load ptr, ptr %44, align 8
  %46 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = icmp eq ptr %45, %47
  %49 = zext i1 %48 to i8
  %50 = icmp ne i8 %49, 0
  call void @"runtime::assert"(i1 zeroext %50, ptr @"ggv$runtime::arena_temp_end$3", ptr %1, ptr %__.context_ptr)
  br label %if.done5

if.done5:                                         ; preds = %if.then4, %for.done
  br label %for.loop6

for.loop6:                                        ; preds = %for.body7, %if.done5
  %51 = load ptr, ptr %arena, align 8
  %52 = getelementptr inbounds nuw %"runtime::Arena", ptr %51, i32 0, i32 1
  %53 = load ptr, ptr %52, align 8
  %54 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 1
  %55 = load ptr, ptr %54, align 8
  %56 = icmp ne ptr %53, %55
  %57 = zext i1 %56 to i8
  %58 = icmp ne i8 %57, 0
  br i1 %58, label %for.body7, label %for.done8

for.body7:                                        ; preds = %for.loop6
  %59 = load ptr, ptr %arena, align 8
  call void @"runtime::arena_free_last_memory_block"(ptr %59, ptr @"scl$[arena_temp_end9151]", ptr %__.context_ptr)
  br label %for.loop6

for.done8:                                        ; preds = %for.loop6
  br label %if.init

if.init:                                          ; preds = %for.done8
  %60 = load ptr, ptr %arena, align 8
  %61 = getelementptr inbounds nuw %"runtime::Arena", ptr %60, i32 0, i32 1
  %62 = load ptr, ptr %61, align 8
  store ptr %62, ptr %block9, align 8
  %63 = load ptr, ptr %block9, align 8
  %64 = icmp ne ptr %63, null
  %65 = zext i1 %64 to i8
  %66 = icmp ne i8 %65, 0
  br i1 %66, label %if.then10, label %if.done11

if.then10:                                        ; preds = %if.init
  %67 = load ptr, ptr %block9, align 8
  %68 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %67, i32 0, i32 3
  %69 = load i64, ptr %68, align 8
  %70 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 2
  %71 = load i64, ptr %70, align 8
  %72 = icmp uge i64 %69, %71
  %73 = zext i1 %72 to i8
  %74 = icmp ne i8 %73, 0
  call void @"runtime::assert"(i1 zeroext %74, ptr @"ggv$runtime::arena_temp_end$4", ptr %1, ptr %__.context_ptr)
  %75 = load ptr, ptr %block9, align 8
  %76 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %75, i32 0, i32 3
  %77 = load i64, ptr %76, align 8
  %78 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 2
  %79 = load i64, ptr %78, align 8
  %80 = sub i64 %77, %79
  store i64 %80, ptr %amount_to_zero, align 8
  %81 = load ptr, ptr %block9, align 8
  %82 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %81, i32 0, i32 2
  %83 = load ptr, ptr %82, align 8
  %84 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 2
  %85 = load i64, ptr %84, align 8
  %86 = getelementptr i8, ptr %83, i64 %85
  store ptr %86, ptr %2, align 8
  %87 = load ptr, ptr %2, align 8
  %88 = load i64, ptr %amount_to_zero, align 8
  call void @llvm.memset.p0.i64(ptr %87, i8 0, i64 %88, i1 false)
  %89 = load ptr, ptr %block9, align 8
  %90 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %89, i32 0, i32 3
  %91 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 2
  %92 = load i64, ptr %91, align 8
  store i64 %92, ptr %90, align 8
  %93 = load ptr, ptr %arena, align 8
  %94 = getelementptr inbounds nuw %"runtime::Arena", ptr %93, i32 0, i32 2
  %95 = load i64, ptr %amount_to_zero, align 8
  %96 = load i64, ptr %94, align 8
  %97 = sub i64 %96, %95
  store i64 %97, ptr %94, align 8
  br label %if.done11

if.done11:                                        ; preds = %if.then10, %if.init
  br label %if.done12

if.done12:                                        ; preds = %if.done11, %if.done
  %98 = load ptr, ptr %arena, align 8
  %99 = getelementptr inbounds nuw %"runtime::Arena", ptr %98, i32 0, i32 5
  %100 = load i64, ptr %99, align 8
  %101 = icmp ugt i64 %100, 0
  %102 = zext i1 %101 to i8
  %103 = icmp ne i8 %102, 0
  call void @"runtime::assert"(i1 zeroext %103, ptr @"ggv$runtime::arena_temp_end$5", ptr %1, ptr %__.context_ptr)
  %104 = load ptr, ptr %arena, align 8
  %105 = getelementptr inbounds nuw %"runtime::Arena", ptr %104, i32 0, i32 5
  %106 = load i64, ptr %105, align 8
  %107 = sub i64 %106, 1
  store i64 %107, ptr %105, align 8
  ret void
}

; Function Attrs: alwaysinline
define void @"runtime::bounds_check_error_loc"(ptr %0, i64 %1, i64 %2) #1 {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %1, ptr %3, align 8
  store i64 %2, ptr %4, align 8
  %5 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %0, i32 0, i32 0
  %6 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %0, i32 0, i32 1
  %7 = load i32, ptr %6, align 4
  %8 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %0, i32 0, i32 2
  %9 = load i32, ptr %8, align 4
  call void @"runtime::bounds_check_error"(ptr %5, i32 %7, i32 %9, i64 %1, i64 %2)
  ret void
}

; Function Attrs: alwaysinline
define i64 @"runtime::map_cap"(ptr %0) #1 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %1 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %0, i32 0, i32 0
  %2 = load i64, ptr %1, align 8
  %3 = icmp eq i64 %2, 0
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.done

if.else:                                          ; preds = %entry
  %6 = load i64, ptr %0, align 8
  %7 = and i64 %6, 63
  %8 = icmp ult i64 %7, 64
  %9 = shl i64 1, %7
  %10 = select i1 %8, i64 %9, i64 0
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  %11 = phi i64 [ 0, %if.then ], [ %10, %if.else ]
  ret i64 %11
}

define i8 @"runtime::delete_cstring"(ptr %0, ptr %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca %"runtime::Allocator", align 8
  %5 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  %6 = alloca ptr, align 8
  %7 = alloca %"runtime::Allocator", align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %6, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %1, i64 16, i1 false)
  call void @llvm.experimental.noalias.scope.decl(metadata !36)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 16, ptr %4)
  call void @llvm.lifetime.start.p0(i64 16, ptr %5)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %0, ptr %3, align 8, !noalias !36
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %7, i64 16, i1 false), !noalias !36
  %8 = icmp eq ptr %0, null
  %9 = zext i1 %8 to i8
  br i1 %8, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %entry
  %10 = load ptr, ptr %4, align 8, !noalias !36
  %11 = icmp eq ptr %10, null
  %12 = zext i1 %11 to i8
  br i1 %11, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %13 = load ptr, ptr %4, align 8, !noalias !36
  %14 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 1
  %15 = load ptr, ptr %14, align 8, !noalias !36
  call void @llvm.memset.inline.p0.i64(ptr %5, i8 0, i64 16, i1 false), !noalias !36
  %16 = call i8 %13(ptr %15, i8 1, i64 0, i64 0, ptr %0, i64 0, ptr %2, ptr %5, ptr nonnull %__.context_ptr)
  store i8 %16, ptr %err.i, align 1, !noalias !36
  %17 = load i8, ptr %err.i, align 1, !noalias !36
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free.exit"

"runtime::mem_free.exit":                         ; preds = %if.done.i, %if.then.i
  %18 = phi i8 [ 0, %if.then.i ], [ %17, %if.done.i ]
  ret i8 %18
}

define i8 @"runtime::make_slice:proc(T:$[]string,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[]string,:runtime::Allocator_Error)"(i64 %0, ptr %1, ptr %2, ptr noalias nonnull %3, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 8
  %6 = alloca { ptr, i64 }, align 8
  %7 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %1, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %6, i8 0, i64 16, i1 false)
  %8 = call i8 @"runtime::make_aligned:proc(T:$[]string,len:int,alignment:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[]string,:runtime::Allocator_Error)"(i64 %0, i64 8, ptr %5, ptr %2, ptr %6, ptr %__.context_ptr)
  %9 = load { ptr, i64 }, ptr %6, align 8
  store { ptr, i64 } %9, ptr %3, align 8
  ret i8 %8
}

define i64 @"runtime::memory_compare"(ptr %0, ptr %1, i64 %2) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %a = alloca ptr, align 8
  %b = alloca ptr, align 8
  %n = alloca i64, align 8
  %i = alloca i64, align 8
  %m = alloca i64, align 8
  %load_a = alloca <16 x i8>, align 16
  %load_b = alloca <16 x i8>, align 16
  %comparison = alloca <16 x i8>, align 16
  %sentinel = alloca <16 x i8>, align 16
  %indices = alloca <16 x i8>, align 16
  %index_select = alloca <16 x i8>, align 16
  %index_reduce = alloca i64, align 8
  %load_a9 = alloca <8 x i8>, align 8
  %load_b10 = alloca <8 x i8>, align 8
  %comparison11 = alloca <8 x i8>, align 8
  %sentinel13 = alloca <8 x i8>, align 8
  %indices14 = alloca <8 x i8>, align 8
  %index_select15 = alloca <8 x i8>, align 8
  %index_reduce16 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store ptr %1, ptr %4, align 8
  store i64 %2, ptr %5, align 8
  %6 = icmp eq ptr %0, %1
  %7 = zext i1 %6 to i8
  %8 = icmp eq i8 1, %7
  br i1 %8, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %entry
  %9 = icmp eq ptr %0, null
  %10 = zext i1 %9 to i8
  %11 = icmp eq i8 1, %10
  br i1 %11, label %switch.case.body2, label %switch.case.next1

switch.case.body:                                 ; preds = %entry
  ret i64 0

switch.case.next1:                                ; preds = %switch.case.next
  %12 = icmp eq ptr %1, null
  %13 = zext i1 %12 to i8
  %14 = icmp eq i8 1, %13
  br i1 %14, label %switch.case.body4, label %switch.case.next3

switch.case.body2:                                ; preds = %switch.case.next
  ret i64 -1

switch.case.next3:                                ; preds = %switch.case.next1
  br label %switch.done

switch.case.body4:                                ; preds = %switch.case.next1
  ret i64 1

switch.done:                                      ; preds = %switch.case.next3
  store ptr %0, ptr %a, align 8
  store ptr %1, ptr %b, align 8
  store i64 %2, ptr %n, align 8
  store i64 0, ptr %i, align 8
  store i64 0, ptr %m, align 8
  %15 = load i64, ptr %n, align 8
  %16 = load i64, ptr %i, align 8
  %17 = sub i64 %15, %16
  %18 = udiv i64 %17, 16
  %19 = mul i64 %18, 16
  store i64 %19, ptr %m, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %switch.done
  %20 = load i64, ptr %i, align 8
  %21 = load i64, ptr %m, align 8
  %22 = icmp ult i64 %20, %21
  %23 = zext i1 %22 to i8
  %24 = icmp ne i8 %23, 0
  br i1 %24, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %25 = load ptr, ptr %a, align 8
  %26 = load i64, ptr %i, align 8
  %27 = getelementptr i8, ptr %25, i64 %26
  %28 = load <16 x i8>, ptr %27, align 1
  store <16 x i8> %28, ptr %load_a, align 16
  %29 = load ptr, ptr %b, align 8
  %30 = load i64, ptr %i, align 8
  %31 = getelementptr i8, ptr %29, i64 %30
  %32 = load <16 x i8>, ptr %31, align 1
  store <16 x i8> %32, ptr %load_b, align 16
  %33 = load <16 x i8>, ptr %load_a, align 16
  %34 = load <16 x i8>, ptr %load_b, align 16
  %35 = icmp ne <16 x i8> %33, %34
  %36 = sext <16 x i1> %35 to <16 x i8>
  store <16 x i8> %36, ptr %comparison, align 16
  %37 = load <16 x i8>, ptr %comparison, align 16
  %38 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %37)
  %39 = icmp ne i8 %38, 0
  %40 = zext i1 %39 to i8
  %41 = icmp ne i8 %40, 0
  br i1 %41, label %if.then, label %if.done6

if.then:                                          ; preds = %for.body
  store <16 x i8> splat (i8 -1), ptr %sentinel, align 16
  store <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7, i8 8, i8 9, i8 10, i8 11, i8 12, i8 13, i8 14, i8 15>, ptr %indices, align 16
  %42 = load <16 x i8>, ptr %comparison, align 16
  %43 = load <16 x i8>, ptr %indices, align 16
  %44 = load <16 x i8>, ptr %sentinel, align 16
  %45 = icmp ne <16 x i8> %42, zeroinitializer
  %46 = select <16 x i1> %45, <16 x i8> %43, <16 x i8> %44
  store <16 x i8> %46, ptr %index_select, align 16
  %47 = load <16 x i8>, ptr %index_select, align 16
  %48 = call i8 @llvm.vector.reduce.umin.v16i8(<16 x i8> %47)
  %49 = zext i8 %48 to i64
  store i64 %49, ptr %index_reduce, align 8
  %50 = load ptr, ptr %a, align 8
  %51 = load i64, ptr %i, align 8
  %52 = load i64, ptr %index_reduce, align 8
  %53 = add i64 %51, %52
  %54 = getelementptr i8, ptr %50, i64 %53
  %55 = load i8, ptr %54, align 1
  %56 = load ptr, ptr %b, align 8
  %57 = load i64, ptr %i, align 8
  %58 = load i64, ptr %index_reduce, align 8
  %59 = add i64 %57, %58
  %60 = getelementptr i8, ptr %56, i64 %59
  %61 = load i8, ptr %60, align 1
  %62 = icmp ult i8 %55, %61
  %63 = zext i1 %62 to i8
  %64 = icmp ne i8 %63, 0
  br i1 %64, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then
  br label %if.done

if.else:                                          ; preds = %if.then
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then5
  %65 = phi i64 [ -1, %if.then5 ], [ 1, %if.else ]
  ret i64 %65

if.done6:                                         ; preds = %for.body
  br label %for.post

for.post:                                         ; preds = %if.done6
  %66 = load i64, ptr %i, align 8
  %67 = add i64 %66, 16
  store i64 %67, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %68 = load i64, ptr %n, align 8
  %69 = load i64, ptr %i, align 8
  %70 = sub i64 %68, %69
  %71 = udiv i64 %70, 8
  %72 = mul i64 %71, 8
  store i64 %72, ptr %m, align 8
  br label %for.loop7

for.loop7:                                        ; preds = %for.post21, %for.done
  %73 = load i64, ptr %i, align 8
  %74 = load i64, ptr %m, align 8
  %75 = icmp ult i64 %73, %74
  %76 = zext i1 %75 to i8
  %77 = icmp ne i8 %76, 0
  br i1 %77, label %for.body8, label %for.done22

for.body8:                                        ; preds = %for.loop7
  %78 = load ptr, ptr %a, align 8
  %79 = load i64, ptr %i, align 8
  %80 = getelementptr i8, ptr %78, i64 %79
  %81 = load <8 x i8>, ptr %80, align 1
  store <8 x i8> %81, ptr %load_a9, align 8
  %82 = load ptr, ptr %b, align 8
  %83 = load i64, ptr %i, align 8
  %84 = getelementptr i8, ptr %82, i64 %83
  %85 = load <8 x i8>, ptr %84, align 1
  store <8 x i8> %85, ptr %load_b10, align 8
  %86 = load <8 x i8>, ptr %load_a9, align 8
  %87 = load <8 x i8>, ptr %load_b10, align 8
  %88 = icmp ne <8 x i8> %86, %87
  %89 = sext <8 x i1> %88 to <8 x i8>
  store <8 x i8> %89, ptr %comparison11, align 8
  %90 = load <8 x i8>, ptr %comparison11, align 8
  %91 = call i8 @llvm.vector.reduce.or.v8i8(<8 x i8> %90)
  %92 = icmp ne i8 %91, 0
  %93 = zext i1 %92 to i8
  %94 = icmp ne i8 %93, 0
  br i1 %94, label %if.then12, label %if.done20

if.then12:                                        ; preds = %for.body8
  store <8 x i8> splat (i8 -1), ptr %sentinel13, align 8
  store <8 x i8> <i8 0, i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7>, ptr %indices14, align 8
  %95 = load <8 x i8>, ptr %comparison11, align 8
  %96 = load <8 x i8>, ptr %indices14, align 8
  %97 = load <8 x i8>, ptr %sentinel13, align 8
  %98 = icmp ne <8 x i8> %95, zeroinitializer
  %99 = select <8 x i1> %98, <8 x i8> %96, <8 x i8> %97
  store <8 x i8> %99, ptr %index_select15, align 8
  %100 = load <8 x i8>, ptr %index_select15, align 8
  %101 = call i8 @llvm.vector.reduce.umin.v8i8(<8 x i8> %100)
  %102 = zext i8 %101 to i64
  store i64 %102, ptr %index_reduce16, align 8
  %103 = load ptr, ptr %a, align 8
  %104 = load i64, ptr %i, align 8
  %105 = load i64, ptr %index_reduce16, align 8
  %106 = add i64 %104, %105
  %107 = getelementptr i8, ptr %103, i64 %106
  %108 = load i8, ptr %107, align 1
  %109 = load ptr, ptr %b, align 8
  %110 = load i64, ptr %i, align 8
  %111 = load i64, ptr %index_reduce16, align 8
  %112 = add i64 %110, %111
  %113 = getelementptr i8, ptr %109, i64 %112
  %114 = load i8, ptr %113, align 1
  %115 = icmp ult i8 %108, %114
  %116 = zext i1 %115 to i8
  %117 = icmp ne i8 %116, 0
  br i1 %117, label %if.then17, label %if.else18

if.then17:                                        ; preds = %if.then12
  br label %if.done19

if.else18:                                        ; preds = %if.then12
  br label %if.done19

if.done19:                                        ; preds = %if.else18, %if.then17
  %118 = phi i64 [ -1, %if.then17 ], [ 1, %if.else18 ]
  ret i64 %118

if.done20:                                        ; preds = %for.body8
  br label %for.post21

for.post21:                                       ; preds = %if.done20
  %119 = load i64, ptr %i, align 8
  %120 = add i64 %119, 8
  store i64 %120, ptr %i, align 8
  br label %for.loop7

for.done22:                                       ; preds = %for.loop7
  br label %for.loop23

for.loop23:                                       ; preds = %for.post30, %for.done22
  %121 = load i64, ptr %i, align 8
  %122 = load i64, ptr %n, align 8
  %123 = icmp ult i64 %121, %122
  %124 = zext i1 %123 to i8
  %125 = icmp ne i8 %124, 0
  br i1 %125, label %for.body24, label %for.done31

for.body24:                                       ; preds = %for.loop23
  %126 = load ptr, ptr %a, align 8
  %127 = load i64, ptr %i, align 8
  %128 = getelementptr i8, ptr %126, i64 %127
  %129 = load i8, ptr %128, align 1
  %130 = load ptr, ptr %b, align 8
  %131 = load i64, ptr %i, align 8
  %132 = getelementptr i8, ptr %130, i64 %131
  %133 = load i8, ptr %132, align 1
  %134 = xor i8 %129, %133
  %135 = icmp ne i8 %134, 0
  %136 = zext i1 %135 to i8
  %137 = icmp ne i8 %136, 0
  br i1 %137, label %if.then25, label %if.done29

if.then25:                                        ; preds = %for.body24
  %138 = load ptr, ptr %a, align 8
  %139 = load i64, ptr %i, align 8
  %140 = getelementptr i8, ptr %138, i64 %139
  %141 = load i8, ptr %140, align 1
  %142 = zext i8 %141 to i64
  %143 = load ptr, ptr %b, align 8
  %144 = load i64, ptr %i, align 8
  %145 = getelementptr i8, ptr %143, i64 %144
  %146 = load i8, ptr %145, align 1
  %147 = zext i8 %146 to i64
  %148 = sub i64 %142, %147
  %149 = icmp slt i64 %148, 0
  %150 = zext i1 %149 to i8
  %151 = icmp ne i8 %150, 0
  br i1 %151, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.then25
  br label %if.done28

if.else27:                                        ; preds = %if.then25
  br label %if.done28

if.done28:                                        ; preds = %if.else27, %if.then26
  %152 = phi i64 [ -1, %if.then26 ], [ 1, %if.else27 ]
  ret i64 %152

if.done29:                                        ; preds = %for.body24
  br label %for.post30

for.post30:                                       ; preds = %if.done29
  %153 = load i64, ptr %i, align 8
  %154 = add i64 %153, 1
  store i64 %154, ptr %i, align 8
  br label %for.loop23

for.done31:                                       ; preds = %for.loop23
  ret i64 0
}

; Function Attrs: alwaysinline
define i64 @"runtime::map_load_factor"(i64 %0) #1 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = icmp ult i64 %0, 64
  %3 = shl i64 1, %0
  %4 = select i1 %2, i64 %3, i64 0
  %5 = mul i64 %4, 75
  %6 = udiv i64 %5, 100
  ret i64 %6
}

; Function Attrs: alwaysinline
define i64 @"runtime::map_resize_threshold"(ptr %0) #1 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  %2 = load i64, ptr %0, align 8
  %3 = and i64 %2, 63
  call void @llvm.lifetime.start.p0(i64 8, ptr %1)
  store i64 %3, ptr %1, align 8
  %4 = icmp ult i64 %3, 64
  %5 = shl i64 1, %3
  %6 = select i1 %4, i64 %5, i64 0
  %7 = mul i64 %6, 75
  %8 = udiv i64 %7, 100
  call void @llvm.lifetime.end.p0(i64 8, ptr %1)
  ret i64 %8
}

; Function Attrs: alwaysinline
define i64 @"runtime::map_log2_cap"(ptr %0) #1 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %1 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %0, i32 0, i32 0
  %2 = load i64, ptr %1, align 8
  %3 = and i64 %2, 63
  ret i64 %3
}

; Function Attrs: alwaysinline
define i64 @"runtime::map_data"(ptr %0) #1 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %1 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %0, i32 0, i32 0
  %2 = load i64, ptr %1, align 8
  %3 = and i64 %2, -64
  ret i64 %3
}

define i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]int,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %4 = alloca %"runtime::Allocator", align 8
  %5 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  %6 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 2
  %9 = load i64, ptr %8, align 8
  %10 = mul i64 %9, 8
  %11 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 3
  call void @llvm.experimental.noalias.scope.decl(metadata !39)
  call void @llvm.lifetime.start.p0(i64 8, ptr %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 16, ptr %4)
  call void @llvm.lifetime.start.p0(i64 16, ptr %5)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %7, ptr %2, align 8, !noalias !39
  store i64 %10, ptr %3, align 8, !noalias !39
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %11, i64 16, i1 false), !noalias !39
  %12 = icmp eq ptr %7, null
  %13 = zext i1 %12 to i8
  br i1 %12, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %entry
  %14 = load ptr, ptr %4, align 8, !noalias !39
  %15 = icmp eq ptr %14, null
  %16 = zext i1 %15 to i8
  br i1 %15, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %17 = load ptr, ptr %4, align 8, !noalias !39
  %18 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 1
  %19 = load ptr, ptr %18, align 8, !noalias !39
  call void @llvm.memset.inline.p0.i64(ptr %5, i8 0, i64 16, i1 false), !noalias !39
  %20 = call i8 %17(ptr %19, i8 1, i64 0, i64 0, ptr %7, i64 %10, ptr %1, ptr %5, ptr nonnull %__.context_ptr)
  store i8 %20, ptr %err.i, align 1, !noalias !39
  %21 = load i8, ptr %err.i, align 1, !noalias !39
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

"runtime::mem_free_with_size.exit":               ; preds = %if.done.i, %if.then.i
  %22 = phi i8 [ 0, %if.then.i ], [ %21, %if.done.i ]
  ret i8 %22
}

define i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]text_analyzer::Highlight,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %4 = alloca %"runtime::Allocator", align 8
  %5 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  %6 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 2
  %9 = load i64, ptr %8, align 8
  %10 = mul i64 %9, 32
  %11 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 3
  call void @llvm.experimental.noalias.scope.decl(metadata !42)
  call void @llvm.lifetime.start.p0(i64 8, ptr %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 16, ptr %4)
  call void @llvm.lifetime.start.p0(i64 16, ptr %5)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %7, ptr %2, align 8, !noalias !42
  store i64 %10, ptr %3, align 8, !noalias !42
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %11, i64 16, i1 false), !noalias !42
  %12 = icmp eq ptr %7, null
  %13 = zext i1 %12 to i8
  br i1 %12, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %entry
  %14 = load ptr, ptr %4, align 8, !noalias !42
  %15 = icmp eq ptr %14, null
  %16 = zext i1 %15 to i8
  br i1 %15, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %17 = load ptr, ptr %4, align 8, !noalias !42
  %18 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 1
  %19 = load ptr, ptr %18, align 8, !noalias !42
  call void @llvm.memset.inline.p0.i64(ptr %5, i8 0, i64 16, i1 false), !noalias !42
  %20 = call i8 %17(ptr %19, i8 1, i64 0, i64 0, ptr %7, i64 %10, ptr %1, ptr %5, ptr nonnull %__.context_ptr)
  store i8 %20, ptr %err.i, align 1, !noalias !42
  %21 = load i8, ptr %err.i, align 1, !noalias !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

"runtime::mem_free_with_size.exit":               ; preds = %if.done.i, %if.then.i
  %22 = phi i8 [ 0, %if.then.i ], [ %21, %if.done.i ]
  ret i8 %22
}

define i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]u8,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %4 = alloca %"runtime::Allocator", align 8
  %5 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  %6 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 2
  %9 = load i64, ptr %8, align 8
  %10 = mul i64 %9, 1
  %11 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 3
  call void @llvm.experimental.noalias.scope.decl(metadata !45)
  call void @llvm.lifetime.start.p0(i64 8, ptr %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 16, ptr %4)
  call void @llvm.lifetime.start.p0(i64 16, ptr %5)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %7, ptr %2, align 8, !noalias !45
  store i64 %10, ptr %3, align 8, !noalias !45
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %11, i64 16, i1 false), !noalias !45
  %12 = icmp eq ptr %7, null
  %13 = zext i1 %12 to i8
  br i1 %12, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %entry
  %14 = load ptr, ptr %4, align 8, !noalias !45
  %15 = icmp eq ptr %14, null
  %16 = zext i1 %15 to i8
  br i1 %15, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %17 = load ptr, ptr %4, align 8, !noalias !45
  %18 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 1
  %19 = load ptr, ptr %18, align 8, !noalias !45
  call void @llvm.memset.inline.p0.i64(ptr %5, i8 0, i64 16, i1 false), !noalias !45
  %20 = call i8 %17(ptr %19, i8 1, i64 0, i64 0, ptr %7, i64 %10, ptr %1, ptr %5, ptr nonnull %__.context_ptr)
  store i8 %20, ptr %err.i, align 1, !noalias !45
  %21 = load i8, ptr %err.i, align 1, !noalias !45
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

"runtime::mem_free_with_size.exit":               ; preds = %if.done.i, %if.then.i
  %22 = phi i8 [ 0, %if.then.i ], [ %21, %if.done.i ]
  ret i8 %22
}

define i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]string,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %4 = alloca %"runtime::Allocator", align 8
  %5 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  %6 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 2
  %9 = load i64, ptr %8, align 8
  %10 = mul i64 %9, 16
  %11 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 3
  call void @llvm.experimental.noalias.scope.decl(metadata !48)
  call void @llvm.lifetime.start.p0(i64 8, ptr %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 16, ptr %4)
  call void @llvm.lifetime.start.p0(i64 16, ptr %5)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %7, ptr %2, align 8, !noalias !48
  store i64 %10, ptr %3, align 8, !noalias !48
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %11, i64 16, i1 false), !noalias !48
  %12 = icmp eq ptr %7, null
  %13 = zext i1 %12 to i8
  br i1 %12, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %entry
  %14 = load ptr, ptr %4, align 8, !noalias !48
  %15 = icmp eq ptr %14, null
  %16 = zext i1 %15 to i8
  br i1 %15, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %17 = load ptr, ptr %4, align 8, !noalias !48
  %18 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 1
  %19 = load ptr, ptr %18, align 8, !noalias !48
  call void @llvm.memset.inline.p0.i64(ptr %5, i8 0, i64 16, i1 false), !noalias !48
  %20 = call i8 %17(ptr %19, i8 1, i64 0, i64 0, ptr %7, i64 %10, ptr %1, ptr %5, ptr nonnull %__.context_ptr)
  store i8 %20, ptr %err.i, align 1, !noalias !48
  %21 = load i8, ptr %err.i, align 1, !noalias !48
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

"runtime::mem_free_with_size.exit":               ; preds = %if.done.i, %if.then.i
  %22 = phi i8 [ 0, %if.then.i ], [ %21, %if.done.i ]
  ret i8 %22
}

define i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]text_analyzer::DisplayLine,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %4 = alloca %"runtime::Allocator", align 8
  %5 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  %6 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 2
  %9 = load i64, ptr %8, align 8
  %10 = mul i64 %9, 32
  %11 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 3
  call void @llvm.experimental.noalias.scope.decl(metadata !51)
  call void @llvm.lifetime.start.p0(i64 8, ptr %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 16, ptr %4)
  call void @llvm.lifetime.start.p0(i64 16, ptr %5)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %7, ptr %2, align 8, !noalias !51
  store i64 %10, ptr %3, align 8, !noalias !51
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %11, i64 16, i1 false), !noalias !51
  %12 = icmp eq ptr %7, null
  %13 = zext i1 %12 to i8
  br i1 %12, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %entry
  %14 = load ptr, ptr %4, align 8, !noalias !51
  %15 = icmp eq ptr %14, null
  %16 = zext i1 %15 to i8
  br i1 %15, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %17 = load ptr, ptr %4, align 8, !noalias !51
  %18 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 1
  %19 = load ptr, ptr %18, align 8, !noalias !51
  call void @llvm.memset.inline.p0.i64(ptr %5, i8 0, i64 16, i1 false), !noalias !51
  %20 = call i8 %17(ptr %19, i8 1, i64 0, i64 0, ptr %7, i64 %10, ptr %1, ptr %5, ptr nonnull %__.context_ptr)
  store i8 %20, ptr %err.i, align 1, !noalias !51
  %21 = load i8, ptr %err.i, align 1, !noalias !51
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

"runtime::mem_free_with_size.exit":               ; preds = %if.done.i, %if.then.i
  %22 = phi i8 [ 0, %if.then.i ], [ %21, %if.done.i ]
  ret i8 %22
}

define i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]text_analyzer::Filter,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %4 = alloca %"runtime::Allocator", align 8
  %5 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  %6 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 2
  %9 = load i64, ptr %8, align 8
  %10 = mul i64 %9, 32
  %11 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 3
  call void @llvm.experimental.noalias.scope.decl(metadata !54)
  call void @llvm.lifetime.start.p0(i64 8, ptr %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 16, ptr %4)
  call void @llvm.lifetime.start.p0(i64 16, ptr %5)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %7, ptr %2, align 8, !noalias !54
  store i64 %10, ptr %3, align 8, !noalias !54
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %11, i64 16, i1 false), !noalias !54
  %12 = icmp eq ptr %7, null
  %13 = zext i1 %12 to i8
  br i1 %12, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %entry
  %14 = load ptr, ptr %4, align 8, !noalias !54
  %15 = icmp eq ptr %14, null
  %16 = zext i1 %15 to i8
  br i1 %15, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %17 = load ptr, ptr %4, align 8, !noalias !54
  %18 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 1
  %19 = load ptr, ptr %18, align 8, !noalias !54
  call void @llvm.memset.inline.p0.i64(ptr %5, i8 0, i64 16, i1 false), !noalias !54
  %20 = call i8 %17(ptr %19, i8 1, i64 0, i64 0, ptr %7, i64 %10, ptr %1, ptr %5, ptr nonnull %__.context_ptr)
  store i8 %20, ptr %err.i, align 1, !noalias !54
  %21 = load i8, ptr %err.i, align 1, !noalias !54
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 16, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

"runtime::mem_free_with_size.exit":               ; preds = %if.done.i, %if.then.i
  %22 = phi i8 [ 0, %if.then.i ], [ %21, %if.done.i ]
  ret i8 %22
}

define i8 @"runtime::delete_slice:proc(array:[]u16,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 8
  %6 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca %"runtime::Allocator", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %8, ptr %1, i64 16, i1 false)
  %9 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  %13 = mul i64 %12, 2
  call void @llvm.experimental.noalias.scope.decl(metadata !57)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 16, ptr %5)
  call void @llvm.lifetime.start.p0(i64 16, ptr %6)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %10, ptr %3, align 8, !noalias !57
  store i64 %13, ptr %4, align 8, !noalias !57
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %8, i64 16, i1 false), !noalias !57
  %14 = icmp eq ptr %10, null
  %15 = zext i1 %14 to i8
  br i1 %14, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %entry
  %16 = load ptr, ptr %5, align 8, !noalias !57
  %17 = icmp eq ptr %16, null
  %18 = zext i1 %17 to i8
  br i1 %17, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 16, ptr %6)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %19 = load ptr, ptr %5, align 8, !noalias !57
  %20 = getelementptr inbounds nuw %"runtime::Allocator", ptr %5, i32 0, i32 1
  %21 = load ptr, ptr %20, align 8, !noalias !57
  call void @llvm.memset.inline.p0.i64(ptr %6, i8 0, i64 16, i1 false), !noalias !57
  %22 = call i8 %19(ptr %21, i8 1, i64 0, i64 0, ptr %10, i64 %13, ptr %2, ptr %6, ptr nonnull %__.context_ptr)
  store i8 %22, ptr %err.i, align 1, !noalias !57
  %23 = load i8, ptr %err.i, align 1, !noalias !57
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 16, ptr %6)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

"runtime::mem_free_with_size.exit":               ; preds = %if.done.i, %if.then.i
  %24 = phi i8 [ 0, %if.then.i ], [ %23, %if.done.i ]
  ret i8 %24
}

define i8 @"runtime::delete_slice:proc(array:[]string,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 8
  %6 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca %"runtime::Allocator", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %8, ptr %1, i64 16, i1 false)
  %9 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  %13 = mul i64 %12, 16
  call void @llvm.experimental.noalias.scope.decl(metadata !60)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 16, ptr %5)
  call void @llvm.lifetime.start.p0(i64 16, ptr %6)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %10, ptr %3, align 8, !noalias !60
  store i64 %13, ptr %4, align 8, !noalias !60
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %8, i64 16, i1 false), !noalias !60
  %14 = icmp eq ptr %10, null
  %15 = zext i1 %14 to i8
  br i1 %14, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %entry
  %16 = load ptr, ptr %5, align 8, !noalias !60
  %17 = icmp eq ptr %16, null
  %18 = zext i1 %17 to i8
  br i1 %17, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 16, ptr %6)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %19 = load ptr, ptr %5, align 8, !noalias !60
  %20 = getelementptr inbounds nuw %"runtime::Allocator", ptr %5, i32 0, i32 1
  %21 = load ptr, ptr %20, align 8, !noalias !60
  call void @llvm.memset.inline.p0.i64(ptr %6, i8 0, i64 16, i1 false), !noalias !60
  %22 = call i8 %19(ptr %21, i8 1, i64 0, i64 0, ptr %10, i64 %13, ptr %2, ptr %6, ptr nonnull %__.context_ptr)
  store i8 %22, ptr %err.i, align 1, !noalias !60
  %23 = load i8, ptr %err.i, align 1, !noalias !60
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 16, ptr %6)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

"runtime::mem_free_with_size.exit":               ; preds = %if.done.i, %if.then.i
  %24 = phi i8 [ 0, %if.then.i ], [ %23, %if.done.i ]
  ret i8 %24
}

define i8 @"runtime::delete_slice:proc(array:[]u8,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 8
  %6 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca %"runtime::Allocator", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %8, ptr %1, i64 16, i1 false)
  %9 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  %13 = mul i64 %12, 1
  call void @llvm.experimental.noalias.scope.decl(metadata !63)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 16, ptr %5)
  call void @llvm.lifetime.start.p0(i64 16, ptr %6)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %10, ptr %3, align 8, !noalias !63
  store i64 %13, ptr %4, align 8, !noalias !63
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %8, i64 16, i1 false), !noalias !63
  %14 = icmp eq ptr %10, null
  %15 = zext i1 %14 to i8
  br i1 %14, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %entry
  %16 = load ptr, ptr %5, align 8, !noalias !63
  %17 = icmp eq ptr %16, null
  %18 = zext i1 %17 to i8
  br i1 %17, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 16, ptr %6)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %19 = load ptr, ptr %5, align 8, !noalias !63
  %20 = getelementptr inbounds nuw %"runtime::Allocator", ptr %5, i32 0, i32 1
  %21 = load ptr, ptr %20, align 8, !noalias !63
  call void @llvm.memset.inline.p0.i64(ptr %6, i8 0, i64 16, i1 false), !noalias !63
  %22 = call i8 %19(ptr %21, i8 1, i64 0, i64 0, ptr %10, i64 %13, ptr %2, ptr %6, ptr nonnull %__.context_ptr)
  store i8 %22, ptr %err.i, align 1, !noalias !63
  %23 = load i8, ptr %err.i, align 1, !noalias !63
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %5)
  call void @llvm.lifetime.end.p0(i64 16, ptr %6)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

"runtime::mem_free_with_size.exit":               ; preds = %if.done.i, %if.then.i
  %24 = phi i8 [ 0, %if.then.i ], [ %23, %if.done.i ]
  ret i8 %24
}

; Function Attrs: alwaysinline
define i8 @"runtime::map_hash_is_empty"(i64 %0) #1 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = icmp eq i64 %0, 0
  %3 = zext i1 %2 to i8
  ret i8 %3
}

; Function Attrs: noinline
define i8 @"runtime::map_hash_is_deleted"(i64 %0) #2 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = and i64 %0, -9223372036854775808
  %3 = icmp ne i64 %2, 0
  %4 = zext i1 %3 to i8
  ret i8 %4
}

; Function Attrs: alwaysinline
define i8 @"runtime::map_hash_is_valid"(i64 %0) #1 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = icmp ne i64 %0, 0
  %3 = zext i1 %2 to i8
  %4 = and i64 %0, -9223372036854775808
  %5 = icmp eq i64 %4, 0
  %6 = zext i1 %5 to i8
  %7 = and i8 %3, %6
  ret i8 %7
}

; Function Attrs: alwaysinline
define i64 @"runtime::map_seed"(ptr %0) #1 {
decls:
  %1 = alloca i64, align 8
  %mix.i = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  %2 = load i64, ptr %0, align 8
  %3 = and i64 %2, -64
  call void @llvm.lifetime.start.p0(i64 8, ptr %1)
  call void @llvm.lifetime.start.p0(i64 8, ptr %mix.i)
  store i64 %3, ptr %1, align 8
  %4 = add i64 %3, -7046029254386353131
  store i64 %4, ptr %mix.i, align 8
  %5 = load i64, ptr %mix.i, align 8
  %6 = load i64, ptr %mix.i, align 8
  %7 = lshr i64 %6, 30
  %8 = xor i64 %5, %7
  %9 = mul i64 %8, -4658895280553007687
  store i64 %9, ptr %mix.i, align 8
  %10 = load i64, ptr %mix.i, align 8
  %11 = load i64, ptr %mix.i, align 8
  %12 = lshr i64 %11, 27
  %13 = xor i64 %10, %12
  %14 = mul i64 %13, -7723592293110705685
  store i64 %14, ptr %mix.i, align 8
  %15 = load i64, ptr %mix.i, align 8
  %16 = load i64, ptr %mix.i, align 8
  %17 = lshr i64 %16, 31
  %18 = xor i64 %15, %17
  call void @llvm.lifetime.end.p0(i64 8, ptr %1)
  call void @llvm.lifetime.end.p0(i64 8, ptr %mix.i)
  ret i64 %18
}

; Function Attrs: alwaysinline
define i64 @"runtime::map_seed_from_map_data"(i64 %0) #1 {
decls:
  %1 = alloca i64, align 8
  %mix = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = add i64 %0, -7046029254386353131
  store i64 %2, ptr %mix, align 8
  %3 = load i64, ptr %mix, align 8
  %4 = load i64, ptr %mix, align 8
  %5 = lshr i64 %4, 30
  %6 = select i1 true, i64 %5, i64 0
  %7 = xor i64 %3, %6
  %8 = mul i64 %7, -4658895280553007687
  store i64 %8, ptr %mix, align 8
  %9 = load i64, ptr %mix, align 8
  %10 = load i64, ptr %mix, align 8
  %11 = lshr i64 %10, 27
  %12 = select i1 true, i64 %11, i64 0
  %13 = xor i64 %9, %12
  %14 = mul i64 %13, -7723592293110705685
  store i64 %14, ptr %mix, align 8
  %15 = load i64, ptr %mix, align 8
  %16 = load i64, ptr %mix, align 8
  %17 = lshr i64 %16, 31
  %18 = select i1 true, i64 %17, i64 0
  %19 = xor i64 %15, %18
  ret i64 %19
}

define i64 @"runtime::memory_compare_zero"(ptr %0, i64 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %n = alloca i64, align 8
  %i = alloca i64, align 8
  %m = alloca i64, align 8
  %bytes = alloca ptr, align 8
  %scanner16 = alloca <16 x i8>, align 16
  %load = alloca <16 x i8>, align 16
  %ne = alloca <16 x i8>, align 16
  %4 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  store i64 %1, ptr %n, align 8
  store i64 0, ptr %i, align 8
  store i64 0, ptr %m, align 8
  store ptr %0, ptr %bytes, align 8
  %5 = load i64, ptr %n, align 8
  %6 = icmp uge i64 %5, 8
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %if.then, label %if.done8

if.then:                                          ; preds = %entry
  store <16 x i8> zeroinitializer, ptr %scanner16, align 16
  %9 = load i64, ptr %n, align 8
  %10 = load i64, ptr %i, align 8
  %11 = sub i64 %9, %10
  %12 = udiv i64 %11, 16
  %13 = mul i64 %12, 16
  store i64 %13, ptr %m, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %if.then
  %14 = load i64, ptr %i, align 8
  %15 = load i64, ptr %m, align 8
  %16 = icmp ult i64 %14, %15
  %17 = zext i1 %16 to i8
  %18 = icmp ne i8 %17, 0
  br i1 %18, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %19 = load ptr, ptr %bytes, align 8
  %20 = load i64, ptr %i, align 8
  %21 = getelementptr i8, ptr %19, i64 %20
  %22 = load <16 x i8>, ptr %21, align 1
  store <16 x i8> %22, ptr %load, align 16
  %23 = load <16 x i8>, ptr %scanner16, align 16
  %24 = load <16 x i8>, ptr %load, align 16
  %25 = icmp ne <16 x i8> %23, %24
  %26 = sext <16 x i1> %25 to <16 x i8>
  store <16 x i8> %26, ptr %ne, align 16
  %27 = load <16 x i8>, ptr %ne, align 16
  %28 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %27)
  %29 = icmp ne i8 %28, 0
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %if.then1, label %if.done

if.then1:                                         ; preds = %for.body
  ret i64 1

if.done:                                          ; preds = %for.body
  br label %for.post

for.post:                                         ; preds = %if.done
  %32 = load i64, ptr %i, align 8
  %33 = add i64 %32, 16
  store i64 %33, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %34 = load i64, ptr %n, align 8
  %35 = load i64, ptr %i, align 8
  %36 = sub i64 %34, %35
  %37 = udiv i64 %36, 8
  %38 = mul i64 %37, 8
  store i64 %38, ptr %m, align 8
  br label %for.loop2

for.loop2:                                        ; preds = %for.post6, %for.done
  %39 = load i64, ptr %i, align 8
  %40 = load i64, ptr %m, align 8
  %41 = icmp ult i64 %39, %40
  %42 = zext i1 %41 to i8
  %43 = icmp ne i8 %42, 0
  br i1 %43, label %for.body3, label %for.done7

for.body3:                                        ; preds = %for.loop2
  %44 = load ptr, ptr %bytes, align 8
  %45 = load i64, ptr %i, align 8
  %46 = getelementptr i8, ptr %44, i64 %45
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %46, i64 8, i1 false)
  %47 = load i64, ptr %4, align 8
  %48 = icmp ne i64 %47, 0
  %49 = zext i1 %48 to i8
  %50 = icmp ne i8 %49, 0
  br i1 %50, label %if.then4, label %if.done5

if.then4:                                         ; preds = %for.body3
  ret i64 1

if.done5:                                         ; preds = %for.body3
  br label %for.post6

for.post6:                                        ; preds = %if.done5
  %51 = load i64, ptr %i, align 8
  %52 = add i64 %51, 8
  store i64 %52, ptr %i, align 8
  br label %for.loop2

for.done7:                                        ; preds = %for.loop2
  br label %if.done8

if.done8:                                         ; preds = %for.done7, %entry
  br label %for.loop9

for.loop9:                                        ; preds = %for.post13, %if.done8
  %53 = load i64, ptr %i, align 8
  %54 = load i64, ptr %n, align 8
  %55 = icmp ult i64 %53, %54
  %56 = zext i1 %55 to i8
  %57 = icmp ne i8 %56, 0
  br i1 %57, label %for.body10, label %for.done14

for.body10:                                       ; preds = %for.loop9
  %58 = load ptr, ptr %bytes, align 8
  %59 = load i64, ptr %i, align 8
  %60 = getelementptr i8, ptr %58, i64 %59
  %61 = load i8, ptr %60, align 1
  %62 = icmp ne i8 %61, 0
  %63 = zext i1 %62 to i8
  %64 = icmp ne i8 %63, 0
  br i1 %64, label %if.then11, label %if.done12

if.then11:                                        ; preds = %for.body10
  ret i64 1

if.done12:                                        ; preds = %for.body10
  br label %for.post13

for.post13:                                       ; preds = %if.done12
  %65 = load i64, ptr %i, align 8
  %66 = add i64 %65, 1
  store i64 %66, ptr %i, align 8
  br label %for.loop9

for.done14:                                       ; preds = %for.loop9
  ret i64 0
}

; Function Attrs: alwaysinline
define i64 @"runtime::map_desired_position"(ptr %0, i64 %1) #1 {
decls:
  %2 = alloca i64, align 8
  %capacity = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %1, ptr %2, align 8
  %3 = load i64, ptr %0, align 8
  %4 = and i64 %3, 63
  %5 = icmp ult i64 %4, 64
  %6 = shl i64 1, %4
  %7 = select i1 %5, i64 %6, i64 0
  store i64 %7, ptr %capacity, align 8
  %8 = load i64, ptr %capacity, align 8
  %9 = sub i64 %8, 1
  %10 = and i64 %1, %9
  ret i64 %10
}

; Function Attrs: alwaysinline
define i64 @"runtime::map_probe_distance"(ptr %0, i64 %1, i64 %2) #1 {
decls:
  %3 = alloca i64, align 8
  %capacity.i = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %capacity = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %1, ptr %4, align 8
  store i64 %2, ptr %5, align 8
  %6 = load i64, ptr %0, align 8
  %7 = and i64 %6, 63
  %8 = icmp ult i64 %7, 64
  %9 = shl i64 1, %7
  %10 = select i1 %8, i64 %9, i64 0
  store i64 %10, ptr %capacity, align 8
  %11 = load i64, ptr %capacity, align 8
  %12 = add i64 %2, %11
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %capacity.i)
  store i64 %1, ptr %3, align 8
  %13 = load i64, ptr %0, align 8
  %14 = and i64 %13, 63
  %15 = shl i64 1, %14
  store i64 %15, ptr %capacity.i, align 8
  %16 = load i64, ptr %capacity.i, align 8
  %17 = sub i64 %16, 1
  %18 = and i64 %1, %17
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %capacity.i)
  %19 = sub i64 %12, %18
  %20 = load i64, ptr %capacity, align 8
  %21 = sub i64 %20, 1
  %22 = and i64 %19, %21
  ret i64 %22
}

define i8 @"runtime::make_aligned:proc(T:$[]u16,len:int,alignment:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[]u16,:runtime::Allocator_Error)"(i64 %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca %"runtime::Allocator", align 8
  %10 = alloca { ptr, i64 }, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca %"runtime::Allocator", align 8
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { { ptr, i64 }, i8 }, align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %16 = alloca %"runtime::Raw_Slice", align 8
  %s = alloca %"runtime::Raw_Slice", align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %11, align 8
  store i64 %1, ptr %12, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %13, ptr %2, i64 16, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  store i64 %0, ptr %5, align 8
  %17 = icmp sle i64 0, %0
  %18 = zext i1 %17 to i8
  br i1 %17, label %"runtime::make_slice_error_loc.exit", label %if.done.i1

if.done.i1:                                       ; preds = %entry
  call void @"runtime::make_slice_error_loc.handle_error-0"(ptr %3, i64 %0)
  unreachable

"runtime::make_slice_error_loc.exit":             ; preds = %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  %19 = mul i64 2, %0
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false)
  call void @llvm.experimental.noalias.scope.decl(metadata !66)
  call void @llvm.experimental.noalias.scope.decl(metadata !69)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 16, ptr %9)
  call void @llvm.lifetime.start.p0(i64 16, ptr %10)
  store i64 %19, ptr %7, align 8, !noalias !71
  store i64 %1, ptr %8, align 8, !noalias !71
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %13, i64 16, i1 false), !noalias !71
  call void @llvm.lifetime.start.p0(i64 8, ptr %6), !noalias !71
  store i64 %1, ptr %6, align 8, !noalias !71
  %20 = icmp sle i64 %1, 0
  %21 = zext i1 %20 to i8
  br i1 %20, label %if.then.i.i, label %if.done.i.i

if.then.i.i:                                      ; preds = %"runtime::make_slice_error_loc.exit"
  call void @llvm.lifetime.end.p0(i64 8, ptr %6), !noalias !71
  br label %"runtime::is_power_of_two_int.exit.i"

if.done.i.i:                                      ; preds = %"runtime::make_slice_error_loc.exit"
  %22 = sub i64 %1, 1
  %23 = and i64 %1, %22
  %24 = icmp eq i64 %23, 0
  %25 = zext i1 %24 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %6), !noalias !71
  br label %"runtime::is_power_of_two_int.exit.i"

"runtime::is_power_of_two_int.exit.i":            ; preds = %if.done.i.i, %if.then.i.i
  %26 = phi i8 [ 0, %if.then.i.i ], [ %25, %if.done.i.i ]
  %27 = icmp ne i8 %26, 0
  call void @"runtime::assert"(i1 zeroext %27, ptr @"ggv$runtime::mem_alloc_bytes$1", ptr %3, ptr nonnull %__.context_ptr), !noalias !66
  %28 = icmp eq i64 %19, 0
  %29 = zext i1 %28 to i8
  br i1 %28, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %"runtime::is_power_of_two_int.exit.i"
  %30 = load ptr, ptr %9, align 8, !noalias !71
  %31 = icmp eq ptr %30, null
  %32 = zext i1 %31 to i8
  br i1 %31, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %"runtime::is_power_of_two_int.exit.i"
  store { ptr, i64 } zeroinitializer, ptr %14, align 8, !alias.scope !66, !noalias !69
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %10)
  br label %"runtime::mem_alloc_bytes.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %33 = load ptr, ptr %9, align 8, !noalias !71
  %34 = getelementptr inbounds nuw %"runtime::Allocator", ptr %9, i32 0, i32 1
  %35 = load ptr, ptr %34, align 8, !noalias !71
  call void @llvm.memset.inline.p0.i64(ptr %10, i8 0, i64 16, i1 false), !noalias !71
  %36 = call i8 %33(ptr %35, i8 0, i64 %19, i64 %1, ptr null, i64 0, ptr %3, ptr %10, ptr nonnull %__.context_ptr), !noalias !66
  %37 = load { ptr, i64 }, ptr %10, align 8, !noalias !71
  store { ptr, i64 } %37, ptr %14, align 8, !alias.scope !66, !noalias !69
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %10)
  br label %"runtime::mem_alloc_bytes.exit"

"runtime::mem_alloc_bytes.exit":                  ; preds = %if.done.i, %if.then.i
  %38 = phi i8 [ 0, %if.then.i ], [ %36, %if.done.i ]
  %39 = load { ptr, i64 }, ptr %14, align 8
  store { ptr, i64 } %39, ptr %data, align 8
  store i8 %38, ptr %err, align 1
  %40 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %41 = load ptr, ptr %40, align 8
  %42 = icmp eq ptr %41, null
  %43 = zext i1 %42 to i8
  %44 = icmp ne i8 %43, 0
  br i1 %44, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %"runtime::mem_alloc_bytes.exit"
  br i1 true, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  %45 = load i8, ptr %err, align 1
  store { ptr, i64 } zeroinitializer, ptr %4, align 8
  ret i8 %45

if.done:                                          ; preds = %cmp.and, %"runtime::mem_alloc_bytes.exit"
  call void @llvm.memset.inline.p0.i64(ptr %16, i8 0, i64 16, i1 false)
  store %"runtime::Raw_Slice" zeroinitializer, ptr %16, align 8
  %46 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %47 = load ptr, ptr %46, align 8
  %48 = getelementptr inbounds nuw %"runtime::Raw_Slice", ptr %16, i32 0, i32 0
  store ptr %47, ptr %48, align 8
  %49 = getelementptr inbounds nuw %"runtime::Raw_Slice", ptr %16, i32 0, i32 1
  store i64 %0, ptr %49, align 8
  %50 = load %"runtime::Raw_Slice", ptr %16, align 8
  store %"runtime::Raw_Slice" %50, ptr %s, align 8
  %51 = load { ptr, i64 }, ptr %s, align 8
  %52 = load i8, ptr %err, align 1
  store { ptr, i64 } %51, ptr %4, align 8
  ret i8 %52
}

define i8 @"runtime::make_aligned:proc(T:$[]u8,len:int,alignment:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[]u8,:runtime::Allocator_Error)"(i64 %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca %"runtime::Allocator", align 8
  %10 = alloca { ptr, i64 }, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca %"runtime::Allocator", align 8
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { { ptr, i64 }, i8 }, align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %16 = alloca %"runtime::Raw_Slice", align 8
  %s = alloca %"runtime::Raw_Slice", align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %11, align 8
  store i64 %1, ptr %12, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %13, ptr %2, i64 16, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  store i64 %0, ptr %5, align 8
  %17 = icmp sle i64 0, %0
  %18 = zext i1 %17 to i8
  br i1 %17, label %"runtime::make_slice_error_loc.exit", label %if.done.i1

if.done.i1:                                       ; preds = %entry
  call void @"runtime::make_slice_error_loc.handle_error-0"(ptr %3, i64 %0)
  unreachable

"runtime::make_slice_error_loc.exit":             ; preds = %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  %19 = mul i64 1, %0
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false)
  call void @llvm.experimental.noalias.scope.decl(metadata !72)
  call void @llvm.experimental.noalias.scope.decl(metadata !75)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 16, ptr %9)
  call void @llvm.lifetime.start.p0(i64 16, ptr %10)
  store i64 %19, ptr %7, align 8, !noalias !77
  store i64 %1, ptr %8, align 8, !noalias !77
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %13, i64 16, i1 false), !noalias !77
  call void @llvm.lifetime.start.p0(i64 8, ptr %6), !noalias !77
  store i64 %1, ptr %6, align 8, !noalias !77
  %20 = icmp sle i64 %1, 0
  %21 = zext i1 %20 to i8
  br i1 %20, label %if.then.i.i, label %if.done.i.i

if.then.i.i:                                      ; preds = %"runtime::make_slice_error_loc.exit"
  call void @llvm.lifetime.end.p0(i64 8, ptr %6), !noalias !77
  br label %"runtime::is_power_of_two_int.exit.i"

if.done.i.i:                                      ; preds = %"runtime::make_slice_error_loc.exit"
  %22 = sub i64 %1, 1
  %23 = and i64 %1, %22
  %24 = icmp eq i64 %23, 0
  %25 = zext i1 %24 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %6), !noalias !77
  br label %"runtime::is_power_of_two_int.exit.i"

"runtime::is_power_of_two_int.exit.i":            ; preds = %if.done.i.i, %if.then.i.i
  %26 = phi i8 [ 0, %if.then.i.i ], [ %25, %if.done.i.i ]
  %27 = icmp ne i8 %26, 0
  call void @"runtime::assert"(i1 zeroext %27, ptr @"ggv$runtime::mem_alloc_bytes$1", ptr %3, ptr nonnull %__.context_ptr), !noalias !72
  %28 = icmp eq i64 %19, 0
  %29 = zext i1 %28 to i8
  br i1 %28, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %"runtime::is_power_of_two_int.exit.i"
  %30 = load ptr, ptr %9, align 8, !noalias !77
  %31 = icmp eq ptr %30, null
  %32 = zext i1 %31 to i8
  br i1 %31, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %"runtime::is_power_of_two_int.exit.i"
  store { ptr, i64 } zeroinitializer, ptr %14, align 8, !alias.scope !72, !noalias !75
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %10)
  br label %"runtime::mem_alloc_bytes.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %33 = load ptr, ptr %9, align 8, !noalias !77
  %34 = getelementptr inbounds nuw %"runtime::Allocator", ptr %9, i32 0, i32 1
  %35 = load ptr, ptr %34, align 8, !noalias !77
  call void @llvm.memset.inline.p0.i64(ptr %10, i8 0, i64 16, i1 false), !noalias !77
  %36 = call i8 %33(ptr %35, i8 0, i64 %19, i64 %1, ptr null, i64 0, ptr %3, ptr %10, ptr nonnull %__.context_ptr), !noalias !72
  %37 = load { ptr, i64 }, ptr %10, align 8, !noalias !77
  store { ptr, i64 } %37, ptr %14, align 8, !alias.scope !72, !noalias !75
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %10)
  br label %"runtime::mem_alloc_bytes.exit"

"runtime::mem_alloc_bytes.exit":                  ; preds = %if.done.i, %if.then.i
  %38 = phi i8 [ 0, %if.then.i ], [ %36, %if.done.i ]
  %39 = load { ptr, i64 }, ptr %14, align 8
  store { ptr, i64 } %39, ptr %data, align 8
  store i8 %38, ptr %err, align 1
  %40 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %41 = load ptr, ptr %40, align 8
  %42 = icmp eq ptr %41, null
  %43 = zext i1 %42 to i8
  %44 = icmp ne i8 %43, 0
  br i1 %44, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %"runtime::mem_alloc_bytes.exit"
  br i1 true, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  %45 = load i8, ptr %err, align 1
  store { ptr, i64 } zeroinitializer, ptr %4, align 8
  ret i8 %45

if.done:                                          ; preds = %cmp.and, %"runtime::mem_alloc_bytes.exit"
  call void @llvm.memset.inline.p0.i64(ptr %16, i8 0, i64 16, i1 false)
  store %"runtime::Raw_Slice" zeroinitializer, ptr %16, align 8
  %46 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %47 = load ptr, ptr %46, align 8
  %48 = getelementptr inbounds nuw %"runtime::Raw_Slice", ptr %16, i32 0, i32 0
  store ptr %47, ptr %48, align 8
  %49 = getelementptr inbounds nuw %"runtime::Raw_Slice", ptr %16, i32 0, i32 1
  store i64 %0, ptr %49, align 8
  %50 = load %"runtime::Raw_Slice", ptr %16, align 8
  store %"runtime::Raw_Slice" %50, ptr %s, align 8
  %51 = load { ptr, i64 }, ptr %s, align 8
  %52 = load i8, ptr %err, align 1
  store { ptr, i64 } %51, ptr %4, align 8
  ret i8 %52
}

define i8 @"runtime::make_aligned:proc(T:$[]string,len:int,alignment:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[]string,:runtime::Allocator_Error)"(i64 %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca %"runtime::Allocator", align 8
  %10 = alloca { ptr, i64 }, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca %"runtime::Allocator", align 8
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { { ptr, i64 }, i8 }, align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %16 = alloca %"runtime::Raw_Slice", align 8
  %s = alloca %"runtime::Raw_Slice", align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %11, align 8
  store i64 %1, ptr %12, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %13, ptr %2, i64 16, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  store i64 %0, ptr %5, align 8
  %17 = icmp sle i64 0, %0
  %18 = zext i1 %17 to i8
  br i1 %17, label %"runtime::make_slice_error_loc.exit", label %if.done.i1

if.done.i1:                                       ; preds = %entry
  call void @"runtime::make_slice_error_loc.handle_error-0"(ptr %3, i64 %0)
  unreachable

"runtime::make_slice_error_loc.exit":             ; preds = %entry
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  %19 = mul i64 16, %0
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false)
  call void @llvm.experimental.noalias.scope.decl(metadata !78)
  call void @llvm.experimental.noalias.scope.decl(metadata !81)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 16, ptr %9)
  call void @llvm.lifetime.start.p0(i64 16, ptr %10)
  store i64 %19, ptr %7, align 8, !noalias !83
  store i64 %1, ptr %8, align 8, !noalias !83
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %13, i64 16, i1 false), !noalias !83
  call void @llvm.lifetime.start.p0(i64 8, ptr %6), !noalias !83
  store i64 %1, ptr %6, align 8, !noalias !83
  %20 = icmp sle i64 %1, 0
  %21 = zext i1 %20 to i8
  br i1 %20, label %if.then.i.i, label %if.done.i.i

if.then.i.i:                                      ; preds = %"runtime::make_slice_error_loc.exit"
  call void @llvm.lifetime.end.p0(i64 8, ptr %6), !noalias !83
  br label %"runtime::is_power_of_two_int.exit.i"

if.done.i.i:                                      ; preds = %"runtime::make_slice_error_loc.exit"
  %22 = sub i64 %1, 1
  %23 = and i64 %1, %22
  %24 = icmp eq i64 %23, 0
  %25 = zext i1 %24 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %6), !noalias !83
  br label %"runtime::is_power_of_two_int.exit.i"

"runtime::is_power_of_two_int.exit.i":            ; preds = %if.done.i.i, %if.then.i.i
  %26 = phi i8 [ 0, %if.then.i.i ], [ %25, %if.done.i.i ]
  %27 = icmp ne i8 %26, 0
  call void @"runtime::assert"(i1 zeroext %27, ptr @"ggv$runtime::mem_alloc_bytes$1", ptr %3, ptr nonnull %__.context_ptr), !noalias !78
  %28 = icmp eq i64 %19, 0
  %29 = zext i1 %28 to i8
  br i1 %28, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %"runtime::is_power_of_two_int.exit.i"
  %30 = load ptr, ptr %9, align 8, !noalias !83
  %31 = icmp eq ptr %30, null
  %32 = zext i1 %31 to i8
  br i1 %31, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %"runtime::is_power_of_two_int.exit.i"
  store { ptr, i64 } zeroinitializer, ptr %14, align 8, !alias.scope !78, !noalias !81
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %10)
  br label %"runtime::mem_alloc_bytes.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %33 = load ptr, ptr %9, align 8, !noalias !83
  %34 = getelementptr inbounds nuw %"runtime::Allocator", ptr %9, i32 0, i32 1
  %35 = load ptr, ptr %34, align 8, !noalias !83
  call void @llvm.memset.inline.p0.i64(ptr %10, i8 0, i64 16, i1 false), !noalias !83
  %36 = call i8 %33(ptr %35, i8 0, i64 %19, i64 %1, ptr null, i64 0, ptr %3, ptr %10, ptr nonnull %__.context_ptr), !noalias !78
  %37 = load { ptr, i64 }, ptr %10, align 8, !noalias !83
  store { ptr, i64 } %37, ptr %14, align 8, !alias.scope !78, !noalias !81
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %10)
  br label %"runtime::mem_alloc_bytes.exit"

"runtime::mem_alloc_bytes.exit":                  ; preds = %if.done.i, %if.then.i
  %38 = phi i8 [ 0, %if.then.i ], [ %36, %if.done.i ]
  %39 = load { ptr, i64 }, ptr %14, align 8
  store { ptr, i64 } %39, ptr %data, align 8
  store i8 %38, ptr %err, align 1
  %40 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %41 = load ptr, ptr %40, align 8
  %42 = icmp eq ptr %41, null
  %43 = zext i1 %42 to i8
  %44 = icmp ne i8 %43, 0
  br i1 %44, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %"runtime::mem_alloc_bytes.exit"
  br i1 true, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  %45 = load i8, ptr %err, align 1
  store { ptr, i64 } zeroinitializer, ptr %4, align 8
  ret i8 %45

if.done:                                          ; preds = %cmp.and, %"runtime::mem_alloc_bytes.exit"
  call void @llvm.memset.inline.p0.i64(ptr %16, i8 0, i64 16, i1 false)
  store %"runtime::Raw_Slice" zeroinitializer, ptr %16, align 8
  %46 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %47 = load ptr, ptr %46, align 8
  %48 = getelementptr inbounds nuw %"runtime::Raw_Slice", ptr %16, i32 0, i32 0
  store ptr %47, ptr %48, align 8
  %49 = getelementptr inbounds nuw %"runtime::Raw_Slice", ptr %16, i32 0, i32 1
  store i64 %0, ptr %49, align 8
  %50 = load %"runtime::Raw_Slice", ptr %16, align 8
  store %"runtime::Raw_Slice" %50, ptr %s, align 8
  %51 = load { ptr, i64 }, ptr %s, align 8
  %52 = load i8, ptr %err, align 1
  store { ptr, i64 } %51, ptr %4, align 8
  ret i8 %52
}

define i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]text_analyzer::DisplayLine,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]text_analyzer::DisplayLine,err:runtime::Allocator_Error)"(i64 %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca %"runtime::Allocator", align 8
  %array = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %err = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %2, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr %array, i8 0, i64 40, i1 false)
  store i8 0, ptr %err, align 1
  %8 = call i8 @"runtime::_make_dynamic_array_len_cap"(ptr %array, i64 32, i64 8, i64 %0, i64 %1, ptr %7, ptr %3, ptr %__.context_ptr)
  store i8 %8, ptr %err, align 1
  %9 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %array, align 8
  %10 = load i8, ptr %err, align 1
  store { ptr, i64, i64, %"runtime::Allocator" } %9, ptr %array, align 8
  store i8 %10, ptr %err, align 1
  store { ptr, i64, i64, %"runtime::Allocator" } %9, ptr %4, align 8
  ret i8 %10
}

define i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]text_analyzer::Filter,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]text_analyzer::Filter,err:runtime::Allocator_Error)"(i64 %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca %"runtime::Allocator", align 8
  %array = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %err = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %2, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr %array, i8 0, i64 40, i1 false)
  store i8 0, ptr %err, align 1
  %8 = call i8 @"runtime::_make_dynamic_array_len_cap"(ptr %array, i64 32, i64 8, i64 %0, i64 %1, ptr %7, ptr %3, ptr %__.context_ptr)
  store i8 %8, ptr %err, align 1
  %9 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %array, align 8
  %10 = load i8, ptr %err, align 1
  store { ptr, i64, i64, %"runtime::Allocator" } %9, ptr %array, align 8
  store i8 %10, ptr %err, align 1
  store { ptr, i64, i64, %"runtime::Allocator" } %9, ptr %4, align 8
  ret i8 %10
}

define i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]string,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]string,err:runtime::Allocator_Error)"(i64 %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca %"runtime::Allocator", align 8
  %array = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %err = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %2, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr %array, i8 0, i64 40, i1 false)
  store i8 0, ptr %err, align 1
  %8 = call i8 @"runtime::_make_dynamic_array_len_cap"(ptr %array, i64 16, i64 8, i64 %0, i64 %1, ptr %7, ptr %3, ptr %__.context_ptr)
  store i8 %8, ptr %err, align 1
  %9 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %array, align 8
  %10 = load i8, ptr %err, align 1
  store { ptr, i64, i64, %"runtime::Allocator" } %9, ptr %array, align 8
  store i8 %10, ptr %err, align 1
  store { ptr, i64, i64, %"runtime::Allocator" } %9, ptr %4, align 8
  ret i8 %10
}

define i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]text_analyzer::Highlight,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]text_analyzer::Highlight,err:runtime::Allocator_Error)"(i64 %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca %"runtime::Allocator", align 8
  %array = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %err = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %2, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr %array, i8 0, i64 40, i1 false)
  store i8 0, ptr %err, align 1
  %8 = call i8 @"runtime::_make_dynamic_array_len_cap"(ptr %array, i64 32, i64 8, i64 %0, i64 %1, ptr %7, ptr %3, ptr %__.context_ptr)
  store i8 %8, ptr %err, align 1
  %9 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %array, align 8
  %10 = load i8, ptr %err, align 1
  store { ptr, i64, i64, %"runtime::Allocator" } %9, ptr %array, align 8
  store i8 %10, ptr %err, align 1
  store { ptr, i64, i64, %"runtime::Allocator" } %9, ptr %4, align 8
  ret i8 %10
}

define i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]int,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]int,err:runtime::Allocator_Error)"(i64 %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca %"runtime::Allocator", align 8
  %array = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %err = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %2, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr %array, i8 0, i64 40, i1 false)
  store i8 0, ptr %err, align 1
  %8 = call i8 @"runtime::_make_dynamic_array_len_cap"(ptr %array, i64 8, i64 8, i64 %0, i64 %1, ptr %7, ptr %3, ptr %__.context_ptr)
  store i8 %8, ptr %err, align 1
  %9 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %array, align 8
  %10 = load i8, ptr %err, align 1
  store { ptr, i64, i64, %"runtime::Allocator" } %9, ptr %array, align 8
  store i8 %10, ptr %err, align 1
  store { ptr, i64, i64, %"runtime::Allocator" } %9, ptr %4, align 8
  ret i8 %10
}

define i64 @"runtime::map_kvh_data_dynamic"(ptr %0, ptr noalias %1, ptr noalias nonnull %2, ptr noalias nonnull %3, ptr noalias nonnull %4, ptr noalias nonnull %5) {
decls:
  %6 = alloca i64, align 8
  %7 = alloca ptr, align 8
  %8 = alloca i64, align 8
  %elements_per_cell.i13 = alloca i64, align 8
  %size_of_cell.i14 = alloca i64, align 8
  %cell_index.i15 = alloca i64, align 8
  %data_index.i16 = alloca i64, align 8
  %size_of_type.i17 = alloca i64, align 8
  %cell_index2.i18 = alloca i64, align 8
  %data_index3.i19 = alloca i64, align 8
  %size_of_type4.i20 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca ptr, align 8
  %11 = alloca i64, align 8
  %elements_per_cell.i1 = alloca i64, align 8
  %size_of_cell.i2 = alloca i64, align 8
  %cell_index.i3 = alloca i64, align 8
  %data_index.i4 = alloca i64, align 8
  %size_of_type.i5 = alloca i64, align 8
  %cell_index2.i6 = alloca i64, align 8
  %data_index3.i7 = alloca i64, align 8
  %size_of_type4.i8 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca ptr, align 8
  %14 = alloca i64, align 8
  %elements_per_cell.i = alloca i64, align 8
  %size_of_cell.i = alloca i64, align 8
  %cell_index.i = alloca i64, align 8
  %data_index.i = alloca i64, align 8
  %size_of_type.i = alloca i64, align 8
  %cell_index2.i = alloca i64, align 8
  %data_index3.i = alloca i64, align 8
  %size_of_type4.i = alloca i64, align 8
  %15 = alloca ptr, align 8
  %ks = alloca i64, align 8
  %vs = alloca i64, align 8
  %hs = alloca ptr, align 8
  %sk = alloca i64, align 8
  %sv = alloca i64, align 8
  %INFO_HS = alloca ptr, align 8
  %capacity = alloca i64, align 8
  %hs_ = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %1, ptr %15, align 8
  store i64 0, ptr %ks, align 8
  store i64 0, ptr %vs, align 8
  store ptr null, ptr %hs, align 8
  store i64 0, ptr %sk, align 8
  store i64 0, ptr %sv, align 8
  store ptr @"ggv$map_cell_info-13197927915248882629", ptr %INFO_HS, align 8
  %16 = load i64, ptr %0, align 8
  %17 = and i64 %16, 63
  %18 = icmp ult i64 %17, 64
  %19 = shl i64 1, %17
  %20 = select i1 %18, i64 %19, i64 0
  store i64 %20, ptr %capacity, align 8
  %21 = load i64, ptr %0, align 8
  %22 = and i64 %21, -64
  store i64 %22, ptr %ks, align 8
  %23 = load i64, ptr %ks, align 8
  %24 = load ptr, ptr %15, align 8
  %25 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %24, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %27 = load i64, ptr %capacity, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !84)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i13)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i15)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i16)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i17)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i18)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i19)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i20)
  store i64 %23, ptr %6, align 8, !noalias !84
  store ptr %26, ptr %7, align 8, !noalias !84
  store i64 %27, ptr %8, align 8, !noalias !84
  %28 = load ptr, ptr %7, align 8, !noalias !84
  %29 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %28, i32 0, i32 3
  %30 = load i64, ptr %29, align 8
  store i64 %30, ptr %elements_per_cell.i13, align 8, !noalias !84
  %31 = load ptr, ptr %7, align 8, !noalias !84
  %32 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %31, i32 0, i32 2
  %33 = load i64, ptr %32, align 8
  store i64 %33, ptr %size_of_cell.i14, align 8, !noalias !84
  %34 = load i64, ptr %elements_per_cell.i13, align 8, !noalias !84
  switch i64 %34, label %switch.default.body.i23 [
    i64 1, label %switch.case.body.i22
    i64 2, label %switch.case.body1.i21
  ]

switch.case.body.i22:                             ; preds = %entry
  %35 = load i64, ptr %size_of_cell.i14, align 8, !noalias !84
  %36 = mul i64 %27, %35
  %37 = add i64 %23, %36
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i20)
  br label %"runtime::map_cell_index_dynamic.exit24"

switch.case.body1.i21:                            ; preds = %entry
  %38 = lshr i64 %27, 1
  store i64 %38, ptr %cell_index.i15, align 8, !noalias !84
  %39 = and i64 %27, 1
  store i64 %39, ptr %data_index.i16, align 8, !noalias !84
  %40 = load ptr, ptr %7, align 8, !noalias !84
  %41 = load i64, ptr %40, align 8
  store i64 %41, ptr %size_of_type.i17, align 8, !noalias !84
  %42 = load i64, ptr %cell_index.i15, align 8, !noalias !84
  %43 = load i64, ptr %size_of_cell.i14, align 8, !noalias !84
  %44 = mul i64 %42, %43
  %45 = add i64 %23, %44
  %46 = load i64, ptr %data_index.i16, align 8, !noalias !84
  %47 = load i64, ptr %size_of_type.i17, align 8, !noalias !84
  %48 = mul i64 %46, %47
  %49 = add i64 %45, %48
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i20)
  br label %"runtime::map_cell_index_dynamic.exit24"

switch.default.body.i23:                          ; preds = %entry
  %50 = load i64, ptr %elements_per_cell.i13, align 8, !noalias !84
  %51 = udiv i64 %27, %50
  store i64 %51, ptr %cell_index2.i18, align 8, !noalias !84
  %52 = load i64, ptr %elements_per_cell.i13, align 8, !noalias !84
  %53 = urem i64 %27, %52
  store i64 %53, ptr %data_index3.i19, align 8, !noalias !84
  %54 = load ptr, ptr %7, align 8, !noalias !84
  %55 = load i64, ptr %54, align 8
  store i64 %55, ptr %size_of_type4.i20, align 8, !noalias !84
  %56 = load i64, ptr %cell_index2.i18, align 8, !noalias !84
  %57 = load i64, ptr %size_of_cell.i14, align 8, !noalias !84
  %58 = mul i64 %56, %57
  %59 = add i64 %23, %58
  %60 = load i64, ptr %data_index3.i19, align 8, !noalias !84
  %61 = load i64, ptr %size_of_type4.i20, align 8, !noalias !84
  %62 = mul i64 %60, %61
  %63 = add i64 %59, %62
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i20)
  br label %"runtime::map_cell_index_dynamic.exit24"

"runtime::map_cell_index_dynamic.exit24":         ; preds = %switch.default.body.i23, %switch.case.body1.i21, %switch.case.body.i22
  %64 = phi i64 [ %37, %switch.case.body.i22 ], [ %49, %switch.case.body1.i21 ], [ %63, %switch.default.body.i23 ]
  store i64 %64, ptr %vs, align 8
  %65 = load i64, ptr %vs, align 8
  %66 = load ptr, ptr %15, align 8
  %67 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %66, i32 0, i32 1
  %68 = load ptr, ptr %67, align 8
  %69 = load i64, ptr %capacity, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !87)
  call void @llvm.lifetime.start.p0(i64 8, ptr %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i1)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i8)
  store i64 %65, ptr %9, align 8, !noalias !87
  store ptr %68, ptr %10, align 8, !noalias !87
  store i64 %69, ptr %11, align 8, !noalias !87
  %70 = load ptr, ptr %10, align 8, !noalias !87
  %71 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %70, i32 0, i32 3
  %72 = load i64, ptr %71, align 8
  store i64 %72, ptr %elements_per_cell.i1, align 8, !noalias !87
  %73 = load ptr, ptr %10, align 8, !noalias !87
  %74 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %73, i32 0, i32 2
  %75 = load i64, ptr %74, align 8
  store i64 %75, ptr %size_of_cell.i2, align 8, !noalias !87
  %76 = load i64, ptr %elements_per_cell.i1, align 8, !noalias !87
  switch i64 %76, label %switch.default.body.i11 [
    i64 1, label %switch.case.body.i10
    i64 2, label %switch.case.body1.i9
  ]

switch.case.body.i10:                             ; preds = %"runtime::map_cell_index_dynamic.exit24"
  %77 = load i64, ptr %size_of_cell.i2, align 8, !noalias !87
  %78 = mul i64 %69, %77
  %79 = add i64 %65, %78
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i1)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i8)
  br label %"runtime::map_cell_index_dynamic.exit12"

switch.case.body1.i9:                             ; preds = %"runtime::map_cell_index_dynamic.exit24"
  %80 = lshr i64 %69, 1
  store i64 %80, ptr %cell_index.i3, align 8, !noalias !87
  %81 = and i64 %69, 1
  store i64 %81, ptr %data_index.i4, align 8, !noalias !87
  %82 = load ptr, ptr %10, align 8, !noalias !87
  %83 = load i64, ptr %82, align 8
  store i64 %83, ptr %size_of_type.i5, align 8, !noalias !87
  %84 = load i64, ptr %cell_index.i3, align 8, !noalias !87
  %85 = load i64, ptr %size_of_cell.i2, align 8, !noalias !87
  %86 = mul i64 %84, %85
  %87 = add i64 %65, %86
  %88 = load i64, ptr %data_index.i4, align 8, !noalias !87
  %89 = load i64, ptr %size_of_type.i5, align 8, !noalias !87
  %90 = mul i64 %88, %89
  %91 = add i64 %87, %90
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i1)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i8)
  br label %"runtime::map_cell_index_dynamic.exit12"

switch.default.body.i11:                          ; preds = %"runtime::map_cell_index_dynamic.exit24"
  %92 = load i64, ptr %elements_per_cell.i1, align 8, !noalias !87
  %93 = udiv i64 %69, %92
  store i64 %93, ptr %cell_index2.i6, align 8, !noalias !87
  %94 = load i64, ptr %elements_per_cell.i1, align 8, !noalias !87
  %95 = urem i64 %69, %94
  store i64 %95, ptr %data_index3.i7, align 8, !noalias !87
  %96 = load ptr, ptr %10, align 8, !noalias !87
  %97 = load i64, ptr %96, align 8
  store i64 %97, ptr %size_of_type4.i8, align 8, !noalias !87
  %98 = load i64, ptr %cell_index2.i6, align 8, !noalias !87
  %99 = load i64, ptr %size_of_cell.i2, align 8, !noalias !87
  %100 = mul i64 %98, %99
  %101 = add i64 %65, %100
  %102 = load i64, ptr %data_index3.i7, align 8, !noalias !87
  %103 = load i64, ptr %size_of_type4.i8, align 8, !noalias !87
  %104 = mul i64 %102, %103
  %105 = add i64 %101, %104
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i1)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i8)
  br label %"runtime::map_cell_index_dynamic.exit12"

"runtime::map_cell_index_dynamic.exit12":         ; preds = %switch.default.body.i11, %switch.case.body1.i9, %switch.case.body.i10
  %106 = phi i64 [ %79, %switch.case.body.i10 ], [ %91, %switch.case.body1.i9 ], [ %105, %switch.default.body.i11 ]
  store i64 %106, ptr %hs_, align 8
  %107 = load i64, ptr %hs_, align 8
  %108 = load ptr, ptr %INFO_HS, align 8
  %109 = load i64, ptr %capacity, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !90)
  call void @llvm.lifetime.start.p0(i64 8, ptr %12)
  call void @llvm.lifetime.start.p0(i64 8, ptr %13)
  call void @llvm.lifetime.start.p0(i64 8, ptr %14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i)
  store i64 %107, ptr %12, align 8, !noalias !90
  store ptr %108, ptr %13, align 8, !noalias !90
  store i64 %109, ptr %14, align 8, !noalias !90
  %110 = load ptr, ptr %13, align 8, !noalias !90
  %111 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %110, i32 0, i32 3
  %112 = load i64, ptr %111, align 8
  store i64 %112, ptr %elements_per_cell.i, align 8, !noalias !90
  %113 = load ptr, ptr %13, align 8, !noalias !90
  %114 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %113, i32 0, i32 2
  %115 = load i64, ptr %114, align 8
  store i64 %115, ptr %size_of_cell.i, align 8, !noalias !90
  %116 = load i64, ptr %elements_per_cell.i, align 8, !noalias !90
  switch i64 %116, label %switch.default.body.i [
    i64 1, label %switch.case.body.i
    i64 2, label %switch.case.body1.i
  ]

switch.case.body.i:                               ; preds = %"runtime::map_cell_index_dynamic.exit12"
  %117 = load i64, ptr %size_of_cell.i, align 8, !noalias !90
  %118 = mul i64 %109, %117
  %119 = add i64 %107, %118
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i)
  br label %"runtime::map_cell_index_dynamic.exit"

switch.case.body1.i:                              ; preds = %"runtime::map_cell_index_dynamic.exit12"
  %120 = lshr i64 %109, 1
  store i64 %120, ptr %cell_index.i, align 8, !noalias !90
  %121 = and i64 %109, 1
  store i64 %121, ptr %data_index.i, align 8, !noalias !90
  %122 = load ptr, ptr %13, align 8, !noalias !90
  %123 = load i64, ptr %122, align 8
  store i64 %123, ptr %size_of_type.i, align 8, !noalias !90
  %124 = load i64, ptr %cell_index.i, align 8, !noalias !90
  %125 = load i64, ptr %size_of_cell.i, align 8, !noalias !90
  %126 = mul i64 %124, %125
  %127 = add i64 %107, %126
  %128 = load i64, ptr %data_index.i, align 8, !noalias !90
  %129 = load i64, ptr %size_of_type.i, align 8, !noalias !90
  %130 = mul i64 %128, %129
  %131 = add i64 %127, %130
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i)
  br label %"runtime::map_cell_index_dynamic.exit"

switch.default.body.i:                            ; preds = %"runtime::map_cell_index_dynamic.exit12"
  %132 = load i64, ptr %elements_per_cell.i, align 8, !noalias !90
  %133 = udiv i64 %109, %132
  store i64 %133, ptr %cell_index2.i, align 8, !noalias !90
  %134 = load i64, ptr %elements_per_cell.i, align 8, !noalias !90
  %135 = urem i64 %109, %134
  store i64 %135, ptr %data_index3.i, align 8, !noalias !90
  %136 = load ptr, ptr %13, align 8, !noalias !90
  %137 = load i64, ptr %136, align 8
  store i64 %137, ptr %size_of_type4.i, align 8, !noalias !90
  %138 = load i64, ptr %cell_index2.i, align 8, !noalias !90
  %139 = load i64, ptr %size_of_cell.i, align 8, !noalias !90
  %140 = mul i64 %138, %139
  %141 = add i64 %107, %140
  %142 = load i64, ptr %data_index3.i, align 8, !noalias !90
  %143 = load i64, ptr %size_of_type4.i, align 8, !noalias !90
  %144 = mul i64 %142, %143
  %145 = add i64 %141, %144
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i)
  br label %"runtime::map_cell_index_dynamic.exit"

"runtime::map_cell_index_dynamic.exit":           ; preds = %switch.default.body.i, %switch.case.body1.i, %switch.case.body.i
  %146 = phi i64 [ %119, %switch.case.body.i ], [ %131, %switch.case.body1.i ], [ %145, %switch.default.body.i ]
  store i64 %146, ptr %sk, align 8
  %147 = load i64, ptr %sk, align 8
  %148 = load ptr, ptr %15, align 8
  %149 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %148, i32 0, i32 0
  %150 = load ptr, ptr %149, align 8
  %151 = call i64 @"runtime::map_cell_index_dynamic_const:proc\22contextless\22(base:uintptr,info:^runtime::Map_Cell_Info,INDEX:$$2)->(:uintptr)"(i64 %147, ptr %150)
  store i64 %151, ptr %sv, align 8
  %152 = load i64, ptr %hs_, align 8
  %153 = inttoptr i64 %152 to ptr
  store ptr %153, ptr %hs, align 8
  %154 = load i64, ptr %ks, align 8
  %155 = load i64, ptr %vs, align 8
  %156 = load ptr, ptr %hs, align 8
  %157 = load i64, ptr %sk, align 8
  %158 = load i64, ptr %sv, align 8
  store i64 %154, ptr %ks, align 8
  store i64 %155, ptr %vs, align 8
  store ptr %156, ptr %hs, align 8
  store i64 %157, ptr %sk, align 8
  store i64 %158, ptr %sv, align 8
  store i64 %154, ptr %2, align 8
  store i64 %155, ptr %3, align 8
  store ptr %156, ptr %4, align 8
  store i64 %157, ptr %5, align 8
  ret i64 %158
}

define i64 @"runtime::map_cell_index_dynamic_const:proc\22contextless\22(base:uintptr,info:^runtime::Map_Cell_Info,INDEX:$$2)->(:uintptr)"(i64 %0, ptr noalias %1) {
decls:
  %2 = alloca i64, align 8
  %3 = alloca ptr, align 8
  %elements_per_cell = alloca i64, align 8
  %size_of_cell = alloca i64, align 8
  %size_of_type = alloca i64, align 8
  %cell_index = alloca i64, align 8
  %data_index = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  store ptr %1, ptr %3, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %4, i32 0, i32 3
  %6 = load i64, ptr %5, align 8
  store i64 %6, ptr %elements_per_cell, align 8
  %7 = load ptr, ptr %3, align 8
  %8 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %7, i32 0, i32 2
  %9 = load i64, ptr %8, align 8
  store i64 %9, ptr %size_of_cell, align 8
  %10 = load ptr, ptr %3, align 8
  %11 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %10, i32 0, i32 0
  %12 = load i64, ptr %11, align 8
  store i64 %12, ptr %size_of_type, align 8
  %13 = load i64, ptr %elements_per_cell, align 8
  %14 = udiv i64 2, %13
  store i64 %14, ptr %cell_index, align 8
  %15 = load i64, ptr %elements_per_cell, align 8
  %16 = urem i64 2, %15
  store i64 %16, ptr %data_index, align 8
  %17 = load i64, ptr %cell_index, align 8
  %18 = load i64, ptr %size_of_cell, align 8
  %19 = mul i64 %17, %18
  %20 = add i64 %0, %19
  %21 = load i64, ptr %data_index, align 8
  %22 = load i64, ptr %size_of_type, align 8
  %23 = mul i64 %21, %22
  %24 = add i64 %20, %23
  ret i64 %24
}

define i8 @"runtime::_make_dynamic_array_len_cap"(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr %5, ptr %6, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca %"runtime::Allocator", align 8
  %13 = alloca { ptr, i64 }, align 8
  %14 = alloca ptr, align 8
  %15 = alloca i64, align 8
  %16 = alloca i64, align 8
  %17 = alloca i64, align 8
  %18 = alloca i64, align 8
  %19 = alloca %"runtime::Allocator", align 8
  %err = alloca i8, align 1
  %20 = alloca { ptr, i64 }, align 8
  %21 = alloca { { ptr, i64 }, i8 }, align 8
  %data = alloca { ptr, i64 }, align 8
  %use_zero = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %14, align 8
  store i64 %1, ptr %15, align 8
  store i64 %2, ptr %16, align 8
  store i64 %3, ptr %17, align 8
  store i64 %4, ptr %18, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %19, ptr %5, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  store i64 %3, ptr %7, align 8
  store i64 %4, ptr %8, align 8
  %22 = icmp sle i64 0, %3
  %23 = zext i1 %22 to i8
  br i1 %22, label %cmp.and.i, label %if.done.i4

cmp.and.i:                                        ; preds = %entry
  %24 = icmp sle i64 %3, %4
  %25 = zext i1 %24 to i8
  br i1 %24, label %"runtime::make_dynamic_array_error_loc.exit", label %if.done.i4

if.done.i4:                                       ; preds = %cmp.and.i, %entry
  call void @"runtime::make_dynamic_array_error_loc.handle_error-0"(ptr %6, i64 %3, i64 %4)
  unreachable

"runtime::make_dynamic_array_error_loc.exit":     ; preds = %cmp.and.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  %26 = load ptr, ptr %14, align 8
  %27 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %26, i32 0, i32 3
  %28 = load %"runtime::Allocator", ptr %19, align 8
  store %"runtime::Allocator" %28, ptr %27, align 8
  %29 = mul i64 %1, %4
  call void @llvm.memset.inline.p0.i64(ptr %20, i8 0, i64 16, i1 false)
  call void @llvm.experimental.noalias.scope.decl(metadata !93)
  call void @llvm.experimental.noalias.scope.decl(metadata !96)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 16, ptr %12)
  call void @llvm.lifetime.start.p0(i64 16, ptr %13)
  store i64 %29, ptr %10, align 8, !noalias !98
  store i64 %2, ptr %11, align 8, !noalias !98
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %12, ptr %19, i64 16, i1 false), !noalias !98
  call void @llvm.lifetime.start.p0(i64 8, ptr %9), !noalias !98
  store i64 %2, ptr %9, align 8, !noalias !98
  %30 = icmp sle i64 %2, 0
  %31 = zext i1 %30 to i8
  br i1 %30, label %if.then.i.i, label %if.done.i.i

if.then.i.i:                                      ; preds = %"runtime::make_dynamic_array_error_loc.exit"
  call void @llvm.lifetime.end.p0(i64 8, ptr %9), !noalias !98
  br label %"runtime::is_power_of_two_int.exit.i"

if.done.i.i:                                      ; preds = %"runtime::make_dynamic_array_error_loc.exit"
  %32 = sub i64 %2, 1
  %33 = and i64 %2, %32
  %34 = icmp eq i64 %33, 0
  %35 = zext i1 %34 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %9), !noalias !98
  br label %"runtime::is_power_of_two_int.exit.i"

"runtime::is_power_of_two_int.exit.i":            ; preds = %if.done.i.i, %if.then.i.i
  %36 = phi i8 [ 0, %if.then.i.i ], [ %35, %if.done.i.i ]
  %37 = icmp ne i8 %36, 0
  call void @"runtime::assert"(i1 zeroext %37, ptr @"ggv$runtime::mem_alloc_bytes$1", ptr %6, ptr nonnull %__.context_ptr), !noalias !93
  %38 = icmp eq i64 %29, 0
  %39 = zext i1 %38 to i8
  br i1 %38, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %"runtime::is_power_of_two_int.exit.i"
  %40 = load ptr, ptr %12, align 8, !noalias !98
  %41 = icmp eq ptr %40, null
  %42 = zext i1 %41 to i8
  br i1 %41, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %"runtime::is_power_of_two_int.exit.i"
  store { ptr, i64 } zeroinitializer, ptr %20, align 8, !alias.scope !93, !noalias !96
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  br label %"runtime::mem_alloc_bytes.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %43 = load ptr, ptr %12, align 8, !noalias !98
  %44 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %45 = load ptr, ptr %44, align 8, !noalias !98
  call void @llvm.memset.inline.p0.i64(ptr %13, i8 0, i64 16, i1 false), !noalias !98
  %46 = call i8 %43(ptr %45, i8 0, i64 %29, i64 %2, ptr null, i64 0, ptr %6, ptr %13, ptr nonnull %__.context_ptr), !noalias !93
  %47 = load { ptr, i64 }, ptr %13, align 8, !noalias !98
  store { ptr, i64 } %47, ptr %20, align 8, !alias.scope !93, !noalias !96
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  br label %"runtime::mem_alloc_bytes.exit"

"runtime::mem_alloc_bytes.exit":                  ; preds = %if.done.i, %if.then.i
  %48 = phi i8 [ 0, %if.then.i ], [ %46, %if.done.i ]
  %49 = load { ptr, i64 }, ptr %20, align 8
  %50 = icmp eq i8 %48, 0
  br i1 %50, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %"runtime::mem_alloc_bytes.exit"
  store i8 %48, ptr %err, align 1
  %51 = load i8, ptr %err, align 1
  store i8 %51, ptr %err, align 1
  ret i8 %51

or_return.continue:                               ; preds = %"runtime::mem_alloc_bytes.exit"
  store { ptr, i64 } %49, ptr %data, align 8
  %52 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %53 = load ptr, ptr %52, align 8
  %54 = icmp eq ptr %53, null
  %55 = zext i1 %54 to i8
  %56 = icmp ne i8 %55, 0
  br i1 %56, label %logical.cmp.rhs, label %logical.cmp.done

logical.cmp.rhs:                                  ; preds = %or_return.continue
  %57 = icmp ne i64 %1, 0
  %58 = zext i1 %57 to i8
  %59 = icmp ne i8 %58, 0
  br label %logical.cmp.done

logical.cmp.done:                                 ; preds = %logical.cmp.rhs, %or_return.continue
  %60 = phi i1 [ false, %or_return.continue ], [ %59, %logical.cmp.rhs ]
  %61 = zext i1 %60 to i8
  store i8 %61, ptr %use_zero, align 1
  %62 = load ptr, ptr %14, align 8
  %63 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %62, i32 0, i32 0
  %64 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %65 = load ptr, ptr %64, align 8
  store ptr %65, ptr %63, align 8
  %66 = load ptr, ptr %14, align 8
  %67 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %66, i32 0, i32 1
  %68 = load i8, ptr %use_zero, align 1
  %69 = icmp ne i8 %68, 0
  br i1 %69, label %if.then, label %if.else

if.then:                                          ; preds = %logical.cmp.done
  br label %if.done

if.else:                                          ; preds = %logical.cmp.done
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  %70 = phi i64 [ 0, %if.then ], [ %3, %if.else ]
  store i64 %70, ptr %67, align 8
  %71 = load ptr, ptr %14, align 8
  %72 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %71, i32 0, i32 2
  %73 = load i8, ptr %use_zero, align 1
  %74 = icmp ne i8 %73, 0
  br i1 %74, label %if.then1, label %if.else2

if.then1:                                         ; preds = %if.done
  br label %if.done3

if.else2:                                         ; preds = %if.done
  br label %if.done3

if.done3:                                         ; preds = %if.else2, %if.then1
  %75 = phi i64 [ 0, %if.then1 ], [ %4, %if.else2 ]
  store i64 %75, ptr %72, align 8
  %76 = load ptr, ptr %14, align 8
  %77 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %76, i32 0, i32 3
  %78 = load %"runtime::Allocator", ptr %19, align 8
  store %"runtime::Allocator" %78, ptr %77, align 8
  %79 = load i8, ptr %err, align 1
  store i8 %79, ptr %err, align 1
  ret i8 %79
}

; Function Attrs: alwaysinline
define i64 @"runtime::map_total_allocation_size"(i64 %0, ptr %1) #1 {
decls:
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca ptr, align 8
  %9 = alloca i64, align 8
  %elements_per_cell.i37 = alloca i64, align 8
  %size_of_cell.i38 = alloca i64, align 8
  %cell_index.i39 = alloca i64, align 8
  %data_index.i40 = alloca i64, align 8
  %size_of_type.i41 = alloca i64, align 8
  %cell_index2.i42 = alloca i64, align 8
  %data_index3.i43 = alloca i64, align 8
  %size_of_type4.i44 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca ptr, align 8
  %12 = alloca i64, align 8
  %elements_per_cell.i25 = alloca i64, align 8
  %size_of_cell.i26 = alloca i64, align 8
  %cell_index.i27 = alloca i64, align 8
  %data_index.i28 = alloca i64, align 8
  %size_of_type.i29 = alloca i64, align 8
  %cell_index2.i30 = alloca i64, align 8
  %data_index3.i31 = alloca i64, align 8
  %size_of_type4.i32 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca ptr, align 8
  %15 = alloca i64, align 8
  %elements_per_cell.i13 = alloca i64, align 8
  %size_of_cell.i14 = alloca i64, align 8
  %cell_index.i15 = alloca i64, align 8
  %data_index.i16 = alloca i64, align 8
  %size_of_type.i17 = alloca i64, align 8
  %cell_index2.i18 = alloca i64, align 8
  %data_index3.i19 = alloca i64, align 8
  %size_of_type4.i20 = alloca i64, align 8
  %16 = alloca i64, align 8
  %17 = alloca ptr, align 8
  %18 = alloca i64, align 8
  %elements_per_cell.i1 = alloca i64, align 8
  %size_of_cell.i2 = alloca i64, align 8
  %cell_index.i3 = alloca i64, align 8
  %data_index.i4 = alloca i64, align 8
  %size_of_type.i5 = alloca i64, align 8
  %cell_index2.i6 = alloca i64, align 8
  %data_index3.i7 = alloca i64, align 8
  %size_of_type4.i8 = alloca i64, align 8
  %19 = alloca i64, align 8
  %20 = alloca ptr, align 8
  %21 = alloca i64, align 8
  %elements_per_cell.i = alloca i64, align 8
  %size_of_cell.i = alloca i64, align 8
  %cell_index.i = alloca i64, align 8
  %data_index.i = alloca i64, align 8
  %size_of_type.i = alloca i64, align 8
  %cell_index2.i = alloca i64, align 8
  %data_index3.i = alloca i64, align 8
  %size_of_type4.i = alloca i64, align 8
  %22 = alloca i64, align 8
  %23 = alloca ptr, align 8
  %INFO_HS = alloca ptr, align 8
  %size = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %22, align 8
  store ptr %1, ptr %23, align 8
  store ptr @"ggv$map_cell_info-13197927915248882629", ptr %INFO_HS, align 8
  store i64 0, ptr %size, align 8
  %24 = load i64, ptr %size, align 8
  %25 = load ptr, ptr %23, align 8
  %26 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !99)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i37)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i38)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i39)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i40)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i41)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i42)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i43)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i44)
  store i64 %24, ptr %7, align 8, !noalias !99
  store ptr %27, ptr %8, align 8, !noalias !99
  store i64 %0, ptr %9, align 8, !noalias !99
  %28 = load ptr, ptr %8, align 8, !noalias !99
  %29 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %28, i32 0, i32 3
  %30 = load i64, ptr %29, align 8
  store i64 %30, ptr %elements_per_cell.i37, align 8, !noalias !99
  %31 = load ptr, ptr %8, align 8, !noalias !99
  %32 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %31, i32 0, i32 2
  %33 = load i64, ptr %32, align 8
  store i64 %33, ptr %size_of_cell.i38, align 8, !noalias !99
  %34 = load i64, ptr %elements_per_cell.i37, align 8, !noalias !99
  switch i64 %34, label %switch.default.body.i47 [
    i64 1, label %switch.case.body.i46
    i64 2, label %switch.case.body1.i45
  ]

switch.case.body.i46:                             ; preds = %entry
  %35 = load i64, ptr %size_of_cell.i38, align 8, !noalias !99
  %36 = mul i64 %0, %35
  %37 = add i64 %24, %36
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i37)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i38)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i39)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i40)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i41)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i42)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i43)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i44)
  br label %"runtime::map_cell_index_dynamic.exit48"

switch.case.body1.i45:                            ; preds = %entry
  %38 = lshr i64 %0, 1
  store i64 %38, ptr %cell_index.i39, align 8, !noalias !99
  %39 = and i64 %0, 1
  store i64 %39, ptr %data_index.i40, align 8, !noalias !99
  %40 = load ptr, ptr %8, align 8, !noalias !99
  %41 = load i64, ptr %40, align 8
  store i64 %41, ptr %size_of_type.i41, align 8, !noalias !99
  %42 = load i64, ptr %cell_index.i39, align 8, !noalias !99
  %43 = load i64, ptr %size_of_cell.i38, align 8, !noalias !99
  %44 = mul i64 %42, %43
  %45 = add i64 %24, %44
  %46 = load i64, ptr %data_index.i40, align 8, !noalias !99
  %47 = load i64, ptr %size_of_type.i41, align 8, !noalias !99
  %48 = mul i64 %46, %47
  %49 = add i64 %45, %48
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i37)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i38)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i39)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i40)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i41)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i42)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i43)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i44)
  br label %"runtime::map_cell_index_dynamic.exit48"

switch.default.body.i47:                          ; preds = %entry
  %50 = load i64, ptr %elements_per_cell.i37, align 8, !noalias !99
  %51 = udiv i64 %0, %50
  store i64 %51, ptr %cell_index2.i42, align 8, !noalias !99
  %52 = load i64, ptr %elements_per_cell.i37, align 8, !noalias !99
  %53 = urem i64 %0, %52
  store i64 %53, ptr %data_index3.i43, align 8, !noalias !99
  %54 = load ptr, ptr %8, align 8, !noalias !99
  %55 = load i64, ptr %54, align 8
  store i64 %55, ptr %size_of_type4.i44, align 8, !noalias !99
  %56 = load i64, ptr %cell_index2.i42, align 8, !noalias !99
  %57 = load i64, ptr %size_of_cell.i38, align 8, !noalias !99
  %58 = mul i64 %56, %57
  %59 = add i64 %24, %58
  %60 = load i64, ptr %data_index3.i43, align 8, !noalias !99
  %61 = load i64, ptr %size_of_type4.i44, align 8, !noalias !99
  %62 = mul i64 %60, %61
  %63 = add i64 %59, %62
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i37)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i38)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i39)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i40)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i41)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i42)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i43)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i44)
  br label %"runtime::map_cell_index_dynamic.exit48"

"runtime::map_cell_index_dynamic.exit48":         ; preds = %switch.default.body.i47, %switch.case.body1.i45, %switch.case.body.i46
  %64 = phi i64 [ %37, %switch.case.body.i46 ], [ %49, %switch.case.body1.i45 ], [ %63, %switch.default.body.i47 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %2)
  store i64 %64, ptr %2, align 8
  %65 = add i64 %64, 63
  %66 = and i64 %65, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  store i64 %66, ptr %size, align 8
  %67 = load i64, ptr %size, align 8
  %68 = load ptr, ptr %23, align 8
  %69 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %68, i32 0, i32 1
  %70 = load ptr, ptr %69, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !102)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %12)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i25)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i26)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i27)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i28)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i29)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i30)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i31)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i32)
  store i64 %67, ptr %10, align 8, !noalias !102
  store ptr %70, ptr %11, align 8, !noalias !102
  store i64 %0, ptr %12, align 8, !noalias !102
  %71 = load ptr, ptr %11, align 8, !noalias !102
  %72 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %71, i32 0, i32 3
  %73 = load i64, ptr %72, align 8
  store i64 %73, ptr %elements_per_cell.i25, align 8, !noalias !102
  %74 = load ptr, ptr %11, align 8, !noalias !102
  %75 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %74, i32 0, i32 2
  %76 = load i64, ptr %75, align 8
  store i64 %76, ptr %size_of_cell.i26, align 8, !noalias !102
  %77 = load i64, ptr %elements_per_cell.i25, align 8, !noalias !102
  switch i64 %77, label %switch.default.body.i35 [
    i64 1, label %switch.case.body.i34
    i64 2, label %switch.case.body1.i33
  ]

switch.case.body.i34:                             ; preds = %"runtime::map_cell_index_dynamic.exit48"
  %78 = load i64, ptr %size_of_cell.i26, align 8, !noalias !102
  %79 = mul i64 %0, %78
  %80 = add i64 %67, %79
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i25)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i26)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i27)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i28)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i29)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i30)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i31)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i32)
  br label %"runtime::map_cell_index_dynamic.exit36"

switch.case.body1.i33:                            ; preds = %"runtime::map_cell_index_dynamic.exit48"
  %81 = lshr i64 %0, 1
  store i64 %81, ptr %cell_index.i27, align 8, !noalias !102
  %82 = and i64 %0, 1
  store i64 %82, ptr %data_index.i28, align 8, !noalias !102
  %83 = load ptr, ptr %11, align 8, !noalias !102
  %84 = load i64, ptr %83, align 8
  store i64 %84, ptr %size_of_type.i29, align 8, !noalias !102
  %85 = load i64, ptr %cell_index.i27, align 8, !noalias !102
  %86 = load i64, ptr %size_of_cell.i26, align 8, !noalias !102
  %87 = mul i64 %85, %86
  %88 = add i64 %67, %87
  %89 = load i64, ptr %data_index.i28, align 8, !noalias !102
  %90 = load i64, ptr %size_of_type.i29, align 8, !noalias !102
  %91 = mul i64 %89, %90
  %92 = add i64 %88, %91
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i25)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i26)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i27)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i28)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i29)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i30)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i31)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i32)
  br label %"runtime::map_cell_index_dynamic.exit36"

switch.default.body.i35:                          ; preds = %"runtime::map_cell_index_dynamic.exit48"
  %93 = load i64, ptr %elements_per_cell.i25, align 8, !noalias !102
  %94 = udiv i64 %0, %93
  store i64 %94, ptr %cell_index2.i30, align 8, !noalias !102
  %95 = load i64, ptr %elements_per_cell.i25, align 8, !noalias !102
  %96 = urem i64 %0, %95
  store i64 %96, ptr %data_index3.i31, align 8, !noalias !102
  %97 = load ptr, ptr %11, align 8, !noalias !102
  %98 = load i64, ptr %97, align 8
  store i64 %98, ptr %size_of_type4.i32, align 8, !noalias !102
  %99 = load i64, ptr %cell_index2.i30, align 8, !noalias !102
  %100 = load i64, ptr %size_of_cell.i26, align 8, !noalias !102
  %101 = mul i64 %99, %100
  %102 = add i64 %67, %101
  %103 = load i64, ptr %data_index3.i31, align 8, !noalias !102
  %104 = load i64, ptr %size_of_type4.i32, align 8, !noalias !102
  %105 = mul i64 %103, %104
  %106 = add i64 %102, %105
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i25)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i26)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i27)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i28)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i29)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i30)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i31)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i32)
  br label %"runtime::map_cell_index_dynamic.exit36"

"runtime::map_cell_index_dynamic.exit36":         ; preds = %switch.default.body.i35, %switch.case.body1.i33, %switch.case.body.i34
  %107 = phi i64 [ %80, %switch.case.body.i34 ], [ %92, %switch.case.body1.i33 ], [ %106, %switch.default.body.i35 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  store i64 %107, ptr %3, align 8
  %108 = add i64 %107, 63
  %109 = and i64 %108, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  store i64 %109, ptr %size, align 8
  %110 = load i64, ptr %size, align 8
  %111 = load ptr, ptr %INFO_HS, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !105)
  call void @llvm.lifetime.start.p0(i64 8, ptr %13)
  call void @llvm.lifetime.start.p0(i64 8, ptr %14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i13)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i15)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i16)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i17)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i18)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i19)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i20)
  store i64 %110, ptr %13, align 8, !noalias !105
  store ptr %111, ptr %14, align 8, !noalias !105
  store i64 %0, ptr %15, align 8, !noalias !105
  %112 = load ptr, ptr %14, align 8, !noalias !105
  %113 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %112, i32 0, i32 3
  %114 = load i64, ptr %113, align 8
  store i64 %114, ptr %elements_per_cell.i13, align 8, !noalias !105
  %115 = load ptr, ptr %14, align 8, !noalias !105
  %116 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %115, i32 0, i32 2
  %117 = load i64, ptr %116, align 8
  store i64 %117, ptr %size_of_cell.i14, align 8, !noalias !105
  %118 = load i64, ptr %elements_per_cell.i13, align 8, !noalias !105
  switch i64 %118, label %switch.default.body.i23 [
    i64 1, label %switch.case.body.i22
    i64 2, label %switch.case.body1.i21
  ]

switch.case.body.i22:                             ; preds = %"runtime::map_cell_index_dynamic.exit36"
  %119 = load i64, ptr %size_of_cell.i14, align 8, !noalias !105
  %120 = mul i64 %0, %119
  %121 = add i64 %110, %120
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i20)
  br label %"runtime::map_cell_index_dynamic.exit24"

switch.case.body1.i21:                            ; preds = %"runtime::map_cell_index_dynamic.exit36"
  %122 = lshr i64 %0, 1
  store i64 %122, ptr %cell_index.i15, align 8, !noalias !105
  %123 = and i64 %0, 1
  store i64 %123, ptr %data_index.i16, align 8, !noalias !105
  %124 = load ptr, ptr %14, align 8, !noalias !105
  %125 = load i64, ptr %124, align 8
  store i64 %125, ptr %size_of_type.i17, align 8, !noalias !105
  %126 = load i64, ptr %cell_index.i15, align 8, !noalias !105
  %127 = load i64, ptr %size_of_cell.i14, align 8, !noalias !105
  %128 = mul i64 %126, %127
  %129 = add i64 %110, %128
  %130 = load i64, ptr %data_index.i16, align 8, !noalias !105
  %131 = load i64, ptr %size_of_type.i17, align 8, !noalias !105
  %132 = mul i64 %130, %131
  %133 = add i64 %129, %132
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i20)
  br label %"runtime::map_cell_index_dynamic.exit24"

switch.default.body.i23:                          ; preds = %"runtime::map_cell_index_dynamic.exit36"
  %134 = load i64, ptr %elements_per_cell.i13, align 8, !noalias !105
  %135 = udiv i64 %0, %134
  store i64 %135, ptr %cell_index2.i18, align 8, !noalias !105
  %136 = load i64, ptr %elements_per_cell.i13, align 8, !noalias !105
  %137 = urem i64 %0, %136
  store i64 %137, ptr %data_index3.i19, align 8, !noalias !105
  %138 = load ptr, ptr %14, align 8, !noalias !105
  %139 = load i64, ptr %138, align 8
  store i64 %139, ptr %size_of_type4.i20, align 8, !noalias !105
  %140 = load i64, ptr %cell_index2.i18, align 8, !noalias !105
  %141 = load i64, ptr %size_of_cell.i14, align 8, !noalias !105
  %142 = mul i64 %140, %141
  %143 = add i64 %110, %142
  %144 = load i64, ptr %data_index3.i19, align 8, !noalias !105
  %145 = load i64, ptr %size_of_type4.i20, align 8, !noalias !105
  %146 = mul i64 %144, %145
  %147 = add i64 %143, %146
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i20)
  br label %"runtime::map_cell_index_dynamic.exit24"

"runtime::map_cell_index_dynamic.exit24":         ; preds = %switch.default.body.i23, %switch.case.body1.i21, %switch.case.body.i22
  %148 = phi i64 [ %121, %switch.case.body.i22 ], [ %133, %switch.case.body1.i21 ], [ %147, %switch.default.body.i23 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  store i64 %148, ptr %4, align 8
  %149 = add i64 %148, 63
  %150 = and i64 %149, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  store i64 %150, ptr %size, align 8
  %151 = load i64, ptr %size, align 8
  %152 = load ptr, ptr %23, align 8
  %153 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %152, i32 0, i32 0
  %154 = load ptr, ptr %153, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !108)
  call void @llvm.lifetime.start.p0(i64 8, ptr %16)
  call void @llvm.lifetime.start.p0(i64 8, ptr %17)
  call void @llvm.lifetime.start.p0(i64 8, ptr %18)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i1)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i8)
  store i64 %151, ptr %16, align 8, !noalias !108
  store ptr %154, ptr %17, align 8, !noalias !108
  store i64 2, ptr %18, align 8, !noalias !108
  %155 = load ptr, ptr %17, align 8, !noalias !108
  %156 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %155, i32 0, i32 3
  %157 = load i64, ptr %156, align 8
  store i64 %157, ptr %elements_per_cell.i1, align 8, !noalias !108
  %158 = load ptr, ptr %17, align 8, !noalias !108
  %159 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %158, i32 0, i32 2
  %160 = load i64, ptr %159, align 8
  store i64 %160, ptr %size_of_cell.i2, align 8, !noalias !108
  %161 = load i64, ptr %elements_per_cell.i1, align 8, !noalias !108
  switch i64 %161, label %switch.default.body.i11 [
    i64 1, label %switch.case.body.i10
    i64 2, label %switch.case.body1.i9
  ]

switch.case.body.i10:                             ; preds = %"runtime::map_cell_index_dynamic.exit24"
  %162 = load i64, ptr %size_of_cell.i2, align 8, !noalias !108
  %163 = mul i64 2, %162
  %164 = add i64 %151, %163
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i1)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i8)
  br label %"runtime::map_cell_index_dynamic.exit12"

switch.case.body1.i9:                             ; preds = %"runtime::map_cell_index_dynamic.exit24"
  store i64 1, ptr %cell_index.i3, align 8, !noalias !108
  store i64 0, ptr %data_index.i4, align 8, !noalias !108
  %165 = load ptr, ptr %17, align 8, !noalias !108
  %166 = load i64, ptr %165, align 8
  store i64 %166, ptr %size_of_type.i5, align 8, !noalias !108
  %167 = load i64, ptr %cell_index.i3, align 8, !noalias !108
  %168 = load i64, ptr %size_of_cell.i2, align 8, !noalias !108
  %169 = mul i64 %167, %168
  %170 = add i64 %151, %169
  %171 = load i64, ptr %data_index.i4, align 8, !noalias !108
  %172 = load i64, ptr %size_of_type.i5, align 8, !noalias !108
  %173 = mul i64 %171, %172
  %174 = add i64 %170, %173
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i1)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i8)
  br label %"runtime::map_cell_index_dynamic.exit12"

switch.default.body.i11:                          ; preds = %"runtime::map_cell_index_dynamic.exit24"
  %175 = load i64, ptr %elements_per_cell.i1, align 8, !noalias !108
  %176 = udiv i64 2, %175
  store i64 %176, ptr %cell_index2.i6, align 8, !noalias !108
  %177 = load i64, ptr %elements_per_cell.i1, align 8, !noalias !108
  %178 = urem i64 2, %177
  store i64 %178, ptr %data_index3.i7, align 8, !noalias !108
  %179 = load ptr, ptr %17, align 8, !noalias !108
  %180 = load i64, ptr %179, align 8
  store i64 %180, ptr %size_of_type4.i8, align 8, !noalias !108
  %181 = load i64, ptr %cell_index2.i6, align 8, !noalias !108
  %182 = load i64, ptr %size_of_cell.i2, align 8, !noalias !108
  %183 = mul i64 %181, %182
  %184 = add i64 %151, %183
  %185 = load i64, ptr %data_index3.i7, align 8, !noalias !108
  %186 = load i64, ptr %size_of_type4.i8, align 8, !noalias !108
  %187 = mul i64 %185, %186
  %188 = add i64 %184, %187
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i1)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i8)
  br label %"runtime::map_cell_index_dynamic.exit12"

"runtime::map_cell_index_dynamic.exit12":         ; preds = %switch.default.body.i11, %switch.case.body1.i9, %switch.case.body.i10
  %189 = phi i64 [ %164, %switch.case.body.i10 ], [ %174, %switch.case.body1.i9 ], [ %188, %switch.default.body.i11 ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  store i64 %189, ptr %5, align 8
  %190 = add i64 %189, 63
  %191 = and i64 %190, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  store i64 %191, ptr %size, align 8
  %192 = load i64, ptr %size, align 8
  %193 = load ptr, ptr %23, align 8
  %194 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %193, i32 0, i32 1
  %195 = load ptr, ptr %194, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !111)
  call void @llvm.lifetime.start.p0(i64 8, ptr %19)
  call void @llvm.lifetime.start.p0(i64 8, ptr %20)
  call void @llvm.lifetime.start.p0(i64 8, ptr %21)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i)
  store i64 %192, ptr %19, align 8, !noalias !111
  store ptr %195, ptr %20, align 8, !noalias !111
  store i64 2, ptr %21, align 8, !noalias !111
  %196 = load ptr, ptr %20, align 8, !noalias !111
  %197 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %196, i32 0, i32 3
  %198 = load i64, ptr %197, align 8
  store i64 %198, ptr %elements_per_cell.i, align 8, !noalias !111
  %199 = load ptr, ptr %20, align 8, !noalias !111
  %200 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %199, i32 0, i32 2
  %201 = load i64, ptr %200, align 8
  store i64 %201, ptr %size_of_cell.i, align 8, !noalias !111
  %202 = load i64, ptr %elements_per_cell.i, align 8, !noalias !111
  switch i64 %202, label %switch.default.body.i [
    i64 1, label %switch.case.body.i
    i64 2, label %switch.case.body1.i
  ]

switch.case.body.i:                               ; preds = %"runtime::map_cell_index_dynamic.exit12"
  %203 = load i64, ptr %size_of_cell.i, align 8, !noalias !111
  %204 = mul i64 2, %203
  %205 = add i64 %192, %204
  call void @llvm.lifetime.end.p0(i64 8, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i)
  br label %"runtime::map_cell_index_dynamic.exit"

switch.case.body1.i:                              ; preds = %"runtime::map_cell_index_dynamic.exit12"
  store i64 1, ptr %cell_index.i, align 8, !noalias !111
  store i64 0, ptr %data_index.i, align 8, !noalias !111
  %206 = load ptr, ptr %20, align 8, !noalias !111
  %207 = load i64, ptr %206, align 8
  store i64 %207, ptr %size_of_type.i, align 8, !noalias !111
  %208 = load i64, ptr %cell_index.i, align 8, !noalias !111
  %209 = load i64, ptr %size_of_cell.i, align 8, !noalias !111
  %210 = mul i64 %208, %209
  %211 = add i64 %192, %210
  %212 = load i64, ptr %data_index.i, align 8, !noalias !111
  %213 = load i64, ptr %size_of_type.i, align 8, !noalias !111
  %214 = mul i64 %212, %213
  %215 = add i64 %211, %214
  call void @llvm.lifetime.end.p0(i64 8, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i)
  br label %"runtime::map_cell_index_dynamic.exit"

switch.default.body.i:                            ; preds = %"runtime::map_cell_index_dynamic.exit12"
  %216 = load i64, ptr %elements_per_cell.i, align 8, !noalias !111
  %217 = udiv i64 2, %216
  store i64 %217, ptr %cell_index2.i, align 8, !noalias !111
  %218 = load i64, ptr %elements_per_cell.i, align 8, !noalias !111
  %219 = urem i64 2, %218
  store i64 %219, ptr %data_index3.i, align 8, !noalias !111
  %220 = load ptr, ptr %20, align 8, !noalias !111
  %221 = load i64, ptr %220, align 8
  store i64 %221, ptr %size_of_type4.i, align 8, !noalias !111
  %222 = load i64, ptr %cell_index2.i, align 8, !noalias !111
  %223 = load i64, ptr %size_of_cell.i, align 8, !noalias !111
  %224 = mul i64 %222, %223
  %225 = add i64 %192, %224
  %226 = load i64, ptr %data_index3.i, align 8, !noalias !111
  %227 = load i64, ptr %size_of_type4.i, align 8, !noalias !111
  %228 = mul i64 %226, %227
  %229 = add i64 %225, %228
  call void @llvm.lifetime.end.p0(i64 8, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i)
  br label %"runtime::map_cell_index_dynamic.exit"

"runtime::map_cell_index_dynamic.exit":           ; preds = %switch.default.body.i, %switch.case.body1.i, %switch.case.body.i
  %230 = phi i64 [ %205, %switch.case.body.i ], [ %215, %switch.case.body1.i ], [ %229, %switch.default.body.i ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  store i64 %230, ptr %6, align 8
  %231 = add i64 %230, 63
  %232 = and i64 %231, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  store i64 %232, ptr %size, align 8
  %233 = load i64, ptr %size, align 8
  ret i64 %233
}

declare void @"__$startup_runtime"(ptr noalias nocapture nonnull)

declare void @"__$cleanup_runtime"(ptr noalias nocapture nonnull)

define ptr @"runtime::type_info_base"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %base = alloca ptr, align 8
  %2 = alloca [48 x i8], align 8
  %i = alloca { [9 x i64], i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp eq ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret ptr null

if.done:                                          ; preds = %entry
  store ptr %0, ptr %base, align 8
  br label %for.body

for.body:                                         ; preds = %typeswitch.done, %if.done
  %6 = load ptr, ptr %base, align 8
  %7 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %6, i32 0, i32 5
  %8 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %7, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  switch i64 %9, label %typeswitch.default.body [
    i64 1, label %typeswitch.body
  ]

typeswitch.body:                                  ; preds = %for.body
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %7, i64 48, i1 false)
  %10 = getelementptr inbounds nuw %"runtime::Type_Info_Named", ptr %2, i32 0, i32 1
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %base, align 8
  br label %typeswitch.done

typeswitch.default.body:                          ; preds = %for.body
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %i, ptr align 1 %7, i64 80, i1 false)
  br label %for.done

unreachable:                                      ; No predecessors!
  br label %typeswitch.done

typeswitch.done:                                  ; preds = %unreachable, %typeswitch.body
  br label %for.body

for.done:                                         ; preds = %typeswitch.default.body
  %12 = load ptr, ptr %base, align 8
  ret ptr %12
}

define ptr @"runtime::type_info_core"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %base = alloca ptr, align 8
  %2 = alloca [56 x i8], align 8
  %i = alloca { [9 x i64], i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp eq ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret ptr null

if.done:                                          ; preds = %entry
  store ptr %0, ptr %base, align 8
  br label %for.body

for.body:                                         ; preds = %typeswitch.done, %if.done
  %6 = load ptr, ptr %base, align 8
  %7 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %6, i32 0, i32 5
  %8 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %7, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  switch i64 %9, label %typeswitch.default.body [
    i64 1, label %typeswitch.body
    i64 21, label %typeswitch.body1
    i64 27, label %typeswitch.body2
  ]

typeswitch.body:                                  ; preds = %for.body
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %7, i64 48, i1 false)
  %10 = getelementptr inbounds nuw %"runtime::Type_Info_Named", ptr %2, i32 0, i32 1
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %base, align 8
  br label %typeswitch.done

typeswitch.body1:                                 ; preds = %for.body
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %7, i64 40, i1 false)
  %12 = getelementptr inbounds nuw %"runtime::Type_Info_Enum", ptr %2, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %base, align 8
  br label %typeswitch.done

typeswitch.body2:                                 ; preds = %for.body
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %7, i64 56, i1 false)
  %14 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Field", ptr %2, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %base, align 8
  br label %typeswitch.done

typeswitch.default.body:                          ; preds = %for.body
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %i, ptr align 1 %7, i64 80, i1 false)
  br label %for.done

unreachable:                                      ; No predecessors!
  br label %typeswitch.done

typeswitch.done:                                  ; preds = %unreachable, %typeswitch.body2, %typeswitch.body1, %typeswitch.body
  br label %for.body

for.done:                                         ; preds = %typeswitch.default.body
  %16 = load ptr, ptr %base, align 8
  ret ptr %16
}

define i8 @"runtime::map_alloc_dynamic"(ptr %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca ptr, align 8
  %11 = alloca ptr, align 8
  %12 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca ptr, align 8
  %15 = alloca i64, align 8
  %hs.i = alloca ptr, align 8
  %16 = alloca i64, align 8
  %17 = alloca ptr, align 8
  %18 = alloca i64, align 8
  %elements_per_cell.i37.i = alloca i64, align 8
  %size_of_cell.i38.i = alloca i64, align 8
  %cell_index.i39.i = alloca i64, align 8
  %data_index.i40.i = alloca i64, align 8
  %size_of_type.i41.i = alloca i64, align 8
  %cell_index2.i42.i = alloca i64, align 8
  %data_index3.i43.i = alloca i64, align 8
  %size_of_type4.i44.i = alloca i64, align 8
  %19 = alloca i64, align 8
  %20 = alloca ptr, align 8
  %21 = alloca i64, align 8
  %elements_per_cell.i25.i = alloca i64, align 8
  %size_of_cell.i26.i = alloca i64, align 8
  %cell_index.i27.i = alloca i64, align 8
  %data_index.i28.i = alloca i64, align 8
  %size_of_type.i29.i = alloca i64, align 8
  %cell_index2.i30.i = alloca i64, align 8
  %data_index3.i31.i = alloca i64, align 8
  %size_of_type4.i32.i = alloca i64, align 8
  %22 = alloca i64, align 8
  %23 = alloca ptr, align 8
  %24 = alloca i64, align 8
  %elements_per_cell.i13.i = alloca i64, align 8
  %size_of_cell.i14.i = alloca i64, align 8
  %cell_index.i15.i = alloca i64, align 8
  %data_index.i16.i = alloca i64, align 8
  %size_of_type.i17.i = alloca i64, align 8
  %cell_index2.i18.i = alloca i64, align 8
  %data_index3.i19.i = alloca i64, align 8
  %size_of_type4.i20.i = alloca i64, align 8
  %25 = alloca i64, align 8
  %26 = alloca ptr, align 8
  %27 = alloca i64, align 8
  %elements_per_cell.i1.i = alloca i64, align 8
  %size_of_cell.i2.i = alloca i64, align 8
  %cell_index.i3.i = alloca i64, align 8
  %data_index.i4.i = alloca i64, align 8
  %size_of_type.i5.i = alloca i64, align 8
  %cell_index2.i6.i = alloca i64, align 8
  %data_index3.i7.i = alloca i64, align 8
  %size_of_type4.i8.i = alloca i64, align 8
  %28 = alloca i64, align 8
  %29 = alloca ptr, align 8
  %30 = alloca i64, align 8
  %elements_per_cell.i.i = alloca i64, align 8
  %size_of_cell.i.i = alloca i64, align 8
  %cell_index.i.i = alloca i64, align 8
  %data_index.i.i = alloca i64, align 8
  %size_of_type.i.i = alloca i64, align 8
  %cell_index2.i.i = alloca i64, align 8
  %data_index3.i.i = alloca i64, align 8
  %size_of_type4.i.i = alloca i64, align 8
  %31 = alloca i64, align 8
  %32 = alloca ptr, align 8
  %INFO_HS.i = alloca ptr, align 8
  %size.i = alloca i64, align 8
  %33 = alloca i64, align 8
  %34 = alloca i64, align 8
  %35 = alloca i64, align 8
  %36 = alloca %"runtime::Allocator", align 8
  %37 = alloca { ptr, i64 }, align 8
  %38 = alloca ptr, align 8
  %39 = alloca i64, align 8
  %40 = alloca %"runtime::Allocator", align 8
  %result = alloca %"runtime::Raw_Map", align 8
  %err = alloca i8, align 1
  %capacity = alloca i64, align 8
  %size = alloca i64, align 8
  %41 = alloca { ptr, i64 }, align 8
  %42 = alloca { { ptr, i64 }, i8 }, align 8
  %data = alloca { ptr, i64 }, align 8
  %data_ptr = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %38, align 8
  store i64 %1, ptr %39, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %40, ptr %2, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %result, i8 0, i64 32, i1 false)
  store i8 0, ptr %err, align 1
  %43 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %result, i32 0, i32 2
  %44 = load %"runtime::Allocator", ptr %40, align 8
  store %"runtime::Allocator" %44, ptr %43, align 8
  %45 = icmp eq i64 %1, 0
  %46 = zext i1 %45 to i8
  %47 = icmp ne i8 %46, 0
  br i1 %47, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %48 = load %"runtime::Raw_Map", ptr %result, align 8
  %49 = load i8, ptr %err, align 1
  store %"runtime::Raw_Map" %48, ptr %result, align 8
  store i8 %49, ptr %err, align 1
  store %"runtime::Raw_Map" %48, ptr %4, align 8
  ret i8 %49

if.done:                                          ; preds = %entry
  %50 = icmp uge i64 %1, 64
  %51 = zext i1 %50 to i8
  %52 = icmp ne i8 %51, 0
  br i1 %52, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  store %"runtime::Raw_Map" zeroinitializer, ptr %result, align 8
  store i8 1, ptr %err, align 1
  store %"runtime::Raw_Map" zeroinitializer, ptr %4, align 8
  ret i8 1

if.done2:                                         ; preds = %if.done
  %53 = icmp ugt i64 %1, 3
  %54 = select i1 %53, i64 %1, i64 3
  %55 = icmp ult i64 %54, 64
  %56 = shl i64 1, %54
  %57 = select i1 %55, i64 %56, i64 0
  store i64 %57, ptr %capacity, align 8
  %58 = load i64, ptr %capacity, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %31)
  call void @llvm.lifetime.start.p0(i64 8, ptr %32)
  call void @llvm.lifetime.start.p0(i64 8, ptr %INFO_HS.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size.i)
  store i64 %58, ptr %31, align 8
  store ptr %0, ptr %32, align 8
  store ptr @"ggv$map_cell_info-13197927915248882629", ptr %INFO_HS.i, align 8
  store i64 0, ptr %size.i, align 8
  %59 = load i64, ptr %size.i, align 8
  %60 = load ptr, ptr %32, align 8
  %61 = load ptr, ptr %60, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !114)
  call void @llvm.lifetime.start.p0(i64 8, ptr %16)
  call void @llvm.lifetime.start.p0(i64 8, ptr %17)
  call void @llvm.lifetime.start.p0(i64 8, ptr %18)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i37.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i38.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i39.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i40.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i41.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i42.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i43.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i44.i)
  store i64 %59, ptr %16, align 8, !noalias !114
  store ptr %61, ptr %17, align 8, !noalias !114
  store i64 %58, ptr %18, align 8, !noalias !114
  %62 = load ptr, ptr %17, align 8, !noalias !114
  %63 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %62, i32 0, i32 3
  %64 = load i64, ptr %63, align 8
  store i64 %64, ptr %elements_per_cell.i37.i, align 8, !noalias !114
  %65 = load ptr, ptr %17, align 8, !noalias !114
  %66 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %65, i32 0, i32 2
  %67 = load i64, ptr %66, align 8
  store i64 %67, ptr %size_of_cell.i38.i, align 8, !noalias !114
  %68 = load i64, ptr %elements_per_cell.i37.i, align 8, !noalias !114
  switch i64 %68, label %switch.default.body.i47.i [
    i64 1, label %switch.case.body.i46.i
    i64 2, label %switch.case.body1.i45.i
  ]

switch.case.body.i46.i:                           ; preds = %if.done2
  %69 = load i64, ptr %size_of_cell.i38.i, align 8, !noalias !114
  %70 = mul i64 %58, %69
  %71 = add i64 %59, %70
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i37.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i38.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i39.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i40.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i41.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i42.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i43.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i44.i)
  br label %"runtime::map_cell_index_dynamic.exit48.i"

switch.case.body1.i45.i:                          ; preds = %if.done2
  %72 = lshr i64 %58, 1
  store i64 %72, ptr %cell_index.i39.i, align 8, !noalias !114
  %73 = and i64 %58, 1
  store i64 %73, ptr %data_index.i40.i, align 8, !noalias !114
  %74 = load ptr, ptr %17, align 8, !noalias !114
  %75 = load i64, ptr %74, align 8
  store i64 %75, ptr %size_of_type.i41.i, align 8, !noalias !114
  %76 = load i64, ptr %cell_index.i39.i, align 8, !noalias !114
  %77 = load i64, ptr %size_of_cell.i38.i, align 8, !noalias !114
  %78 = mul i64 %76, %77
  %79 = add i64 %59, %78
  %80 = load i64, ptr %data_index.i40.i, align 8, !noalias !114
  %81 = load i64, ptr %size_of_type.i41.i, align 8, !noalias !114
  %82 = mul i64 %80, %81
  %83 = add i64 %79, %82
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i37.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i38.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i39.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i40.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i41.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i42.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i43.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i44.i)
  br label %"runtime::map_cell_index_dynamic.exit48.i"

switch.default.body.i47.i:                        ; preds = %if.done2
  %84 = load i64, ptr %elements_per_cell.i37.i, align 8, !noalias !114
  %85 = udiv i64 %58, %84
  store i64 %85, ptr %cell_index2.i42.i, align 8, !noalias !114
  %86 = load i64, ptr %elements_per_cell.i37.i, align 8, !noalias !114
  %87 = urem i64 %58, %86
  store i64 %87, ptr %data_index3.i43.i, align 8, !noalias !114
  %88 = load ptr, ptr %17, align 8, !noalias !114
  %89 = load i64, ptr %88, align 8
  store i64 %89, ptr %size_of_type4.i44.i, align 8, !noalias !114
  %90 = load i64, ptr %cell_index2.i42.i, align 8, !noalias !114
  %91 = load i64, ptr %size_of_cell.i38.i, align 8, !noalias !114
  %92 = mul i64 %90, %91
  %93 = add i64 %59, %92
  %94 = load i64, ptr %data_index3.i43.i, align 8, !noalias !114
  %95 = load i64, ptr %size_of_type4.i44.i, align 8, !noalias !114
  %96 = mul i64 %94, %95
  %97 = add i64 %93, %96
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i37.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i38.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i39.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i40.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i41.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i42.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i43.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i44.i)
  br label %"runtime::map_cell_index_dynamic.exit48.i"

"runtime::map_cell_index_dynamic.exit48.i":       ; preds = %switch.default.body.i47.i, %switch.case.body1.i45.i, %switch.case.body.i46.i
  %98 = phi i64 [ %71, %switch.case.body.i46.i ], [ %83, %switch.case.body1.i45.i ], [ %97, %switch.default.body.i47.i ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  store i64 %98, ptr %5, align 8
  %99 = add i64 %98, 63
  %100 = and i64 %99, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  store i64 %100, ptr %size.i, align 8
  %101 = load i64, ptr %size.i, align 8
  %102 = load ptr, ptr %32, align 8
  %103 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %102, i32 0, i32 1
  %104 = load ptr, ptr %103, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !117)
  call void @llvm.lifetime.start.p0(i64 8, ptr %19)
  call void @llvm.lifetime.start.p0(i64 8, ptr %20)
  call void @llvm.lifetime.start.p0(i64 8, ptr %21)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i25.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i26.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i27.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i28.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i29.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i30.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i31.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i32.i)
  store i64 %101, ptr %19, align 8, !noalias !117
  store ptr %104, ptr %20, align 8, !noalias !117
  store i64 %58, ptr %21, align 8, !noalias !117
  %105 = load ptr, ptr %20, align 8, !noalias !117
  %106 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %105, i32 0, i32 3
  %107 = load i64, ptr %106, align 8
  store i64 %107, ptr %elements_per_cell.i25.i, align 8, !noalias !117
  %108 = load ptr, ptr %20, align 8, !noalias !117
  %109 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %108, i32 0, i32 2
  %110 = load i64, ptr %109, align 8
  store i64 %110, ptr %size_of_cell.i26.i, align 8, !noalias !117
  %111 = load i64, ptr %elements_per_cell.i25.i, align 8, !noalias !117
  switch i64 %111, label %switch.default.body.i35.i [
    i64 1, label %switch.case.body.i34.i
    i64 2, label %switch.case.body1.i33.i
  ]

switch.case.body.i34.i:                           ; preds = %"runtime::map_cell_index_dynamic.exit48.i"
  %112 = load i64, ptr %size_of_cell.i26.i, align 8, !noalias !117
  %113 = mul i64 %58, %112
  %114 = add i64 %101, %113
  call void @llvm.lifetime.end.p0(i64 8, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i25.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i26.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i27.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i28.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i29.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i30.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i31.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i32.i)
  br label %"runtime::map_cell_index_dynamic.exit36.i"

switch.case.body1.i33.i:                          ; preds = %"runtime::map_cell_index_dynamic.exit48.i"
  %115 = lshr i64 %58, 1
  store i64 %115, ptr %cell_index.i27.i, align 8, !noalias !117
  %116 = and i64 %58, 1
  store i64 %116, ptr %data_index.i28.i, align 8, !noalias !117
  %117 = load ptr, ptr %20, align 8, !noalias !117
  %118 = load i64, ptr %117, align 8
  store i64 %118, ptr %size_of_type.i29.i, align 8, !noalias !117
  %119 = load i64, ptr %cell_index.i27.i, align 8, !noalias !117
  %120 = load i64, ptr %size_of_cell.i26.i, align 8, !noalias !117
  %121 = mul i64 %119, %120
  %122 = add i64 %101, %121
  %123 = load i64, ptr %data_index.i28.i, align 8, !noalias !117
  %124 = load i64, ptr %size_of_type.i29.i, align 8, !noalias !117
  %125 = mul i64 %123, %124
  %126 = add i64 %122, %125
  call void @llvm.lifetime.end.p0(i64 8, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i25.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i26.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i27.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i28.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i29.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i30.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i31.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i32.i)
  br label %"runtime::map_cell_index_dynamic.exit36.i"

switch.default.body.i35.i:                        ; preds = %"runtime::map_cell_index_dynamic.exit48.i"
  %127 = load i64, ptr %elements_per_cell.i25.i, align 8, !noalias !117
  %128 = udiv i64 %58, %127
  store i64 %128, ptr %cell_index2.i30.i, align 8, !noalias !117
  %129 = load i64, ptr %elements_per_cell.i25.i, align 8, !noalias !117
  %130 = urem i64 %58, %129
  store i64 %130, ptr %data_index3.i31.i, align 8, !noalias !117
  %131 = load ptr, ptr %20, align 8, !noalias !117
  %132 = load i64, ptr %131, align 8
  store i64 %132, ptr %size_of_type4.i32.i, align 8, !noalias !117
  %133 = load i64, ptr %cell_index2.i30.i, align 8, !noalias !117
  %134 = load i64, ptr %size_of_cell.i26.i, align 8, !noalias !117
  %135 = mul i64 %133, %134
  %136 = add i64 %101, %135
  %137 = load i64, ptr %data_index3.i31.i, align 8, !noalias !117
  %138 = load i64, ptr %size_of_type4.i32.i, align 8, !noalias !117
  %139 = mul i64 %137, %138
  %140 = add i64 %136, %139
  call void @llvm.lifetime.end.p0(i64 8, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i25.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i26.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i27.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i28.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i29.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i30.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i31.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i32.i)
  br label %"runtime::map_cell_index_dynamic.exit36.i"

"runtime::map_cell_index_dynamic.exit36.i":       ; preds = %switch.default.body.i35.i, %switch.case.body1.i33.i, %switch.case.body.i34.i
  %141 = phi i64 [ %114, %switch.case.body.i34.i ], [ %126, %switch.case.body1.i33.i ], [ %140, %switch.default.body.i35.i ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  store i64 %141, ptr %6, align 8
  %142 = add i64 %141, 63
  %143 = and i64 %142, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  store i64 %143, ptr %size.i, align 8
  %144 = load i64, ptr %size.i, align 8
  %145 = load ptr, ptr %INFO_HS.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !120)
  call void @llvm.lifetime.start.p0(i64 8, ptr %22)
  call void @llvm.lifetime.start.p0(i64 8, ptr %23)
  call void @llvm.lifetime.start.p0(i64 8, ptr %24)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i13.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i14.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i15.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i16.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i17.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i18.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i19.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i20.i)
  store i64 %144, ptr %22, align 8, !noalias !120
  store ptr %145, ptr %23, align 8, !noalias !120
  store i64 %58, ptr %24, align 8, !noalias !120
  %146 = load ptr, ptr %23, align 8, !noalias !120
  %147 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %146, i32 0, i32 3
  %148 = load i64, ptr %147, align 8
  store i64 %148, ptr %elements_per_cell.i13.i, align 8, !noalias !120
  %149 = load ptr, ptr %23, align 8, !noalias !120
  %150 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %149, i32 0, i32 2
  %151 = load i64, ptr %150, align 8
  store i64 %151, ptr %size_of_cell.i14.i, align 8, !noalias !120
  %152 = load i64, ptr %elements_per_cell.i13.i, align 8, !noalias !120
  switch i64 %152, label %switch.default.body.i23.i [
    i64 1, label %switch.case.body.i22.i
    i64 2, label %switch.case.body1.i21.i
  ]

switch.case.body.i22.i:                           ; preds = %"runtime::map_cell_index_dynamic.exit36.i"
  %153 = load i64, ptr %size_of_cell.i14.i, align 8, !noalias !120
  %154 = mul i64 %58, %153
  %155 = add i64 %144, %154
  call void @llvm.lifetime.end.p0(i64 8, ptr %22)
  call void @llvm.lifetime.end.p0(i64 8, ptr %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr %24)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i13.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i14.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i15.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i16.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i17.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i18.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i19.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i20.i)
  br label %"runtime::map_cell_index_dynamic.exit24.i"

switch.case.body1.i21.i:                          ; preds = %"runtime::map_cell_index_dynamic.exit36.i"
  %156 = lshr i64 %58, 1
  store i64 %156, ptr %cell_index.i15.i, align 8, !noalias !120
  %157 = and i64 %58, 1
  store i64 %157, ptr %data_index.i16.i, align 8, !noalias !120
  %158 = load ptr, ptr %23, align 8, !noalias !120
  %159 = load i64, ptr %158, align 8
  store i64 %159, ptr %size_of_type.i17.i, align 8, !noalias !120
  %160 = load i64, ptr %cell_index.i15.i, align 8, !noalias !120
  %161 = load i64, ptr %size_of_cell.i14.i, align 8, !noalias !120
  %162 = mul i64 %160, %161
  %163 = add i64 %144, %162
  %164 = load i64, ptr %data_index.i16.i, align 8, !noalias !120
  %165 = load i64, ptr %size_of_type.i17.i, align 8, !noalias !120
  %166 = mul i64 %164, %165
  %167 = add i64 %163, %166
  call void @llvm.lifetime.end.p0(i64 8, ptr %22)
  call void @llvm.lifetime.end.p0(i64 8, ptr %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr %24)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i13.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i14.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i15.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i16.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i17.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i18.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i19.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i20.i)
  br label %"runtime::map_cell_index_dynamic.exit24.i"

switch.default.body.i23.i:                        ; preds = %"runtime::map_cell_index_dynamic.exit36.i"
  %168 = load i64, ptr %elements_per_cell.i13.i, align 8, !noalias !120
  %169 = udiv i64 %58, %168
  store i64 %169, ptr %cell_index2.i18.i, align 8, !noalias !120
  %170 = load i64, ptr %elements_per_cell.i13.i, align 8, !noalias !120
  %171 = urem i64 %58, %170
  store i64 %171, ptr %data_index3.i19.i, align 8, !noalias !120
  %172 = load ptr, ptr %23, align 8, !noalias !120
  %173 = load i64, ptr %172, align 8
  store i64 %173, ptr %size_of_type4.i20.i, align 8, !noalias !120
  %174 = load i64, ptr %cell_index2.i18.i, align 8, !noalias !120
  %175 = load i64, ptr %size_of_cell.i14.i, align 8, !noalias !120
  %176 = mul i64 %174, %175
  %177 = add i64 %144, %176
  %178 = load i64, ptr %data_index3.i19.i, align 8, !noalias !120
  %179 = load i64, ptr %size_of_type4.i20.i, align 8, !noalias !120
  %180 = mul i64 %178, %179
  %181 = add i64 %177, %180
  call void @llvm.lifetime.end.p0(i64 8, ptr %22)
  call void @llvm.lifetime.end.p0(i64 8, ptr %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr %24)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i13.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i14.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i15.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i16.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i17.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i18.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i19.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i20.i)
  br label %"runtime::map_cell_index_dynamic.exit24.i"

"runtime::map_cell_index_dynamic.exit24.i":       ; preds = %switch.default.body.i23.i, %switch.case.body1.i21.i, %switch.case.body.i22.i
  %182 = phi i64 [ %155, %switch.case.body.i22.i ], [ %167, %switch.case.body1.i21.i ], [ %181, %switch.default.body.i23.i ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  store i64 %182, ptr %7, align 8
  %183 = add i64 %182, 63
  %184 = and i64 %183, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  store i64 %184, ptr %size.i, align 8
  %185 = load i64, ptr %size.i, align 8
  %186 = load ptr, ptr %32, align 8
  %187 = load ptr, ptr %186, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !123)
  call void @llvm.lifetime.start.p0(i64 8, ptr %25)
  call void @llvm.lifetime.start.p0(i64 8, ptr %26)
  call void @llvm.lifetime.start.p0(i64 8, ptr %27)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i1.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i2.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i3.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i4.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i5.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i6.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i7.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i8.i)
  store i64 %185, ptr %25, align 8, !noalias !123
  store ptr %187, ptr %26, align 8, !noalias !123
  store i64 2, ptr %27, align 8, !noalias !123
  %188 = load ptr, ptr %26, align 8, !noalias !123
  %189 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %188, i32 0, i32 3
  %190 = load i64, ptr %189, align 8
  store i64 %190, ptr %elements_per_cell.i1.i, align 8, !noalias !123
  %191 = load ptr, ptr %26, align 8, !noalias !123
  %192 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %191, i32 0, i32 2
  %193 = load i64, ptr %192, align 8
  store i64 %193, ptr %size_of_cell.i2.i, align 8, !noalias !123
  %194 = load i64, ptr %elements_per_cell.i1.i, align 8, !noalias !123
  switch i64 %194, label %switch.default.body.i11.i [
    i64 1, label %switch.case.body.i10.i
    i64 2, label %switch.case.body1.i9.i
  ]

switch.case.body.i10.i:                           ; preds = %"runtime::map_cell_index_dynamic.exit24.i"
  %195 = load i64, ptr %size_of_cell.i2.i, align 8, !noalias !123
  %196 = mul i64 2, %195
  %197 = add i64 %185, %196
  call void @llvm.lifetime.end.p0(i64 8, ptr %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr %26)
  call void @llvm.lifetime.end.p0(i64 8, ptr %27)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i4.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i5.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i6.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i7.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i8.i)
  br label %"runtime::map_cell_index_dynamic.exit12.i"

switch.case.body1.i9.i:                           ; preds = %"runtime::map_cell_index_dynamic.exit24.i"
  store i64 1, ptr %cell_index.i3.i, align 8, !noalias !123
  store i64 0, ptr %data_index.i4.i, align 8, !noalias !123
  %198 = load ptr, ptr %26, align 8, !noalias !123
  %199 = load i64, ptr %198, align 8
  store i64 %199, ptr %size_of_type.i5.i, align 8, !noalias !123
  %200 = load i64, ptr %cell_index.i3.i, align 8, !noalias !123
  %201 = load i64, ptr %size_of_cell.i2.i, align 8, !noalias !123
  %202 = mul i64 %200, %201
  %203 = add i64 %185, %202
  %204 = load i64, ptr %data_index.i4.i, align 8, !noalias !123
  %205 = load i64, ptr %size_of_type.i5.i, align 8, !noalias !123
  %206 = mul i64 %204, %205
  %207 = add i64 %203, %206
  call void @llvm.lifetime.end.p0(i64 8, ptr %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr %26)
  call void @llvm.lifetime.end.p0(i64 8, ptr %27)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i4.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i5.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i6.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i7.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i8.i)
  br label %"runtime::map_cell_index_dynamic.exit12.i"

switch.default.body.i11.i:                        ; preds = %"runtime::map_cell_index_dynamic.exit24.i"
  %208 = load i64, ptr %elements_per_cell.i1.i, align 8, !noalias !123
  %209 = udiv i64 2, %208
  store i64 %209, ptr %cell_index2.i6.i, align 8, !noalias !123
  %210 = load i64, ptr %elements_per_cell.i1.i, align 8, !noalias !123
  %211 = urem i64 2, %210
  store i64 %211, ptr %data_index3.i7.i, align 8, !noalias !123
  %212 = load ptr, ptr %26, align 8, !noalias !123
  %213 = load i64, ptr %212, align 8
  store i64 %213, ptr %size_of_type4.i8.i, align 8, !noalias !123
  %214 = load i64, ptr %cell_index2.i6.i, align 8, !noalias !123
  %215 = load i64, ptr %size_of_cell.i2.i, align 8, !noalias !123
  %216 = mul i64 %214, %215
  %217 = add i64 %185, %216
  %218 = load i64, ptr %data_index3.i7.i, align 8, !noalias !123
  %219 = load i64, ptr %size_of_type4.i8.i, align 8, !noalias !123
  %220 = mul i64 %218, %219
  %221 = add i64 %217, %220
  call void @llvm.lifetime.end.p0(i64 8, ptr %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr %26)
  call void @llvm.lifetime.end.p0(i64 8, ptr %27)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i4.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i5.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i6.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i7.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i8.i)
  br label %"runtime::map_cell_index_dynamic.exit12.i"

"runtime::map_cell_index_dynamic.exit12.i":       ; preds = %switch.default.body.i11.i, %switch.case.body1.i9.i, %switch.case.body.i10.i
  %222 = phi i64 [ %197, %switch.case.body.i10.i ], [ %207, %switch.case.body1.i9.i ], [ %221, %switch.default.body.i11.i ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  store i64 %222, ptr %8, align 8
  %223 = add i64 %222, 63
  %224 = and i64 %223, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  store i64 %224, ptr %size.i, align 8
  %225 = load i64, ptr %size.i, align 8
  %226 = load ptr, ptr %32, align 8
  %227 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %226, i32 0, i32 1
  %228 = load ptr, ptr %227, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !126)
  call void @llvm.lifetime.start.p0(i64 8, ptr %28)
  call void @llvm.lifetime.start.p0(i64 8, ptr %29)
  call void @llvm.lifetime.start.p0(i64 8, ptr %30)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i.i)
  store i64 %225, ptr %28, align 8, !noalias !126
  store ptr %228, ptr %29, align 8, !noalias !126
  store i64 2, ptr %30, align 8, !noalias !126
  %229 = load ptr, ptr %29, align 8, !noalias !126
  %230 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %229, i32 0, i32 3
  %231 = load i64, ptr %230, align 8
  store i64 %231, ptr %elements_per_cell.i.i, align 8, !noalias !126
  %232 = load ptr, ptr %29, align 8, !noalias !126
  %233 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %232, i32 0, i32 2
  %234 = load i64, ptr %233, align 8
  store i64 %234, ptr %size_of_cell.i.i, align 8, !noalias !126
  %235 = load i64, ptr %elements_per_cell.i.i, align 8, !noalias !126
  switch i64 %235, label %switch.default.body.i.i [
    i64 1, label %switch.case.body.i.i
    i64 2, label %switch.case.body1.i.i
  ]

switch.case.body.i.i:                             ; preds = %"runtime::map_cell_index_dynamic.exit12.i"
  %236 = load i64, ptr %size_of_cell.i.i, align 8, !noalias !126
  %237 = mul i64 2, %236
  %238 = add i64 %225, %237
  call void @llvm.lifetime.end.p0(i64 8, ptr %28)
  call void @llvm.lifetime.end.p0(i64 8, ptr %29)
  call void @llvm.lifetime.end.p0(i64 8, ptr %30)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i.i)
  br label %"runtime::map_total_allocation_size.exit"

switch.case.body1.i.i:                            ; preds = %"runtime::map_cell_index_dynamic.exit12.i"
  store i64 1, ptr %cell_index.i.i, align 8, !noalias !126
  store i64 0, ptr %data_index.i.i, align 8, !noalias !126
  %239 = load ptr, ptr %29, align 8, !noalias !126
  %240 = load i64, ptr %239, align 8
  store i64 %240, ptr %size_of_type.i.i, align 8, !noalias !126
  %241 = load i64, ptr %cell_index.i.i, align 8, !noalias !126
  %242 = load i64, ptr %size_of_cell.i.i, align 8, !noalias !126
  %243 = mul i64 %241, %242
  %244 = add i64 %225, %243
  %245 = load i64, ptr %data_index.i.i, align 8, !noalias !126
  %246 = load i64, ptr %size_of_type.i.i, align 8, !noalias !126
  %247 = mul i64 %245, %246
  %248 = add i64 %244, %247
  call void @llvm.lifetime.end.p0(i64 8, ptr %28)
  call void @llvm.lifetime.end.p0(i64 8, ptr %29)
  call void @llvm.lifetime.end.p0(i64 8, ptr %30)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i.i)
  br label %"runtime::map_total_allocation_size.exit"

switch.default.body.i.i:                          ; preds = %"runtime::map_cell_index_dynamic.exit12.i"
  %249 = load i64, ptr %elements_per_cell.i.i, align 8, !noalias !126
  %250 = udiv i64 2, %249
  store i64 %250, ptr %cell_index2.i.i, align 8, !noalias !126
  %251 = load i64, ptr %elements_per_cell.i.i, align 8, !noalias !126
  %252 = urem i64 2, %251
  store i64 %252, ptr %data_index3.i.i, align 8, !noalias !126
  %253 = load ptr, ptr %29, align 8, !noalias !126
  %254 = load i64, ptr %253, align 8
  store i64 %254, ptr %size_of_type4.i.i, align 8, !noalias !126
  %255 = load i64, ptr %cell_index2.i.i, align 8, !noalias !126
  %256 = load i64, ptr %size_of_cell.i.i, align 8, !noalias !126
  %257 = mul i64 %255, %256
  %258 = add i64 %225, %257
  %259 = load i64, ptr %data_index3.i.i, align 8, !noalias !126
  %260 = load i64, ptr %size_of_type4.i.i, align 8, !noalias !126
  %261 = mul i64 %259, %260
  %262 = add i64 %258, %261
  call void @llvm.lifetime.end.p0(i64 8, ptr %28)
  call void @llvm.lifetime.end.p0(i64 8, ptr %29)
  call void @llvm.lifetime.end.p0(i64 8, ptr %30)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i.i)
  br label %"runtime::map_total_allocation_size.exit"

"runtime::map_total_allocation_size.exit":        ; preds = %switch.case.body.i.i, %switch.case.body1.i.i, %switch.default.body.i.i
  %263 = phi i64 [ %238, %switch.case.body.i.i ], [ %248, %switch.case.body1.i.i ], [ %262, %switch.default.body.i.i ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %9)
  store i64 %263, ptr %9, align 8
  %264 = add i64 %263, 63
  %265 = and i64 %264, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  store i64 %265, ptr %size.i, align 8
  %266 = load i64, ptr %size.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr %32)
  call void @llvm.lifetime.end.p0(i64 8, ptr %INFO_HS.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size.i)
  store i64 %266, ptr %size, align 8
  %267 = load i64, ptr %size, align 8
  call void @llvm.memset.inline.p0.i64(ptr %41, i8 0, i64 16, i1 false)
  call void @llvm.experimental.noalias.scope.decl(metadata !129)
  call void @llvm.experimental.noalias.scope.decl(metadata !132)
  call void @llvm.lifetime.start.p0(i64 8, ptr %34)
  call void @llvm.lifetime.start.p0(i64 8, ptr %35)
  call void @llvm.lifetime.start.p0(i64 16, ptr %36)
  call void @llvm.lifetime.start.p0(i64 16, ptr %37)
  store i64 %267, ptr %34, align 8, !noalias !134
  store i64 64, ptr %35, align 8, !noalias !134
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %36, ptr %40, i64 16, i1 false), !noalias !134
  call void @llvm.lifetime.start.p0(i64 8, ptr %33), !noalias !134
  store i64 64, ptr %33, align 8, !noalias !134
  call void @llvm.lifetime.end.p0(i64 8, ptr %33), !noalias !134
  call void @"runtime::assert"(i1 zeroext true, ptr @"ggv$runtime::mem_alloc_non_zeroed$1", ptr %3, ptr nonnull %__.context_ptr), !noalias !129
  %268 = icmp eq i64 %267, 0
  %269 = zext i1 %268 to i8
  br i1 %268, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %"runtime::map_total_allocation_size.exit"
  %270 = load ptr, ptr %36, align 8, !noalias !134
  %271 = icmp eq ptr %270, null
  %272 = zext i1 %271 to i8
  br i1 %271, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %"runtime::map_total_allocation_size.exit"
  store { ptr, i64 } zeroinitializer, ptr %41, align 8, !alias.scope !129, !noalias !132
  call void @llvm.lifetime.end.p0(i64 8, ptr %34)
  call void @llvm.lifetime.end.p0(i64 8, ptr %35)
  call void @llvm.lifetime.end.p0(i64 16, ptr %36)
  call void @llvm.lifetime.end.p0(i64 16, ptr %37)
  br label %"runtime::mem_alloc_non_zeroed.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %273 = load ptr, ptr %36, align 8, !noalias !134
  %274 = getelementptr inbounds nuw %"runtime::Allocator", ptr %36, i32 0, i32 1
  %275 = load ptr, ptr %274, align 8, !noalias !134
  call void @llvm.memset.inline.p0.i64(ptr %37, i8 0, i64 16, i1 false), !noalias !134
  %276 = call i8 %273(ptr %275, i8 6, i64 %267, i64 64, ptr null, i64 0, ptr %3, ptr %37, ptr nonnull %__.context_ptr), !noalias !129
  %277 = load { ptr, i64 }, ptr %37, align 8, !noalias !134
  store { ptr, i64 } %277, ptr %41, align 8, !alias.scope !129, !noalias !132
  call void @llvm.lifetime.end.p0(i64 8, ptr %34)
  call void @llvm.lifetime.end.p0(i64 8, ptr %35)
  call void @llvm.lifetime.end.p0(i64 16, ptr %36)
  call void @llvm.lifetime.end.p0(i64 16, ptr %37)
  br label %"runtime::mem_alloc_non_zeroed.exit"

"runtime::mem_alloc_non_zeroed.exit":             ; preds = %if.done.i, %if.then.i
  %278 = phi i8 [ 0, %if.then.i ], [ %276, %if.done.i ]
  %279 = load { ptr, i64 }, ptr %41, align 8
  %280 = icmp eq i8 %278, 0
  br i1 %280, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %"runtime::mem_alloc_non_zeroed.exit"
  store i8 %278, ptr %err, align 1
  %281 = load %"runtime::Raw_Map", ptr %result, align 8
  %282 = load i8, ptr %err, align 1
  store %"runtime::Raw_Map" %281, ptr %result, align 8
  store i8 %282, ptr %err, align 1
  store %"runtime::Raw_Map" %281, ptr %4, align 8
  ret i8 %282

or_return.continue:                               ; preds = %"runtime::mem_alloc_non_zeroed.exit"
  store { ptr, i64 } %279, ptr %data, align 8
  %283 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %284 = load ptr, ptr %283, align 8
  %285 = ptrtoint ptr %284 to i64
  store i64 %285, ptr %data_ptr, align 8
  %286 = load i64, ptr %data_ptr, align 8
  %287 = icmp eq i64 %286, 0
  %288 = zext i1 %287 to i8
  %289 = icmp ne i8 %288, 0
  br i1 %289, label %if.then3, label %if.done4

if.then3:                                         ; preds = %or_return.continue
  store i8 1, ptr %err, align 1
  %290 = load %"runtime::Raw_Map", ptr %result, align 8
  %291 = load i8, ptr %err, align 1
  store %"runtime::Raw_Map" %290, ptr %result, align 8
  store i8 %291, ptr %err, align 1
  store %"runtime::Raw_Map" %290, ptr %4, align 8
  ret i8 %291

if.done4:                                         ; preds = %or_return.continue
  %292 = load i64, ptr %data_ptr, align 8
  %293 = and i64 %292, 63
  %294 = icmp ne i64 %293, 0
  %295 = zext i1 %294 to i8
  %296 = call i8 @llvm.expect.i8(i8 %295, i8 0)
  %297 = icmp ne i8 %296, 0
  br i1 %297, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.done4
  call void @"runtime::panic"(ptr @"ggv$runtime::map_alloc_dynamic$1", ptr %3, ptr %__.context_ptr)
  unreachable

if.else:                                          ; preds = %if.done4
  %298 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %result, i32 0, i32 0
  %299 = load i64, ptr %data_ptr, align 8
  %300 = or i64 %299, %1
  store i64 %300, ptr %298, align 8
  %301 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %result, i32 0, i32 1
  store i64 0, ptr %301, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !135)
  call void @llvm.experimental.noalias.scope.decl(metadata !138)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %12)
  call void @llvm.lifetime.start.p0(i64 8, ptr %13)
  call void @llvm.lifetime.start.p0(i64 8, ptr %14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr %hs.i)
  store ptr %result, ptr %10, align 8, !noalias !140
  store ptr %0, ptr %11, align 8, !noalias !140
  %302 = load ptr, ptr %10, align 8, !noalias !140
  %303 = load i64, ptr %302, align 8
  %304 = icmp eq i64 %303, 0
  %305 = zext i1 %304 to i8
  br i1 %304, label %if.then.i8, label %if.done.i7

if.then.i8:                                       ; preds = %if.else
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %hs.i)
  br label %"runtime::map_clear_dynamic.exit"

if.done.i7:                                       ; preds = %if.else
  store i64 0, ptr %12, align 8, !noalias !140
  store i64 0, ptr %13, align 8, !noalias !140
  store ptr null, ptr %14, align 8, !noalias !140
  store i64 0, ptr %15, align 8, !noalias !140
  %306 = call i64 @"runtime::map_kvh_data_dynamic"(ptr %result, ptr %0, ptr %12, ptr %13, ptr %14, ptr %15)
  %307 = load ptr, ptr %14, align 8, !noalias !140
  store ptr %307, ptr %hs.i, align 8, !noalias !140
  %308 = load ptr, ptr %hs.i, align 8, !noalias !140
  %309 = load i64, ptr %result, align 8, !alias.scope !135, !noalias !138
  %310 = icmp eq i64 %309, 0
  %311 = zext i1 %310 to i8
  br i1 %310, label %if.then.i.i, label %if.else.i.i

if.then.i.i:                                      ; preds = %if.done.i7
  br label %"runtime::map_cap.exit.i"

if.else.i.i:                                      ; preds = %if.done.i7
  %312 = load i64, ptr %result, align 8, !alias.scope !135, !noalias !138
  %313 = and i64 %312, 63
  %314 = shl i64 1, %313
  br label %"runtime::map_cap.exit.i"

"runtime::map_cap.exit.i":                        ; preds = %if.else.i.i, %if.then.i.i
  %315 = phi i64 [ 0, %if.then.i.i ], [ %314, %if.else.i.i ]
  %316 = mul i64 %315, 8
  call void @llvm.memset.p0.i64(ptr %308, i8 0, i64 %316, i1 false)
  %317 = load ptr, ptr %10, align 8, !noalias !140
  %318 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %317, i32 0, i32 1
  store i64 0, ptr %318, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %hs.i)
  br label %"runtime::map_clear_dynamic.exit"

"runtime::map_clear_dynamic.exit":                ; preds = %"runtime::map_cap.exit.i", %if.then.i8
  br label %if.done6

if.done6:                                         ; preds = %"runtime::map_clear_dynamic.exit"
  %319 = load %"runtime::Raw_Map", ptr %result, align 8
  %320 = load i8, ptr %err, align 1
  store %"runtime::Raw_Map" %319, ptr %result, align 8
  store i8 %320, ptr %err, align 1
  store %"runtime::Raw_Map" %319, ptr %4, align 8
  ret i8 %320
}

; Function Attrs: alwaysinline
define i8 @"runtime::string_ne"(ptr %0, ptr %1) #1 {
decls:
  %2 = alloca %..string, align 8
  %3 = alloca %..string, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %1, i64 16, i1 false)
  %4 = call i8 @"runtime::string_eq"(ptr %2, ptr %3)
  %5 = icmp eq i8 %4, 0
  %6 = zext i1 %5 to i8
  ret i8 %6
}

define ptr @"runtime::__type_info_of"(i64 %0) {
decls:
  %1 = alloca i64, align 8
  %n = alloca i64, align 8
  %i = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %ptr = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %4 = load i64, ptr getelementptr ({ ptr, i64 }, ptr @"runtime::type_table", i64 0, i32 1), align 8
  store i64 %4, ptr %n, align 8
  %5 = load i64, ptr %n, align 8
  %6 = urem i64 %0, %5
  store i64 %6, ptr %i, align 8
  store i64 0, ptr %2, align 8
  store i64 0, ptr %3, align 8
  br label %for.interval.loop

for.interval.loop:                                ; preds = %for.interval.post, %entry
  %7 = load i64, ptr %n, align 8
  %8 = load i64, ptr %2, align 8
  %9 = icmp ult i64 %8, %7
  br i1 %9, label %for.interval.body, label %for.interval.done

for.interval.body:                                ; preds = %for.interval.loop
  %10 = load ptr, ptr @"runtime::type_table", align 8
  %11 = load i64, ptr %i, align 8
  %12 = getelementptr ptr, ptr %10, i64 %11
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %ptr, align 8
  %14 = load ptr, ptr %ptr, align 8
  %15 = icmp ne ptr %14, null
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %for.interval.body
  %18 = load ptr, ptr %ptr, align 8
  %19 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %18, i32 0, i32 4
  %20 = load i64, ptr %19, align 8
  %21 = icmp eq i64 %20, %0
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  %24 = load ptr, ptr %ptr, align 8
  ret ptr %24

if.done:                                          ; preds = %cmp.and, %for.interval.body
  %25 = load i64, ptr %i, align 8
  %26 = add i64 %25, 1
  %27 = load i64, ptr %n, align 8
  %28 = icmp ult i64 %26, %27
  %29 = zext i1 %28 to i8
  %30 = icmp ne i8 %29, 0
  br i1 %30, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.done
  %31 = load i64, ptr %i, align 8
  %32 = add i64 %31, 1
  br label %if.done2

if.else:                                          ; preds = %if.done
  br label %if.done2

if.done2:                                         ; preds = %if.else, %if.then1
  %33 = phi i64 [ %32, %if.then1 ], [ 0, %if.else ]
  store i64 %33, ptr %i, align 8
  br label %for.interval.post

for.interval.post:                                ; preds = %if.done2
  %34 = load i64, ptr %2, align 8
  %35 = add i64 %34, 1
  store i64 %35, ptr %2, align 8
  %36 = load i64, ptr %3, align 8
  %37 = add i64 %36, 1
  store i64 %37, ptr %3, align 8
  br label %for.interval.loop

for.interval.done:                                ; preds = %for.interval.loop
  %38 = load ptr, ptr @"runtime::type_table", align 8
  %39 = getelementptr ptr, ptr %38, i64 0
  %40 = load ptr, ptr %39, align 8
  ret ptr %40
}

define i64 @"runtime::typeid_base"(i64 %0) {
decls:
  %1 = alloca i64, align 8
  %ti = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = call ptr @"runtime::__type_info_of"(i64 %0)
  store ptr %2, ptr %ti, align 8
  %3 = load ptr, ptr %ti, align 8
  %4 = call ptr @"runtime::type_info_base"(ptr %3)
  store ptr %4, ptr %ti, align 8
  %5 = load ptr, ptr %ti, align 8
  %6 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %5, i32 0, i32 4
  %7 = load i64, ptr %6, align 8
  ret i64 %7
}

define i64 @"runtime::cstring_len"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %p0 = alloca i64, align 8
  %p = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = ptrtoint ptr %0 to i64
  store i64 %2, ptr %p0, align 8
  %3 = load i64, ptr %p0, align 8
  store i64 %3, ptr %p, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.body, %entry
  %4 = load i64, ptr %p, align 8
  %5 = icmp ne i64 %4, 0
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %cmp.and, label %for.done

cmp.and:                                          ; preds = %for.loop
  %8 = load i64, ptr %p, align 8
  %9 = inttoptr i64 %8 to ptr
  %10 = load i8, ptr %9, align 1
  %11 = icmp ne i8 %10, 0
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %for.body, label %for.done

for.body:                                         ; preds = %cmp.and
  %14 = load i64, ptr %p, align 8
  %15 = add i64 %14, 1
  store i64 %15, ptr %p, align 8
  br label %for.loop

for.done:                                         ; preds = %cmp.and, %for.loop
  %16 = load i64, ptr %p, align 8
  %17 = load i64, ptr %p0, align 8
  %18 = sub i64 %16, %17
  ret i64 %18
}

define void @"runtime::cstring_to_string"(ptr noalias sret(%..string) %agg.result, ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %ptr = alloca ptr, align 8
  %n = alloca i64, align 8
  %2 = alloca %"runtime::Raw_String", align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp eq ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store %..string zeroinitializer, ptr %agg.result, align 8
  ret void

if.done:                                          ; preds = %entry
  store ptr %0, ptr %ptr, align 8
  %6 = call i64 @"runtime::cstring_len"(ptr %0)
  store i64 %6, ptr %n, align 8
  call void @llvm.memset.inline.p0.i64(ptr %2, i8 0, i64 16, i1 false)
  store %"runtime::Raw_String" zeroinitializer, ptr %2, align 8
  %7 = load ptr, ptr %ptr, align 8
  %8 = getelementptr inbounds nuw %"runtime::Raw_String", ptr %2, i32 0, i32 0
  store ptr %7, ptr %8, align 8
  %9 = load i64, ptr %n, align 8
  %10 = getelementptr inbounds nuw %"runtime::Raw_String", ptr %2, i32 0, i32 1
  store i64 %9, ptr %10, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %agg.result, ptr %2, i64 16, i1 false)
  ret void
}

define i8 @"runtime::cstring_eq"(ptr %0, ptr %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca ptr, align 8
  %4 = alloca i64, align 8
  %a.i = alloca ptr, align 8
  %b.i = alloca ptr, align 8
  %n.i = alloca i64, align 8
  %i.i = alloca i64, align 8
  %m.i = alloca i64, align 8
  %load_a.i = alloca <16 x i8>, align 16
  %load_b.i = alloca <16 x i8>, align 16
  %ne.i = alloca <16 x i8>, align 16
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %x = alloca ptr, align 8
  %y = alloca ptr, align 8
  %xn = alloca i64, align 8
  %yn = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %7, align 8
  store ptr %1, ptr %8, align 8
  store ptr %0, ptr %x, align 8
  store ptr %1, ptr %y, align 8
  %9 = load ptr, ptr %x, align 8
  %10 = load ptr, ptr %y, align 8
  %11 = icmp eq ptr %9, %10
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 1

if.done:                                          ; preds = %entry
  %14 = load ptr, ptr %x, align 8
  %15 = icmp eq ptr %14, null
  %16 = zext i1 %15 to i8
  %17 = load ptr, ptr %y, align 8
  %18 = icmp eq ptr %17, null
  %19 = zext i1 %18 to i8
  %20 = xor i8 %16, %19
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  ret i8 0

if.done2:                                         ; preds = %if.done
  %22 = call i64 @"runtime::cstring_len"(ptr %0)
  store i64 %22, ptr %xn, align 8
  %23 = call i64 @"runtime::cstring_len"(ptr %1)
  store i64 %23, ptr %yn, align 8
  %24 = load i64, ptr %xn, align 8
  %25 = load i64, ptr %yn, align 8
  %26 = icmp ne i64 %24, %25
  %27 = zext i1 %26 to i8
  %28 = icmp ne i8 %27, 0
  br i1 %28, label %if.then3, label %if.done4

if.then3:                                         ; preds = %if.done2
  ret i8 0

if.done4:                                         ; preds = %if.done2
  %29 = load ptr, ptr %x, align 8
  %30 = load ptr, ptr %y, align 8
  %31 = load i64, ptr %xn, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  store ptr %29, ptr %2, align 8
  store ptr %30, ptr %3, align 8
  store i64 %31, ptr %4, align 8
  %32 = icmp eq i64 %31, 0
  %33 = zext i1 %32 to i8
  br i1 %32, label %switch.case.body.i, label %switch.case.next.i

switch.case.next.i:                               ; preds = %if.done4
  %34 = icmp eq ptr %29, %30
  %35 = zext i1 %34 to i8
  br i1 %34, label %switch.case.body2.i, label %switch.case.next1.i

switch.case.body.i:                               ; preds = %if.done4
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  br label %"runtime::memory_equal.exit"

switch.case.next1.i:                              ; preds = %switch.case.next.i
  store ptr %29, ptr %a.i, align 8
  store ptr %30, ptr %b.i, align 8
  store i64 %31, ptr %n.i, align 8
  store i64 0, ptr %i.i, align 8
  store i64 0, ptr %m.i, align 8
  %36 = load i64, ptr %n.i, align 8
  %37 = icmp uge i64 %36, 8
  %38 = zext i1 %37 to i8
  br i1 %37, label %if.then.i, label %if.done10.i

switch.case.body2.i:                              ; preds = %switch.case.next.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  br label %"runtime::memory_equal.exit"

if.then.i:                                        ; preds = %switch.case.next1.i
  %39 = load i64, ptr %n.i, align 8
  %40 = load i64, ptr %i.i, align 8
  %41 = sub i64 %39, %40
  %42 = udiv i64 %41, 16
  %43 = mul i64 %42, 16
  store i64 %43, ptr %m.i, align 8
  br label %for.loop.i

for.loop.i:                                       ; preds = %if.done.i, %if.then.i
  %44 = load i64, ptr %i.i, align 8
  %45 = load i64, ptr %m.i, align 8
  %46 = icmp ult i64 %44, %45
  %47 = zext i1 %46 to i8
  br i1 %46, label %for.body.i, label %for.done.i

for.body.i:                                       ; preds = %for.loop.i
  %48 = load ptr, ptr %a.i, align 8
  %49 = load i64, ptr %i.i, align 8
  %50 = getelementptr i8, ptr %48, i64 %49
  %51 = load <16 x i8>, ptr %50, align 1
  store <16 x i8> %51, ptr %load_a.i, align 16
  %52 = load ptr, ptr %b.i, align 8
  %53 = load i64, ptr %i.i, align 8
  %54 = getelementptr i8, ptr %52, i64 %53
  %55 = load <16 x i8>, ptr %54, align 1
  store <16 x i8> %55, ptr %load_b.i, align 16
  %56 = load <16 x i8>, ptr %load_a.i, align 16
  %57 = load <16 x i8>, ptr %load_b.i, align 16
  %58 = icmp ne <16 x i8> %56, %57
  %59 = sext <16 x i1> %58 to <16 x i8>
  store <16 x i8> %59, ptr %ne.i, align 16
  %60 = load <16 x i8>, ptr %ne.i, align 16
  %61 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %60)
  %62 = icmp ne i8 %61, 0
  %63 = zext i1 %62 to i8
  br i1 %62, label %if.then3.i, label %if.done.i

if.then3.i:                                       ; preds = %for.body.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  br label %"runtime::memory_equal.exit"

if.done.i:                                        ; preds = %for.body.i
  %64 = load i64, ptr %i.i, align 8
  %65 = add i64 %64, 16
  store i64 %65, ptr %i.i, align 8
  br label %for.loop.i

for.done.i:                                       ; preds = %for.loop.i
  %66 = load i64, ptr %n.i, align 8
  %67 = load i64, ptr %i.i, align 8
  %68 = sub i64 %66, %67
  %69 = udiv i64 %68, 8
  %70 = mul i64 %69, 8
  store i64 %70, ptr %m.i, align 8
  br label %for.loop4.i

for.loop4.i:                                      ; preds = %if.done7.i, %for.done.i
  %71 = load i64, ptr %i.i, align 8
  %72 = load i64, ptr %m.i, align 8
  %73 = icmp ult i64 %71, %72
  %74 = zext i1 %73 to i8
  br i1 %73, label %for.body5.i, label %for.done9.i

for.body5.i:                                      ; preds = %for.loop4.i
  %75 = load ptr, ptr %a.i, align 8
  %76 = load i64, ptr %i.i, align 8
  %77 = getelementptr i8, ptr %75, i64 %76
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %77, i64 8, i1 false)
  %78 = load i64, ptr %5, align 8
  %79 = load ptr, ptr %b.i, align 8
  %80 = load i64, ptr %i.i, align 8
  %81 = getelementptr i8, ptr %79, i64 %80
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %6, ptr %81, i64 8, i1 false)
  %82 = load i64, ptr %6, align 8
  %83 = icmp ne i64 %78, %82
  %84 = zext i1 %83 to i8
  br i1 %83, label %if.then6.i, label %if.done7.i

if.then6.i:                                       ; preds = %for.body5.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  br label %"runtime::memory_equal.exit"

if.done7.i:                                       ; preds = %for.body5.i
  %85 = load i64, ptr %i.i, align 8
  %86 = add i64 %85, 8
  store i64 %86, ptr %i.i, align 8
  br label %for.loop4.i

for.done9.i:                                      ; preds = %for.loop4.i
  br label %if.done10.i

if.done10.i:                                      ; preds = %for.done9.i, %switch.case.next1.i
  br label %for.loop11.i

for.loop11.i:                                     ; preds = %if.done14.i, %if.done10.i
  %87 = load i64, ptr %i.i, align 8
  %88 = load i64, ptr %n.i, align 8
  %89 = icmp ult i64 %87, %88
  %90 = zext i1 %89 to i8
  br i1 %89, label %for.body12.i, label %for.done16.i

for.body12.i:                                     ; preds = %for.loop11.i
  %91 = load ptr, ptr %a.i, align 8
  %92 = load i64, ptr %i.i, align 8
  %93 = getelementptr i8, ptr %91, i64 %92
  %94 = load i8, ptr %93, align 1
  %95 = load ptr, ptr %b.i, align 8
  %96 = load i64, ptr %i.i, align 8
  %97 = getelementptr i8, ptr %95, i64 %96
  %98 = load i8, ptr %97, align 1
  %99 = icmp ne i8 %94, %98
  %100 = zext i1 %99 to i8
  br i1 %99, label %if.then13.i, label %if.done14.i

if.then13.i:                                      ; preds = %for.body12.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  br label %"runtime::memory_equal.exit"

if.done14.i:                                      ; preds = %for.body12.i
  %101 = load i64, ptr %i.i, align 8
  %102 = add i64 %101, 1
  store i64 %102, ptr %i.i, align 8
  br label %for.loop11.i

for.done16.i:                                     ; preds = %for.loop11.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %a.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %b.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %m.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_a.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %load_b.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %ne.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  br label %"runtime::memory_equal.exit"

"runtime::memory_equal.exit":                     ; preds = %for.done16.i, %if.then13.i, %if.then6.i, %if.then3.i, %switch.case.body2.i, %switch.case.body.i
  %103 = phi i8 [ 1, %switch.case.body.i ], [ 1, %switch.case.body2.i ], [ 0, %if.then3.i ], [ 0, %if.then6.i ], [ 0, %if.then13.i ], [ 1, %for.done16.i ]
  ret i8 %103
}

define void @"runtime::default_logger_proc"(ptr %0, i64 %1, ptr %2, i16 %3, ptr %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca ptr, align 8
  %6 = alloca i64, align 8
  %7 = alloca %..string, align 8
  %8 = alloca i16, align 2
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %2, i64 16, i1 false)
  store i16 %3, ptr %8, align 2
  ret void
}

define void @"runtime::default_context"(ptr noalias sret(%"runtime::Context") %agg.result) {
decls:
  %c = alloca %"runtime::Context", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memset.p0.i64(ptr %c, i8 0, i64 112, i1 false)
  call void @"runtime::[core.odin]::__init_context"(ptr %c)
  call void @llvm.memcpy.p0.p0.i64(ptr %agg.result, ptr %c, i64 112, i1 false)
  ret void
}

define i64 @"runtime::map_insert_hash_dynamic_with_key"(ptr noalias %0, ptr noalias %1, i64 %2, i64 %3, i64 %4, ptr noalias nonnull %5, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %6 = alloca i64, align 8
  %capacity.i.i224 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %capacity.i225 = alloca i64, align 8
  %9 = alloca i64, align 8
  %capacity.i.i222 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %capacity.i223 = alloca i64, align 8
  %12 = alloca i64, align 8
  %capacity.i.i = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca i64, align 8
  %capacity.i221 = alloca i64, align 8
  %15 = alloca i64, align 8
  %capacity.i = alloca i64, align 8
  %16 = alloca i64, align 8
  %17 = alloca i64, align 8
  %18 = alloca i64, align 8
  %19 = alloca i64, align 8
  %20 = alloca ptr, align 8
  %21 = alloca i64, align 8
  %elements_per_cell.i209 = alloca i64, align 8
  %size_of_cell.i210 = alloca i64, align 8
  %cell_index.i211 = alloca i64, align 8
  %data_index.i212 = alloca i64, align 8
  %size_of_type.i213 = alloca i64, align 8
  %cell_index2.i214 = alloca i64, align 8
  %data_index3.i215 = alloca i64, align 8
  %size_of_type4.i216 = alloca i64, align 8
  %22 = alloca i64, align 8
  %23 = alloca ptr, align 8
  %24 = alloca i64, align 8
  %elements_per_cell.i197 = alloca i64, align 8
  %size_of_cell.i198 = alloca i64, align 8
  %cell_index.i199 = alloca i64, align 8
  %data_index.i200 = alloca i64, align 8
  %size_of_type.i201 = alloca i64, align 8
  %cell_index2.i202 = alloca i64, align 8
  %data_index3.i203 = alloca i64, align 8
  %size_of_type4.i204 = alloca i64, align 8
  %25 = alloca i64, align 8
  %26 = alloca ptr, align 8
  %27 = alloca i64, align 8
  %elements_per_cell.i185 = alloca i64, align 8
  %size_of_cell.i186 = alloca i64, align 8
  %cell_index.i187 = alloca i64, align 8
  %data_index.i188 = alloca i64, align 8
  %size_of_type.i189 = alloca i64, align 8
  %cell_index2.i190 = alloca i64, align 8
  %data_index3.i191 = alloca i64, align 8
  %size_of_type4.i192 = alloca i64, align 8
  %28 = alloca i64, align 8
  %29 = alloca ptr, align 8
  %30 = alloca i64, align 8
  %elements_per_cell.i173 = alloca i64, align 8
  %size_of_cell.i174 = alloca i64, align 8
  %cell_index.i175 = alloca i64, align 8
  %data_index.i176 = alloca i64, align 8
  %size_of_type.i177 = alloca i64, align 8
  %cell_index2.i178 = alloca i64, align 8
  %data_index3.i179 = alloca i64, align 8
  %size_of_type4.i180 = alloca i64, align 8
  %31 = alloca i64, align 8
  %32 = alloca ptr, align 8
  %33 = alloca i64, align 8
  %elements_per_cell.i161 = alloca i64, align 8
  %size_of_cell.i162 = alloca i64, align 8
  %cell_index.i163 = alloca i64, align 8
  %data_index.i164 = alloca i64, align 8
  %size_of_type.i165 = alloca i64, align 8
  %cell_index2.i166 = alloca i64, align 8
  %data_index3.i167 = alloca i64, align 8
  %size_of_type4.i168 = alloca i64, align 8
  %34 = alloca i64, align 8
  %35 = alloca ptr, align 8
  %36 = alloca i64, align 8
  %elements_per_cell.i149 = alloca i64, align 8
  %size_of_cell.i150 = alloca i64, align 8
  %cell_index.i151 = alloca i64, align 8
  %data_index.i152 = alloca i64, align 8
  %size_of_type.i153 = alloca i64, align 8
  %cell_index2.i154 = alloca i64, align 8
  %data_index3.i155 = alloca i64, align 8
  %size_of_type4.i156 = alloca i64, align 8
  %37 = alloca i64, align 8
  %38 = alloca ptr, align 8
  %39 = alloca i64, align 8
  %elements_per_cell.i137 = alloca i64, align 8
  %size_of_cell.i138 = alloca i64, align 8
  %cell_index.i139 = alloca i64, align 8
  %data_index.i140 = alloca i64, align 8
  %size_of_type.i141 = alloca i64, align 8
  %cell_index2.i142 = alloca i64, align 8
  %data_index3.i143 = alloca i64, align 8
  %size_of_type4.i144 = alloca i64, align 8
  %40 = alloca i64, align 8
  %41 = alloca ptr, align 8
  %42 = alloca i64, align 8
  %elements_per_cell.i125 = alloca i64, align 8
  %size_of_cell.i126 = alloca i64, align 8
  %cell_index.i127 = alloca i64, align 8
  %data_index.i128 = alloca i64, align 8
  %size_of_type.i129 = alloca i64, align 8
  %cell_index2.i130 = alloca i64, align 8
  %data_index3.i131 = alloca i64, align 8
  %size_of_type4.i132 = alloca i64, align 8
  %43 = alloca i64, align 8
  %44 = alloca ptr, align 8
  %45 = alloca i64, align 8
  %elements_per_cell.i113 = alloca i64, align 8
  %size_of_cell.i114 = alloca i64, align 8
  %cell_index.i115 = alloca i64, align 8
  %data_index.i116 = alloca i64, align 8
  %size_of_type.i117 = alloca i64, align 8
  %cell_index2.i118 = alloca i64, align 8
  %data_index3.i119 = alloca i64, align 8
  %size_of_type4.i120 = alloca i64, align 8
  %46 = alloca i64, align 8
  %47 = alloca ptr, align 8
  %48 = alloca i64, align 8
  %elements_per_cell.i101 = alloca i64, align 8
  %size_of_cell.i102 = alloca i64, align 8
  %cell_index.i103 = alloca i64, align 8
  %data_index.i104 = alloca i64, align 8
  %size_of_type.i105 = alloca i64, align 8
  %cell_index2.i106 = alloca i64, align 8
  %data_index3.i107 = alloca i64, align 8
  %size_of_type4.i108 = alloca i64, align 8
  %49 = alloca i64, align 8
  %50 = alloca ptr, align 8
  %51 = alloca i64, align 8
  %elements_per_cell.i89 = alloca i64, align 8
  %size_of_cell.i90 = alloca i64, align 8
  %cell_index.i91 = alloca i64, align 8
  %data_index.i92 = alloca i64, align 8
  %size_of_type.i93 = alloca i64, align 8
  %cell_index2.i94 = alloca i64, align 8
  %data_index3.i95 = alloca i64, align 8
  %size_of_type4.i96 = alloca i64, align 8
  %52 = alloca i64, align 8
  %53 = alloca ptr, align 8
  %54 = alloca i64, align 8
  %elements_per_cell.i77 = alloca i64, align 8
  %size_of_cell.i78 = alloca i64, align 8
  %cell_index.i79 = alloca i64, align 8
  %data_index.i80 = alloca i64, align 8
  %size_of_type.i81 = alloca i64, align 8
  %cell_index2.i82 = alloca i64, align 8
  %data_index3.i83 = alloca i64, align 8
  %size_of_type4.i84 = alloca i64, align 8
  %55 = alloca i64, align 8
  %56 = alloca ptr, align 8
  %57 = alloca i64, align 8
  %elements_per_cell.i65 = alloca i64, align 8
  %size_of_cell.i66 = alloca i64, align 8
  %cell_index.i67 = alloca i64, align 8
  %data_index.i68 = alloca i64, align 8
  %size_of_type.i69 = alloca i64, align 8
  %cell_index2.i70 = alloca i64, align 8
  %data_index3.i71 = alloca i64, align 8
  %size_of_type4.i72 = alloca i64, align 8
  %58 = alloca i64, align 8
  %59 = alloca ptr, align 8
  %60 = alloca i64, align 8
  %elements_per_cell.i53 = alloca i64, align 8
  %size_of_cell.i54 = alloca i64, align 8
  %cell_index.i55 = alloca i64, align 8
  %data_index.i56 = alloca i64, align 8
  %size_of_type.i57 = alloca i64, align 8
  %cell_index2.i58 = alloca i64, align 8
  %data_index3.i59 = alloca i64, align 8
  %size_of_type4.i60 = alloca i64, align 8
  %61 = alloca i64, align 8
  %62 = alloca ptr, align 8
  %63 = alloca i64, align 8
  %elements_per_cell.i41 = alloca i64, align 8
  %size_of_cell.i42 = alloca i64, align 8
  %cell_index.i43 = alloca i64, align 8
  %data_index.i44 = alloca i64, align 8
  %size_of_type.i45 = alloca i64, align 8
  %cell_index2.i46 = alloca i64, align 8
  %data_index3.i47 = alloca i64, align 8
  %size_of_type4.i48 = alloca i64, align 8
  %64 = alloca i64, align 8
  %65 = alloca ptr, align 8
  %66 = alloca i64, align 8
  %elements_per_cell.i = alloca i64, align 8
  %size_of_cell.i = alloca i64, align 8
  %cell_index.i = alloca i64, align 8
  %data_index.i = alloca i64, align 8
  %size_of_type.i = alloca i64, align 8
  %cell_index2.i = alloca i64, align 8
  %data_index3.i = alloca i64, align 8
  %size_of_type4.i = alloca i64, align 8
  %67 = alloca ptr, align 8
  %68 = alloca ptr, align 8
  %69 = alloca i64, align 8
  %70 = alloca i64, align 8
  %71 = alloca i64, align 8
  %key = alloca i64, align 8
  %result = alloca i64, align 8
  %h = alloca i64, align 8
  %pos = alloca i64, align 8
  %distance = alloca i64, align 8
  %mask = alloca i64, align 8
  %72 = alloca i64, align 8
  %73 = alloca i64, align 8
  %74 = alloca ptr, align 8
  %75 = alloca i64, align 8
  %76 = alloca { i64, i64, ptr, i64, i64 }, align 8
  %ks = alloca i64, align 8
  %vs = alloca i64, align 8
  %hs = alloca ptr, align 8
  %sk = alloca i64, align 8
  %sv = alloca i64, align 8
  %size_of_k = alloca i64, align 8
  %size_of_v = alloca i64, align 8
  %k = alloca i64, align 8
  %v = alloca i64, align 8
  %tk = alloca i64, align 8
  %tv = alloca i64, align 8
  %element_hash = alloca i64, align 8
  %k_dst = alloca i64, align 8
  %v_dst = alloca i64, align 8
  %probe_distance = alloca i64, align 8
  %kp = alloca i64, align 8
  %vp = alloca i64, align 8
  %th = alloca i64, align 8
  %look_ahead = alloca i64, align 8
  %la_pos = alloca i64, align 8
  %element_hash12 = alloca i64, align 8
  %k_dst16 = alloca i64, align 8
  %v_dst17 = alloca i64, align 8
  %k_src = alloca i64, align 8
  %v_src = alloca i64, align 8
  %probe_distance22 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %67, align 8
  store ptr %1, ptr %68, align 8
  store i64 %2, ptr %69, align 8
  store i64 %3, ptr %70, align 8
  store i64 %4, ptr %71, align 8
  store i64 0, ptr %key, align 8
  store i64 0, ptr %result, align 8
  store i64 %2, ptr %h, align 8
  %77 = load i64, ptr %h, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr %capacity.i)
  store i64 %77, ptr %15, align 8
  %78 = load i64, ptr %0, align 8
  %79 = and i64 %78, 63
  %80 = shl i64 1, %79
  store i64 %80, ptr %capacity.i, align 8
  %81 = load i64, ptr %capacity.i, align 8
  %82 = sub i64 %81, 1
  %83 = and i64 %77, %82
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %capacity.i)
  store i64 %83, ptr %pos, align 8
  store i64 0, ptr %distance, align 8
  %84 = load i64, ptr %0, align 8
  %85 = and i64 %84, 63
  %86 = icmp ult i64 %85, 64
  %87 = shl i64 1, %85
  %88 = select i1 %86, i64 %87, i64 0
  %89 = sub i64 %88, 1
  store i64 %89, ptr %mask, align 8
  store i64 0, ptr %72, align 8
  store i64 0, ptr %73, align 8
  store ptr null, ptr %74, align 8
  store i64 0, ptr %75, align 8
  %90 = call i64 @"runtime::map_kvh_data_dynamic"(ptr %0, ptr %1, ptr %72, ptr %73, ptr %74, ptr %75)
  %91 = load i64, ptr %72, align 8
  %92 = load i64, ptr %73, align 8
  %93 = load ptr, ptr %74, align 8
  %94 = load i64, ptr %75, align 8
  store i64 %91, ptr %ks, align 8
  store i64 %92, ptr %vs, align 8
  store ptr %93, ptr %hs, align 8
  store i64 %94, ptr %sk, align 8
  store i64 %90, ptr %sv, align 8
  %95 = load ptr, ptr %68, align 8
  %96 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %95, i32 0, i32 0
  %97 = load ptr, ptr %96, align 8
  %98 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %97, i32 0, i32 0
  %99 = load i64, ptr %98, align 8
  store i64 %99, ptr %size_of_k, align 8
  %100 = load ptr, ptr %68, align 8
  %101 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %100, i32 0, i32 1
  %102 = load ptr, ptr %101, align 8
  %103 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %102, i32 0, i32 0
  %104 = load i64, ptr %103, align 8
  store i64 %104, ptr %size_of_v, align 8
  %105 = load i64, ptr %sk, align 8
  %106 = load ptr, ptr %68, align 8
  %107 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %106, i32 0, i32 0
  %108 = load ptr, ptr %107, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !141)
  call void @llvm.lifetime.start.p0(i64 8, ptr %19)
  call void @llvm.lifetime.start.p0(i64 8, ptr %20)
  call void @llvm.lifetime.start.p0(i64 8, ptr %21)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i209)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i210)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i211)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i212)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i213)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i214)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i215)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i216)
  store i64 %105, ptr %19, align 8, !noalias !141
  store ptr %108, ptr %20, align 8, !noalias !141
  store i64 0, ptr %21, align 8, !noalias !141
  %109 = load ptr, ptr %20, align 8, !noalias !141
  %110 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %109, i32 0, i32 3
  %111 = load i64, ptr %110, align 8
  store i64 %111, ptr %elements_per_cell.i209, align 8, !noalias !141
  %112 = load ptr, ptr %20, align 8, !noalias !141
  %113 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %112, i32 0, i32 2
  %114 = load i64, ptr %113, align 8
  store i64 %114, ptr %size_of_cell.i210, align 8, !noalias !141
  %115 = load i64, ptr %elements_per_cell.i209, align 8, !noalias !141
  switch i64 %115, label %switch.default.body.i219 [
    i64 1, label %switch.case.body.i218
    i64 2, label %switch.case.body1.i217
  ]

switch.case.body.i218:                            ; preds = %entry
  %116 = load i64, ptr %size_of_cell.i210, align 8, !noalias !141
  call void @llvm.lifetime.end.p0(i64 8, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i209)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i210)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i211)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i212)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i213)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i214)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i215)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i216)
  br label %"runtime::map_cell_index_dynamic.exit220"

switch.case.body1.i217:                           ; preds = %entry
  store i64 0, ptr %cell_index.i211, align 8, !noalias !141
  store i64 0, ptr %data_index.i212, align 8, !noalias !141
  %117 = load ptr, ptr %20, align 8, !noalias !141
  %118 = load i64, ptr %117, align 8
  store i64 %118, ptr %size_of_type.i213, align 8, !noalias !141
  %119 = load i64, ptr %cell_index.i211, align 8, !noalias !141
  %120 = load i64, ptr %size_of_cell.i210, align 8, !noalias !141
  %121 = mul i64 %119, %120
  %122 = add i64 %105, %121
  %123 = load i64, ptr %data_index.i212, align 8, !noalias !141
  %124 = load i64, ptr %size_of_type.i213, align 8, !noalias !141
  %125 = mul i64 %123, %124
  %126 = add i64 %122, %125
  call void @llvm.lifetime.end.p0(i64 8, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i209)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i210)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i211)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i212)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i213)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i214)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i215)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i216)
  br label %"runtime::map_cell_index_dynamic.exit220"

switch.default.body.i219:                         ; preds = %entry
  %127 = load i64, ptr %elements_per_cell.i209, align 8, !noalias !141
  store i64 0, ptr %cell_index2.i214, align 8, !noalias !141
  %128 = load i64, ptr %elements_per_cell.i209, align 8, !noalias !141
  store i64 0, ptr %data_index3.i215, align 8, !noalias !141
  %129 = load ptr, ptr %20, align 8, !noalias !141
  %130 = load i64, ptr %129, align 8
  store i64 %130, ptr %size_of_type4.i216, align 8, !noalias !141
  %131 = load i64, ptr %cell_index2.i214, align 8, !noalias !141
  %132 = load i64, ptr %size_of_cell.i210, align 8, !noalias !141
  %133 = mul i64 %131, %132
  %134 = add i64 %105, %133
  %135 = load i64, ptr %data_index3.i215, align 8, !noalias !141
  %136 = load i64, ptr %size_of_type4.i216, align 8, !noalias !141
  %137 = mul i64 %135, %136
  %138 = add i64 %134, %137
  call void @llvm.lifetime.end.p0(i64 8, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i209)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i210)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i211)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i212)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i213)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i214)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i215)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i216)
  br label %"runtime::map_cell_index_dynamic.exit220"

"runtime::map_cell_index_dynamic.exit220":        ; preds = %switch.default.body.i219, %switch.case.body1.i217, %switch.case.body.i218
  %139 = phi i64 [ %105, %switch.case.body.i218 ], [ %126, %switch.case.body1.i217 ], [ %138, %switch.default.body.i219 ]
  store i64 %139, ptr %k, align 8
  %140 = load i64, ptr %sv, align 8
  %141 = load ptr, ptr %68, align 8
  %142 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %141, i32 0, i32 1
  %143 = load ptr, ptr %142, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !144)
  call void @llvm.lifetime.start.p0(i64 8, ptr %22)
  call void @llvm.lifetime.start.p0(i64 8, ptr %23)
  call void @llvm.lifetime.start.p0(i64 8, ptr %24)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i197)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i198)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i199)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i200)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i201)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i202)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i203)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i204)
  store i64 %140, ptr %22, align 8, !noalias !144
  store ptr %143, ptr %23, align 8, !noalias !144
  store i64 0, ptr %24, align 8, !noalias !144
  %144 = load ptr, ptr %23, align 8, !noalias !144
  %145 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %144, i32 0, i32 3
  %146 = load i64, ptr %145, align 8
  store i64 %146, ptr %elements_per_cell.i197, align 8, !noalias !144
  %147 = load ptr, ptr %23, align 8, !noalias !144
  %148 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %147, i32 0, i32 2
  %149 = load i64, ptr %148, align 8
  store i64 %149, ptr %size_of_cell.i198, align 8, !noalias !144
  %150 = load i64, ptr %elements_per_cell.i197, align 8, !noalias !144
  switch i64 %150, label %switch.default.body.i207 [
    i64 1, label %switch.case.body.i206
    i64 2, label %switch.case.body1.i205
  ]

switch.case.body.i206:                            ; preds = %"runtime::map_cell_index_dynamic.exit220"
  %151 = load i64, ptr %size_of_cell.i198, align 8, !noalias !144
  call void @llvm.lifetime.end.p0(i64 8, ptr %22)
  call void @llvm.lifetime.end.p0(i64 8, ptr %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr %24)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i197)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i198)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i199)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i200)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i201)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i202)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i203)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i204)
  br label %"runtime::map_cell_index_dynamic.exit208"

switch.case.body1.i205:                           ; preds = %"runtime::map_cell_index_dynamic.exit220"
  store i64 0, ptr %cell_index.i199, align 8, !noalias !144
  store i64 0, ptr %data_index.i200, align 8, !noalias !144
  %152 = load ptr, ptr %23, align 8, !noalias !144
  %153 = load i64, ptr %152, align 8
  store i64 %153, ptr %size_of_type.i201, align 8, !noalias !144
  %154 = load i64, ptr %cell_index.i199, align 8, !noalias !144
  %155 = load i64, ptr %size_of_cell.i198, align 8, !noalias !144
  %156 = mul i64 %154, %155
  %157 = add i64 %140, %156
  %158 = load i64, ptr %data_index.i200, align 8, !noalias !144
  %159 = load i64, ptr %size_of_type.i201, align 8, !noalias !144
  %160 = mul i64 %158, %159
  %161 = add i64 %157, %160
  call void @llvm.lifetime.end.p0(i64 8, ptr %22)
  call void @llvm.lifetime.end.p0(i64 8, ptr %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr %24)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i197)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i198)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i199)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i200)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i201)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i202)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i203)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i204)
  br label %"runtime::map_cell_index_dynamic.exit208"

switch.default.body.i207:                         ; preds = %"runtime::map_cell_index_dynamic.exit220"
  %162 = load i64, ptr %elements_per_cell.i197, align 8, !noalias !144
  store i64 0, ptr %cell_index2.i202, align 8, !noalias !144
  %163 = load i64, ptr %elements_per_cell.i197, align 8, !noalias !144
  store i64 0, ptr %data_index3.i203, align 8, !noalias !144
  %164 = load ptr, ptr %23, align 8, !noalias !144
  %165 = load i64, ptr %164, align 8
  store i64 %165, ptr %size_of_type4.i204, align 8, !noalias !144
  %166 = load i64, ptr %cell_index2.i202, align 8, !noalias !144
  %167 = load i64, ptr %size_of_cell.i198, align 8, !noalias !144
  %168 = mul i64 %166, %167
  %169 = add i64 %140, %168
  %170 = load i64, ptr %data_index3.i203, align 8, !noalias !144
  %171 = load i64, ptr %size_of_type4.i204, align 8, !noalias !144
  %172 = mul i64 %170, %171
  %173 = add i64 %169, %172
  call void @llvm.lifetime.end.p0(i64 8, ptr %22)
  call void @llvm.lifetime.end.p0(i64 8, ptr %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr %24)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i197)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i198)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i199)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i200)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i201)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i202)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i203)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i204)
  br label %"runtime::map_cell_index_dynamic.exit208"

"runtime::map_cell_index_dynamic.exit208":        ; preds = %switch.default.body.i207, %switch.case.body1.i205, %switch.case.body.i206
  %174 = phi i64 [ %140, %switch.case.body.i206 ], [ %161, %switch.case.body1.i205 ], [ %173, %switch.default.body.i207 ]
  store i64 %174, ptr %v, align 8
  %175 = load i64, ptr %k, align 8
  %176 = inttoptr i64 %175 to ptr
  %177 = inttoptr i64 %3 to ptr
  %178 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %176, ptr %177, i64 %178, i1 false)
  %179 = load i64, ptr %v, align 8
  %180 = inttoptr i64 %179 to ptr
  %181 = inttoptr i64 %4 to ptr
  %182 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %180, ptr %181, i64 %182, i1 false)
  %183 = load i64, ptr %sk, align 8
  %184 = load ptr, ptr %68, align 8
  %185 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %184, i32 0, i32 0
  %186 = load ptr, ptr %185, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !147)
  call void @llvm.lifetime.start.p0(i64 8, ptr %25)
  call void @llvm.lifetime.start.p0(i64 8, ptr %26)
  call void @llvm.lifetime.start.p0(i64 8, ptr %27)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i185)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i186)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i187)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i188)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i189)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i190)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i191)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i192)
  store i64 %183, ptr %25, align 8, !noalias !147
  store ptr %186, ptr %26, align 8, !noalias !147
  store i64 1, ptr %27, align 8, !noalias !147
  %187 = load ptr, ptr %26, align 8, !noalias !147
  %188 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %187, i32 0, i32 3
  %189 = load i64, ptr %188, align 8
  store i64 %189, ptr %elements_per_cell.i185, align 8, !noalias !147
  %190 = load ptr, ptr %26, align 8, !noalias !147
  %191 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %190, i32 0, i32 2
  %192 = load i64, ptr %191, align 8
  store i64 %192, ptr %size_of_cell.i186, align 8, !noalias !147
  %193 = load i64, ptr %elements_per_cell.i185, align 8, !noalias !147
  switch i64 %193, label %switch.default.body.i195 [
    i64 1, label %switch.case.body.i194
    i64 2, label %switch.case.body1.i193
  ]

switch.case.body.i194:                            ; preds = %"runtime::map_cell_index_dynamic.exit208"
  %194 = load i64, ptr %size_of_cell.i186, align 8, !noalias !147
  %195 = add i64 %183, %194
  call void @llvm.lifetime.end.p0(i64 8, ptr %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr %26)
  call void @llvm.lifetime.end.p0(i64 8, ptr %27)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i185)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i186)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i187)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i188)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i189)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i190)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i191)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i192)
  br label %"runtime::map_cell_index_dynamic.exit196"

switch.case.body1.i193:                           ; preds = %"runtime::map_cell_index_dynamic.exit208"
  store i64 0, ptr %cell_index.i187, align 8, !noalias !147
  store i64 1, ptr %data_index.i188, align 8, !noalias !147
  %196 = load ptr, ptr %26, align 8, !noalias !147
  %197 = load i64, ptr %196, align 8
  store i64 %197, ptr %size_of_type.i189, align 8, !noalias !147
  %198 = load i64, ptr %cell_index.i187, align 8, !noalias !147
  %199 = load i64, ptr %size_of_cell.i186, align 8, !noalias !147
  %200 = mul i64 %198, %199
  %201 = add i64 %183, %200
  %202 = load i64, ptr %data_index.i188, align 8, !noalias !147
  %203 = load i64, ptr %size_of_type.i189, align 8, !noalias !147
  %204 = mul i64 %202, %203
  %205 = add i64 %201, %204
  call void @llvm.lifetime.end.p0(i64 8, ptr %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr %26)
  call void @llvm.lifetime.end.p0(i64 8, ptr %27)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i185)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i186)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i187)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i188)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i189)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i190)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i191)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i192)
  br label %"runtime::map_cell_index_dynamic.exit196"

switch.default.body.i195:                         ; preds = %"runtime::map_cell_index_dynamic.exit208"
  %206 = load i64, ptr %elements_per_cell.i185, align 8, !noalias !147
  %207 = udiv i64 1, %206
  store i64 %207, ptr %cell_index2.i190, align 8, !noalias !147
  %208 = load i64, ptr %elements_per_cell.i185, align 8, !noalias !147
  %209 = urem i64 1, %208
  store i64 %209, ptr %data_index3.i191, align 8, !noalias !147
  %210 = load ptr, ptr %26, align 8, !noalias !147
  %211 = load i64, ptr %210, align 8
  store i64 %211, ptr %size_of_type4.i192, align 8, !noalias !147
  %212 = load i64, ptr %cell_index2.i190, align 8, !noalias !147
  %213 = load i64, ptr %size_of_cell.i186, align 8, !noalias !147
  %214 = mul i64 %212, %213
  %215 = add i64 %183, %214
  %216 = load i64, ptr %data_index3.i191, align 8, !noalias !147
  %217 = load i64, ptr %size_of_type4.i192, align 8, !noalias !147
  %218 = mul i64 %216, %217
  %219 = add i64 %215, %218
  call void @llvm.lifetime.end.p0(i64 8, ptr %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr %26)
  call void @llvm.lifetime.end.p0(i64 8, ptr %27)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i185)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i186)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i187)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i188)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i189)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i190)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i191)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i192)
  br label %"runtime::map_cell_index_dynamic.exit196"

"runtime::map_cell_index_dynamic.exit196":        ; preds = %switch.default.body.i195, %switch.case.body1.i193, %switch.case.body.i194
  %220 = phi i64 [ %195, %switch.case.body.i194 ], [ %205, %switch.case.body1.i193 ], [ %219, %switch.default.body.i195 ]
  store i64 %220, ptr %tk, align 8
  %221 = load i64, ptr %sv, align 8
  %222 = load ptr, ptr %68, align 8
  %223 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %222, i32 0, i32 1
  %224 = load ptr, ptr %223, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !150)
  call void @llvm.lifetime.start.p0(i64 8, ptr %28)
  call void @llvm.lifetime.start.p0(i64 8, ptr %29)
  call void @llvm.lifetime.start.p0(i64 8, ptr %30)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i173)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i174)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i175)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i176)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i177)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i178)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i179)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i180)
  store i64 %221, ptr %28, align 8, !noalias !150
  store ptr %224, ptr %29, align 8, !noalias !150
  store i64 1, ptr %30, align 8, !noalias !150
  %225 = load ptr, ptr %29, align 8, !noalias !150
  %226 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %225, i32 0, i32 3
  %227 = load i64, ptr %226, align 8
  store i64 %227, ptr %elements_per_cell.i173, align 8, !noalias !150
  %228 = load ptr, ptr %29, align 8, !noalias !150
  %229 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %228, i32 0, i32 2
  %230 = load i64, ptr %229, align 8
  store i64 %230, ptr %size_of_cell.i174, align 8, !noalias !150
  %231 = load i64, ptr %elements_per_cell.i173, align 8, !noalias !150
  switch i64 %231, label %switch.default.body.i183 [
    i64 1, label %switch.case.body.i182
    i64 2, label %switch.case.body1.i181
  ]

switch.case.body.i182:                            ; preds = %"runtime::map_cell_index_dynamic.exit196"
  %232 = load i64, ptr %size_of_cell.i174, align 8, !noalias !150
  %233 = add i64 %221, %232
  call void @llvm.lifetime.end.p0(i64 8, ptr %28)
  call void @llvm.lifetime.end.p0(i64 8, ptr %29)
  call void @llvm.lifetime.end.p0(i64 8, ptr %30)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i173)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i174)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i175)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i176)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i177)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i178)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i179)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i180)
  br label %"runtime::map_cell_index_dynamic.exit184"

switch.case.body1.i181:                           ; preds = %"runtime::map_cell_index_dynamic.exit196"
  store i64 0, ptr %cell_index.i175, align 8, !noalias !150
  store i64 1, ptr %data_index.i176, align 8, !noalias !150
  %234 = load ptr, ptr %29, align 8, !noalias !150
  %235 = load i64, ptr %234, align 8
  store i64 %235, ptr %size_of_type.i177, align 8, !noalias !150
  %236 = load i64, ptr %cell_index.i175, align 8, !noalias !150
  %237 = load i64, ptr %size_of_cell.i174, align 8, !noalias !150
  %238 = mul i64 %236, %237
  %239 = add i64 %221, %238
  %240 = load i64, ptr %data_index.i176, align 8, !noalias !150
  %241 = load i64, ptr %size_of_type.i177, align 8, !noalias !150
  %242 = mul i64 %240, %241
  %243 = add i64 %239, %242
  call void @llvm.lifetime.end.p0(i64 8, ptr %28)
  call void @llvm.lifetime.end.p0(i64 8, ptr %29)
  call void @llvm.lifetime.end.p0(i64 8, ptr %30)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i173)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i174)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i175)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i176)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i177)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i178)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i179)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i180)
  br label %"runtime::map_cell_index_dynamic.exit184"

switch.default.body.i183:                         ; preds = %"runtime::map_cell_index_dynamic.exit196"
  %244 = load i64, ptr %elements_per_cell.i173, align 8, !noalias !150
  %245 = udiv i64 1, %244
  store i64 %245, ptr %cell_index2.i178, align 8, !noalias !150
  %246 = load i64, ptr %elements_per_cell.i173, align 8, !noalias !150
  %247 = urem i64 1, %246
  store i64 %247, ptr %data_index3.i179, align 8, !noalias !150
  %248 = load ptr, ptr %29, align 8, !noalias !150
  %249 = load i64, ptr %248, align 8
  store i64 %249, ptr %size_of_type4.i180, align 8, !noalias !150
  %250 = load i64, ptr %cell_index2.i178, align 8, !noalias !150
  %251 = load i64, ptr %size_of_cell.i174, align 8, !noalias !150
  %252 = mul i64 %250, %251
  %253 = add i64 %221, %252
  %254 = load i64, ptr %data_index3.i179, align 8, !noalias !150
  %255 = load i64, ptr %size_of_type4.i180, align 8, !noalias !150
  %256 = mul i64 %254, %255
  %257 = add i64 %253, %256
  call void @llvm.lifetime.end.p0(i64 8, ptr %28)
  call void @llvm.lifetime.end.p0(i64 8, ptr %29)
  call void @llvm.lifetime.end.p0(i64 8, ptr %30)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i173)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i174)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i175)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i176)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i177)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i178)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i179)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i180)
  br label %"runtime::map_cell_index_dynamic.exit184"

"runtime::map_cell_index_dynamic.exit184":        ; preds = %switch.default.body.i183, %switch.case.body1.i181, %switch.case.body.i182
  %258 = phi i64 [ %233, %switch.case.body.i182 ], [ %243, %switch.case.body1.i181 ], [ %257, %switch.default.body.i183 ]
  store i64 %258, ptr %tv, align 8
  br label %for.body

for.body:                                         ; preds = %if.done10, %"runtime::map_cell_index_dynamic.exit184"
  %259 = load i64, ptr %distance, align 8
  %260 = load i64, ptr %mask, align 8
  %261 = icmp ugt i64 %259, %260
  %262 = zext i1 %261 to i8
  %263 = icmp ne i8 %262, 0
  br i1 %263, label %if.then, label %if.done

if.then:                                          ; preds = %for.body
  call void @"runtime::panic"(ptr @"ggv$runtime::map_insert_hash_dynamic_with_key$1", ptr @"scl$[map_insert_hash_dynamic_with_key18063]", ptr %__.context_ptr)
  unreachable

if.done:                                          ; preds = %for.body
  %264 = load ptr, ptr %hs, align 8
  %265 = load i64, ptr %pos, align 8
  %266 = getelementptr i64, ptr %264, i64 %265
  %267 = load i64, ptr %266, align 8
  store i64 %267, ptr %element_hash, align 8
  %268 = load i64, ptr %element_hash, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %16)
  store i64 %268, ptr %16, align 8
  %269 = icmp eq i64 %268, 0
  %270 = zext i1 %269 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  %271 = icmp ne i8 %270, 0
  br i1 %271, label %if.then1, label %if.done4

if.then1:                                         ; preds = %if.done
  %272 = load i64, ptr %ks, align 8
  %273 = load ptr, ptr %68, align 8
  %274 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %273, i32 0, i32 0
  %275 = load ptr, ptr %274, align 8
  %276 = load i64, ptr %pos, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !153)
  call void @llvm.lifetime.start.p0(i64 8, ptr %31)
  call void @llvm.lifetime.start.p0(i64 8, ptr %32)
  call void @llvm.lifetime.start.p0(i64 8, ptr %33)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i161)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i162)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i163)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i164)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i165)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i166)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i167)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i168)
  store i64 %272, ptr %31, align 8, !noalias !153
  store ptr %275, ptr %32, align 8, !noalias !153
  store i64 %276, ptr %33, align 8, !noalias !153
  %277 = load ptr, ptr %32, align 8, !noalias !153
  %278 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %277, i32 0, i32 3
  %279 = load i64, ptr %278, align 8
  store i64 %279, ptr %elements_per_cell.i161, align 8, !noalias !153
  %280 = load ptr, ptr %32, align 8, !noalias !153
  %281 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %280, i32 0, i32 2
  %282 = load i64, ptr %281, align 8
  store i64 %282, ptr %size_of_cell.i162, align 8, !noalias !153
  %283 = load i64, ptr %elements_per_cell.i161, align 8, !noalias !153
  switch i64 %283, label %switch.default.body.i171 [
    i64 1, label %switch.case.body.i170
    i64 2, label %switch.case.body1.i169
  ]

switch.case.body.i170:                            ; preds = %if.then1
  %284 = load i64, ptr %size_of_cell.i162, align 8, !noalias !153
  %285 = mul i64 %276, %284
  %286 = add i64 %272, %285
  call void @llvm.lifetime.end.p0(i64 8, ptr %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr %32)
  call void @llvm.lifetime.end.p0(i64 8, ptr %33)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i161)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i162)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i163)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i164)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i165)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i166)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i167)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i168)
  br label %"runtime::map_cell_index_dynamic.exit172"

switch.case.body1.i169:                           ; preds = %if.then1
  %287 = lshr i64 %276, 1
  store i64 %287, ptr %cell_index.i163, align 8, !noalias !153
  %288 = and i64 %276, 1
  store i64 %288, ptr %data_index.i164, align 8, !noalias !153
  %289 = load ptr, ptr %32, align 8, !noalias !153
  %290 = load i64, ptr %289, align 8
  store i64 %290, ptr %size_of_type.i165, align 8, !noalias !153
  %291 = load i64, ptr %cell_index.i163, align 8, !noalias !153
  %292 = load i64, ptr %size_of_cell.i162, align 8, !noalias !153
  %293 = mul i64 %291, %292
  %294 = add i64 %272, %293
  %295 = load i64, ptr %data_index.i164, align 8, !noalias !153
  %296 = load i64, ptr %size_of_type.i165, align 8, !noalias !153
  %297 = mul i64 %295, %296
  %298 = add i64 %294, %297
  call void @llvm.lifetime.end.p0(i64 8, ptr %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr %32)
  call void @llvm.lifetime.end.p0(i64 8, ptr %33)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i161)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i162)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i163)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i164)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i165)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i166)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i167)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i168)
  br label %"runtime::map_cell_index_dynamic.exit172"

switch.default.body.i171:                         ; preds = %if.then1
  %299 = load i64, ptr %elements_per_cell.i161, align 8, !noalias !153
  %300 = udiv i64 %276, %299
  store i64 %300, ptr %cell_index2.i166, align 8, !noalias !153
  %301 = load i64, ptr %elements_per_cell.i161, align 8, !noalias !153
  %302 = urem i64 %276, %301
  store i64 %302, ptr %data_index3.i167, align 8, !noalias !153
  %303 = load ptr, ptr %32, align 8, !noalias !153
  %304 = load i64, ptr %303, align 8
  store i64 %304, ptr %size_of_type4.i168, align 8, !noalias !153
  %305 = load i64, ptr %cell_index2.i166, align 8, !noalias !153
  %306 = load i64, ptr %size_of_cell.i162, align 8, !noalias !153
  %307 = mul i64 %305, %306
  %308 = add i64 %272, %307
  %309 = load i64, ptr %data_index3.i167, align 8, !noalias !153
  %310 = load i64, ptr %size_of_type4.i168, align 8, !noalias !153
  %311 = mul i64 %309, %310
  %312 = add i64 %308, %311
  call void @llvm.lifetime.end.p0(i64 8, ptr %31)
  call void @llvm.lifetime.end.p0(i64 8, ptr %32)
  call void @llvm.lifetime.end.p0(i64 8, ptr %33)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i161)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i162)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i163)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i164)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i165)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i166)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i167)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i168)
  br label %"runtime::map_cell_index_dynamic.exit172"

"runtime::map_cell_index_dynamic.exit172":        ; preds = %switch.default.body.i171, %switch.case.body1.i169, %switch.case.body.i170
  %313 = phi i64 [ %286, %switch.case.body.i170 ], [ %298, %switch.case.body1.i169 ], [ %312, %switch.default.body.i171 ]
  store i64 %313, ptr %k_dst, align 8
  %314 = load i64, ptr %vs, align 8
  %315 = load ptr, ptr %68, align 8
  %316 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %315, i32 0, i32 1
  %317 = load ptr, ptr %316, align 8
  %318 = load i64, ptr %pos, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !156)
  call void @llvm.lifetime.start.p0(i64 8, ptr %34)
  call void @llvm.lifetime.start.p0(i64 8, ptr %35)
  call void @llvm.lifetime.start.p0(i64 8, ptr %36)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i149)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i150)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i151)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i152)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i153)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i154)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i155)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i156)
  store i64 %314, ptr %34, align 8, !noalias !156
  store ptr %317, ptr %35, align 8, !noalias !156
  store i64 %318, ptr %36, align 8, !noalias !156
  %319 = load ptr, ptr %35, align 8, !noalias !156
  %320 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %319, i32 0, i32 3
  %321 = load i64, ptr %320, align 8
  store i64 %321, ptr %elements_per_cell.i149, align 8, !noalias !156
  %322 = load ptr, ptr %35, align 8, !noalias !156
  %323 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %322, i32 0, i32 2
  %324 = load i64, ptr %323, align 8
  store i64 %324, ptr %size_of_cell.i150, align 8, !noalias !156
  %325 = load i64, ptr %elements_per_cell.i149, align 8, !noalias !156
  switch i64 %325, label %switch.default.body.i159 [
    i64 1, label %switch.case.body.i158
    i64 2, label %switch.case.body1.i157
  ]

switch.case.body.i158:                            ; preds = %"runtime::map_cell_index_dynamic.exit172"
  %326 = load i64, ptr %size_of_cell.i150, align 8, !noalias !156
  %327 = mul i64 %318, %326
  %328 = add i64 %314, %327
  call void @llvm.lifetime.end.p0(i64 8, ptr %34)
  call void @llvm.lifetime.end.p0(i64 8, ptr %35)
  call void @llvm.lifetime.end.p0(i64 8, ptr %36)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i149)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i150)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i151)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i152)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i153)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i154)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i155)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i156)
  br label %"runtime::map_cell_index_dynamic.exit160"

switch.case.body1.i157:                           ; preds = %"runtime::map_cell_index_dynamic.exit172"
  %329 = lshr i64 %318, 1
  store i64 %329, ptr %cell_index.i151, align 8, !noalias !156
  %330 = and i64 %318, 1
  store i64 %330, ptr %data_index.i152, align 8, !noalias !156
  %331 = load ptr, ptr %35, align 8, !noalias !156
  %332 = load i64, ptr %331, align 8
  store i64 %332, ptr %size_of_type.i153, align 8, !noalias !156
  %333 = load i64, ptr %cell_index.i151, align 8, !noalias !156
  %334 = load i64, ptr %size_of_cell.i150, align 8, !noalias !156
  %335 = mul i64 %333, %334
  %336 = add i64 %314, %335
  %337 = load i64, ptr %data_index.i152, align 8, !noalias !156
  %338 = load i64, ptr %size_of_type.i153, align 8, !noalias !156
  %339 = mul i64 %337, %338
  %340 = add i64 %336, %339
  call void @llvm.lifetime.end.p0(i64 8, ptr %34)
  call void @llvm.lifetime.end.p0(i64 8, ptr %35)
  call void @llvm.lifetime.end.p0(i64 8, ptr %36)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i149)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i150)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i151)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i152)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i153)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i154)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i155)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i156)
  br label %"runtime::map_cell_index_dynamic.exit160"

switch.default.body.i159:                         ; preds = %"runtime::map_cell_index_dynamic.exit172"
  %341 = load i64, ptr %elements_per_cell.i149, align 8, !noalias !156
  %342 = udiv i64 %318, %341
  store i64 %342, ptr %cell_index2.i154, align 8, !noalias !156
  %343 = load i64, ptr %elements_per_cell.i149, align 8, !noalias !156
  %344 = urem i64 %318, %343
  store i64 %344, ptr %data_index3.i155, align 8, !noalias !156
  %345 = load ptr, ptr %35, align 8, !noalias !156
  %346 = load i64, ptr %345, align 8
  store i64 %346, ptr %size_of_type4.i156, align 8, !noalias !156
  %347 = load i64, ptr %cell_index2.i154, align 8, !noalias !156
  %348 = load i64, ptr %size_of_cell.i150, align 8, !noalias !156
  %349 = mul i64 %347, %348
  %350 = add i64 %314, %349
  %351 = load i64, ptr %data_index3.i155, align 8, !noalias !156
  %352 = load i64, ptr %size_of_type4.i156, align 8, !noalias !156
  %353 = mul i64 %351, %352
  %354 = add i64 %350, %353
  call void @llvm.lifetime.end.p0(i64 8, ptr %34)
  call void @llvm.lifetime.end.p0(i64 8, ptr %35)
  call void @llvm.lifetime.end.p0(i64 8, ptr %36)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i149)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i150)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i151)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i152)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i153)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i154)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i155)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i156)
  br label %"runtime::map_cell_index_dynamic.exit160"

"runtime::map_cell_index_dynamic.exit160":        ; preds = %switch.default.body.i159, %switch.case.body1.i157, %switch.case.body.i158
  %355 = phi i64 [ %328, %switch.case.body.i158 ], [ %340, %switch.case.body1.i157 ], [ %354, %switch.default.body.i159 ]
  store i64 %355, ptr %v_dst, align 8
  %356 = load i64, ptr %k_dst, align 8
  %357 = inttoptr i64 %356 to ptr
  %358 = load i64, ptr %k, align 8
  %359 = inttoptr i64 %358 to ptr
  %360 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %357, ptr %359, i64 %360, i1 false)
  %361 = load i64, ptr %v_dst, align 8
  %362 = inttoptr i64 %361 to ptr
  %363 = load i64, ptr %v, align 8
  %364 = inttoptr i64 %363 to ptr
  %365 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %362, ptr %364, i64 %365, i1 false)
  %366 = load ptr, ptr %hs, align 8
  %367 = load i64, ptr %pos, align 8
  %368 = getelementptr i64, ptr %366, i64 %367
  %369 = load i64, ptr %h, align 8
  store i64 %369, ptr %368, align 8
  %370 = load i64, ptr %result, align 8
  %371 = icmp eq i64 %370, 0
  %372 = zext i1 %371 to i8
  %373 = icmp ne i8 %372, 0
  br i1 %373, label %if.then2, label %if.done3

if.then2:                                         ; preds = %"runtime::map_cell_index_dynamic.exit160"
  %374 = load i64, ptr %k_dst, align 8
  store i64 %374, ptr %key, align 8
  %375 = load i64, ptr %v_dst, align 8
  store i64 %375, ptr %result, align 8
  br label %if.done3

if.done3:                                         ; preds = %if.then2, %"runtime::map_cell_index_dynamic.exit160"
  %376 = load i64, ptr %key, align 8
  %377 = load i64, ptr %result, align 8
  store i64 %376, ptr %key, align 8
  store i64 %377, ptr %result, align 8
  store i64 %376, ptr %5, align 8
  ret i64 %377

if.done4:                                         ; preds = %if.done
  %378 = load i64, ptr %element_hash, align 8
  %379 = call i8 @"runtime::map_hash_is_deleted"(i64 %378)
  %380 = icmp ne i8 %379, 0
  br i1 %380, label %if.then5, label %if.done6

if.then5:                                         ; preds = %if.done4
  br label %for.done

unreachable:                                      ; No predecessors!
  br label %if.done6

if.done6:                                         ; preds = %unreachable, %if.done4
  br label %if.init

if.init:                                          ; preds = %if.done6
  %381 = load i64, ptr %element_hash, align 8
  %382 = load i64, ptr %pos, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %capacity.i225)
  store i64 %381, ptr %7, align 8
  store i64 %382, ptr %8, align 8
  %383 = load i64, ptr %0, align 8
  %384 = and i64 %383, 63
  %385 = shl i64 1, %384
  store i64 %385, ptr %capacity.i225, align 8
  %386 = load i64, ptr %capacity.i225, align 8
  %387 = add i64 %382, %386
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %capacity.i.i224)
  store i64 %381, ptr %6, align 8
  %388 = load i64, ptr %0, align 8
  %389 = and i64 %388, 63
  %390 = shl i64 1, %389
  store i64 %390, ptr %capacity.i.i224, align 8
  %391 = load i64, ptr %capacity.i.i224, align 8
  %392 = sub i64 %391, 1
  %393 = and i64 %381, %392
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %capacity.i.i224)
  %394 = sub i64 %387, %393
  %395 = load i64, ptr %capacity.i225, align 8
  %396 = sub i64 %395, 1
  %397 = and i64 %394, %396
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %capacity.i225)
  store i64 %397, ptr %probe_distance, align 8
  %398 = load i64, ptr %distance, align 8
  %399 = load i64, ptr %probe_distance, align 8
  %400 = icmp ugt i64 %398, %399
  %401 = zext i1 %400 to i8
  %402 = icmp ne i8 %401, 0
  br i1 %402, label %if.then7, label %if.done10

if.then7:                                         ; preds = %if.init
  %403 = load i64, ptr %ks, align 8
  %404 = load ptr, ptr %68, align 8
  %405 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %404, i32 0, i32 0
  %406 = load ptr, ptr %405, align 8
  %407 = load i64, ptr %pos, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !159)
  call void @llvm.lifetime.start.p0(i64 8, ptr %37)
  call void @llvm.lifetime.start.p0(i64 8, ptr %38)
  call void @llvm.lifetime.start.p0(i64 8, ptr %39)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i137)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i138)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i139)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i140)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i141)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i142)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i143)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i144)
  store i64 %403, ptr %37, align 8, !noalias !159
  store ptr %406, ptr %38, align 8, !noalias !159
  store i64 %407, ptr %39, align 8, !noalias !159
  %408 = load ptr, ptr %38, align 8, !noalias !159
  %409 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %408, i32 0, i32 3
  %410 = load i64, ptr %409, align 8
  store i64 %410, ptr %elements_per_cell.i137, align 8, !noalias !159
  %411 = load ptr, ptr %38, align 8, !noalias !159
  %412 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %411, i32 0, i32 2
  %413 = load i64, ptr %412, align 8
  store i64 %413, ptr %size_of_cell.i138, align 8, !noalias !159
  %414 = load i64, ptr %elements_per_cell.i137, align 8, !noalias !159
  switch i64 %414, label %switch.default.body.i147 [
    i64 1, label %switch.case.body.i146
    i64 2, label %switch.case.body1.i145
  ]

switch.case.body.i146:                            ; preds = %if.then7
  %415 = load i64, ptr %size_of_cell.i138, align 8, !noalias !159
  %416 = mul i64 %407, %415
  %417 = add i64 %403, %416
  call void @llvm.lifetime.end.p0(i64 8, ptr %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i137)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i138)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i139)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i140)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i141)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i142)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i143)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i144)
  br label %"runtime::map_cell_index_dynamic.exit148"

switch.case.body1.i145:                           ; preds = %if.then7
  %418 = lshr i64 %407, 1
  store i64 %418, ptr %cell_index.i139, align 8, !noalias !159
  %419 = and i64 %407, 1
  store i64 %419, ptr %data_index.i140, align 8, !noalias !159
  %420 = load ptr, ptr %38, align 8, !noalias !159
  %421 = load i64, ptr %420, align 8
  store i64 %421, ptr %size_of_type.i141, align 8, !noalias !159
  %422 = load i64, ptr %cell_index.i139, align 8, !noalias !159
  %423 = load i64, ptr %size_of_cell.i138, align 8, !noalias !159
  %424 = mul i64 %422, %423
  %425 = add i64 %403, %424
  %426 = load i64, ptr %data_index.i140, align 8, !noalias !159
  %427 = load i64, ptr %size_of_type.i141, align 8, !noalias !159
  %428 = mul i64 %426, %427
  %429 = add i64 %425, %428
  call void @llvm.lifetime.end.p0(i64 8, ptr %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i137)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i138)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i139)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i140)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i141)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i142)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i143)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i144)
  br label %"runtime::map_cell_index_dynamic.exit148"

switch.default.body.i147:                         ; preds = %if.then7
  %430 = load i64, ptr %elements_per_cell.i137, align 8, !noalias !159
  %431 = udiv i64 %407, %430
  store i64 %431, ptr %cell_index2.i142, align 8, !noalias !159
  %432 = load i64, ptr %elements_per_cell.i137, align 8, !noalias !159
  %433 = urem i64 %407, %432
  store i64 %433, ptr %data_index3.i143, align 8, !noalias !159
  %434 = load ptr, ptr %38, align 8, !noalias !159
  %435 = load i64, ptr %434, align 8
  store i64 %435, ptr %size_of_type4.i144, align 8, !noalias !159
  %436 = load i64, ptr %cell_index2.i142, align 8, !noalias !159
  %437 = load i64, ptr %size_of_cell.i138, align 8, !noalias !159
  %438 = mul i64 %436, %437
  %439 = add i64 %403, %438
  %440 = load i64, ptr %data_index3.i143, align 8, !noalias !159
  %441 = load i64, ptr %size_of_type4.i144, align 8, !noalias !159
  %442 = mul i64 %440, %441
  %443 = add i64 %439, %442
  call void @llvm.lifetime.end.p0(i64 8, ptr %37)
  call void @llvm.lifetime.end.p0(i64 8, ptr %38)
  call void @llvm.lifetime.end.p0(i64 8, ptr %39)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i137)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i138)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i139)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i140)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i141)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i142)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i143)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i144)
  br label %"runtime::map_cell_index_dynamic.exit148"

"runtime::map_cell_index_dynamic.exit148":        ; preds = %switch.default.body.i147, %switch.case.body1.i145, %switch.case.body.i146
  %444 = phi i64 [ %417, %switch.case.body.i146 ], [ %429, %switch.case.body1.i145 ], [ %443, %switch.default.body.i147 ]
  store i64 %444, ptr %kp, align 8
  %445 = load i64, ptr %vs, align 8
  %446 = load ptr, ptr %68, align 8
  %447 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %446, i32 0, i32 1
  %448 = load ptr, ptr %447, align 8
  %449 = load i64, ptr %pos, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !162)
  call void @llvm.lifetime.start.p0(i64 8, ptr %40)
  call void @llvm.lifetime.start.p0(i64 8, ptr %41)
  call void @llvm.lifetime.start.p0(i64 8, ptr %42)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i125)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i126)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i127)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i128)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i129)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i130)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i131)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i132)
  store i64 %445, ptr %40, align 8, !noalias !162
  store ptr %448, ptr %41, align 8, !noalias !162
  store i64 %449, ptr %42, align 8, !noalias !162
  %450 = load ptr, ptr %41, align 8, !noalias !162
  %451 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %450, i32 0, i32 3
  %452 = load i64, ptr %451, align 8
  store i64 %452, ptr %elements_per_cell.i125, align 8, !noalias !162
  %453 = load ptr, ptr %41, align 8, !noalias !162
  %454 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %453, i32 0, i32 2
  %455 = load i64, ptr %454, align 8
  store i64 %455, ptr %size_of_cell.i126, align 8, !noalias !162
  %456 = load i64, ptr %elements_per_cell.i125, align 8, !noalias !162
  switch i64 %456, label %switch.default.body.i135 [
    i64 1, label %switch.case.body.i134
    i64 2, label %switch.case.body1.i133
  ]

switch.case.body.i134:                            ; preds = %"runtime::map_cell_index_dynamic.exit148"
  %457 = load i64, ptr %size_of_cell.i126, align 8, !noalias !162
  %458 = mul i64 %449, %457
  %459 = add i64 %445, %458
  call void @llvm.lifetime.end.p0(i64 8, ptr %40)
  call void @llvm.lifetime.end.p0(i64 8, ptr %41)
  call void @llvm.lifetime.end.p0(i64 8, ptr %42)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i125)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i126)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i127)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i128)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i129)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i130)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i131)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i132)
  br label %"runtime::map_cell_index_dynamic.exit136"

switch.case.body1.i133:                           ; preds = %"runtime::map_cell_index_dynamic.exit148"
  %460 = lshr i64 %449, 1
  store i64 %460, ptr %cell_index.i127, align 8, !noalias !162
  %461 = and i64 %449, 1
  store i64 %461, ptr %data_index.i128, align 8, !noalias !162
  %462 = load ptr, ptr %41, align 8, !noalias !162
  %463 = load i64, ptr %462, align 8
  store i64 %463, ptr %size_of_type.i129, align 8, !noalias !162
  %464 = load i64, ptr %cell_index.i127, align 8, !noalias !162
  %465 = load i64, ptr %size_of_cell.i126, align 8, !noalias !162
  %466 = mul i64 %464, %465
  %467 = add i64 %445, %466
  %468 = load i64, ptr %data_index.i128, align 8, !noalias !162
  %469 = load i64, ptr %size_of_type.i129, align 8, !noalias !162
  %470 = mul i64 %468, %469
  %471 = add i64 %467, %470
  call void @llvm.lifetime.end.p0(i64 8, ptr %40)
  call void @llvm.lifetime.end.p0(i64 8, ptr %41)
  call void @llvm.lifetime.end.p0(i64 8, ptr %42)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i125)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i126)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i127)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i128)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i129)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i130)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i131)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i132)
  br label %"runtime::map_cell_index_dynamic.exit136"

switch.default.body.i135:                         ; preds = %"runtime::map_cell_index_dynamic.exit148"
  %472 = load i64, ptr %elements_per_cell.i125, align 8, !noalias !162
  %473 = udiv i64 %449, %472
  store i64 %473, ptr %cell_index2.i130, align 8, !noalias !162
  %474 = load i64, ptr %elements_per_cell.i125, align 8, !noalias !162
  %475 = urem i64 %449, %474
  store i64 %475, ptr %data_index3.i131, align 8, !noalias !162
  %476 = load ptr, ptr %41, align 8, !noalias !162
  %477 = load i64, ptr %476, align 8
  store i64 %477, ptr %size_of_type4.i132, align 8, !noalias !162
  %478 = load i64, ptr %cell_index2.i130, align 8, !noalias !162
  %479 = load i64, ptr %size_of_cell.i126, align 8, !noalias !162
  %480 = mul i64 %478, %479
  %481 = add i64 %445, %480
  %482 = load i64, ptr %data_index3.i131, align 8, !noalias !162
  %483 = load i64, ptr %size_of_type4.i132, align 8, !noalias !162
  %484 = mul i64 %482, %483
  %485 = add i64 %481, %484
  call void @llvm.lifetime.end.p0(i64 8, ptr %40)
  call void @llvm.lifetime.end.p0(i64 8, ptr %41)
  call void @llvm.lifetime.end.p0(i64 8, ptr %42)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i125)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i126)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i127)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i128)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i129)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i130)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i131)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i132)
  br label %"runtime::map_cell_index_dynamic.exit136"

"runtime::map_cell_index_dynamic.exit136":        ; preds = %switch.default.body.i135, %switch.case.body1.i133, %switch.case.body.i134
  %486 = phi i64 [ %459, %switch.case.body.i134 ], [ %471, %switch.case.body1.i133 ], [ %485, %switch.default.body.i135 ]
  store i64 %486, ptr %vp, align 8
  %487 = load i64, ptr %result, align 8
  %488 = icmp eq i64 %487, 0
  %489 = zext i1 %488 to i8
  %490 = icmp ne i8 %489, 0
  br i1 %490, label %if.then8, label %if.done9

if.then8:                                         ; preds = %"runtime::map_cell_index_dynamic.exit136"
  %491 = load i64, ptr %kp, align 8
  store i64 %491, ptr %key, align 8
  %492 = load i64, ptr %vp, align 8
  store i64 %492, ptr %result, align 8
  br label %if.done9

if.done9:                                         ; preds = %if.then8, %"runtime::map_cell_index_dynamic.exit136"
  %493 = load i64, ptr %tk, align 8
  %494 = inttoptr i64 %493 to ptr
  %495 = load i64, ptr %k, align 8
  %496 = inttoptr i64 %495 to ptr
  %497 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %494, ptr %496, i64 %497, i1 false)
  %498 = load i64, ptr %k, align 8
  %499 = inttoptr i64 %498 to ptr
  %500 = load i64, ptr %kp, align 8
  %501 = inttoptr i64 %500 to ptr
  %502 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %499, ptr %501, i64 %502, i1 false)
  %503 = load i64, ptr %kp, align 8
  %504 = inttoptr i64 %503 to ptr
  %505 = load i64, ptr %tk, align 8
  %506 = inttoptr i64 %505 to ptr
  %507 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %504, ptr %506, i64 %507, i1 false)
  %508 = load i64, ptr %tv, align 8
  %509 = inttoptr i64 %508 to ptr
  %510 = load i64, ptr %v, align 8
  %511 = inttoptr i64 %510 to ptr
  %512 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %509, ptr %511, i64 %512, i1 false)
  %513 = load i64, ptr %v, align 8
  %514 = inttoptr i64 %513 to ptr
  %515 = load i64, ptr %vp, align 8
  %516 = inttoptr i64 %515 to ptr
  %517 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %514, ptr %516, i64 %517, i1 false)
  %518 = load i64, ptr %vp, align 8
  %519 = inttoptr i64 %518 to ptr
  %520 = load i64, ptr %tv, align 8
  %521 = inttoptr i64 %520 to ptr
  %522 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %519, ptr %521, i64 %522, i1 false)
  %523 = load i64, ptr %h, align 8
  store i64 %523, ptr %th, align 8
  %524 = load ptr, ptr %hs, align 8
  %525 = load i64, ptr %pos, align 8
  %526 = getelementptr i64, ptr %524, i64 %525
  %527 = load i64, ptr %526, align 8
  store i64 %527, ptr %h, align 8
  %528 = load ptr, ptr %hs, align 8
  %529 = load i64, ptr %pos, align 8
  %530 = getelementptr i64, ptr %528, i64 %529
  %531 = load i64, ptr %th, align 8
  store i64 %531, ptr %530, align 8
  %532 = load i64, ptr %probe_distance, align 8
  store i64 %532, ptr %distance, align 8
  br label %if.done10

if.done10:                                        ; preds = %if.done9, %if.init
  %533 = load i64, ptr %pos, align 8
  %534 = add i64 %533, 1
  %535 = load i64, ptr %mask, align 8
  %536 = and i64 %534, %535
  store i64 %536, ptr %pos, align 8
  %537 = load i64, ptr %distance, align 8
  %538 = add i64 %537, 1
  store i64 %538, ptr %distance, align 8
  br label %for.body

for.done:                                         ; preds = %if.then5
  %539 = load ptr, ptr %hs, align 8
  %540 = load i64, ptr %pos, align 8
  %541 = getelementptr i64, ptr %539, i64 %540
  store i64 0, ptr %541, align 8
  store i64 1, ptr %look_ahead, align 8
  br label %for.body11

for.body11:                                       ; preds = %if.done39, %if.then13, %for.done
  %542 = load i64, ptr %pos, align 8
  %543 = load i64, ptr %look_ahead, align 8
  %544 = add i64 %542, %543
  %545 = load i64, ptr %mask, align 8
  %546 = and i64 %544, %545
  store i64 %546, ptr %la_pos, align 8
  %547 = load ptr, ptr %hs, align 8
  %548 = load i64, ptr %la_pos, align 8
  %549 = getelementptr i64, ptr %547, i64 %548
  %550 = load i64, ptr %549, align 8
  store i64 %550, ptr %element_hash12, align 8
  %551 = load i64, ptr %element_hash12, align 8
  %552 = call i8 @"runtime::map_hash_is_deleted"(i64 %551)
  %553 = icmp ne i8 %552, 0
  br i1 %553, label %if.then13, label %if.done15

if.then13:                                        ; preds = %for.body11
  %554 = load i64, ptr %look_ahead, align 8
  %555 = add i64 %554, 1
  store i64 %555, ptr %look_ahead, align 8
  %556 = load ptr, ptr %hs, align 8
  %557 = load i64, ptr %la_pos, align 8
  %558 = getelementptr i64, ptr %556, i64 %557
  store i64 0, ptr %558, align 8
  br label %for.body11

unreachable14:                                    ; No predecessors!
  br label %if.done15

if.done15:                                        ; preds = %unreachable14, %for.body11
  %559 = load i64, ptr %ks, align 8
  %560 = load ptr, ptr %68, align 8
  %561 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %560, i32 0, i32 0
  %562 = load ptr, ptr %561, align 8
  %563 = load i64, ptr %pos, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !165)
  call void @llvm.lifetime.start.p0(i64 8, ptr %43)
  call void @llvm.lifetime.start.p0(i64 8, ptr %44)
  call void @llvm.lifetime.start.p0(i64 8, ptr %45)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i113)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i114)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i115)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i116)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i117)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i118)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i119)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i120)
  store i64 %559, ptr %43, align 8, !noalias !165
  store ptr %562, ptr %44, align 8, !noalias !165
  store i64 %563, ptr %45, align 8, !noalias !165
  %564 = load ptr, ptr %44, align 8, !noalias !165
  %565 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %564, i32 0, i32 3
  %566 = load i64, ptr %565, align 8
  store i64 %566, ptr %elements_per_cell.i113, align 8, !noalias !165
  %567 = load ptr, ptr %44, align 8, !noalias !165
  %568 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %567, i32 0, i32 2
  %569 = load i64, ptr %568, align 8
  store i64 %569, ptr %size_of_cell.i114, align 8, !noalias !165
  %570 = load i64, ptr %elements_per_cell.i113, align 8, !noalias !165
  switch i64 %570, label %switch.default.body.i123 [
    i64 1, label %switch.case.body.i122
    i64 2, label %switch.case.body1.i121
  ]

switch.case.body.i122:                            ; preds = %if.done15
  %571 = load i64, ptr %size_of_cell.i114, align 8, !noalias !165
  %572 = mul i64 %563, %571
  %573 = add i64 %559, %572
  call void @llvm.lifetime.end.p0(i64 8, ptr %43)
  call void @llvm.lifetime.end.p0(i64 8, ptr %44)
  call void @llvm.lifetime.end.p0(i64 8, ptr %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i113)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i114)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i115)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i116)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i117)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i118)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i119)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i120)
  br label %"runtime::map_cell_index_dynamic.exit124"

switch.case.body1.i121:                           ; preds = %if.done15
  %574 = lshr i64 %563, 1
  store i64 %574, ptr %cell_index.i115, align 8, !noalias !165
  %575 = and i64 %563, 1
  store i64 %575, ptr %data_index.i116, align 8, !noalias !165
  %576 = load ptr, ptr %44, align 8, !noalias !165
  %577 = load i64, ptr %576, align 8
  store i64 %577, ptr %size_of_type.i117, align 8, !noalias !165
  %578 = load i64, ptr %cell_index.i115, align 8, !noalias !165
  %579 = load i64, ptr %size_of_cell.i114, align 8, !noalias !165
  %580 = mul i64 %578, %579
  %581 = add i64 %559, %580
  %582 = load i64, ptr %data_index.i116, align 8, !noalias !165
  %583 = load i64, ptr %size_of_type.i117, align 8, !noalias !165
  %584 = mul i64 %582, %583
  %585 = add i64 %581, %584
  call void @llvm.lifetime.end.p0(i64 8, ptr %43)
  call void @llvm.lifetime.end.p0(i64 8, ptr %44)
  call void @llvm.lifetime.end.p0(i64 8, ptr %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i113)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i114)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i115)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i116)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i117)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i118)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i119)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i120)
  br label %"runtime::map_cell_index_dynamic.exit124"

switch.default.body.i123:                         ; preds = %if.done15
  %586 = load i64, ptr %elements_per_cell.i113, align 8, !noalias !165
  %587 = udiv i64 %563, %586
  store i64 %587, ptr %cell_index2.i118, align 8, !noalias !165
  %588 = load i64, ptr %elements_per_cell.i113, align 8, !noalias !165
  %589 = urem i64 %563, %588
  store i64 %589, ptr %data_index3.i119, align 8, !noalias !165
  %590 = load ptr, ptr %44, align 8, !noalias !165
  %591 = load i64, ptr %590, align 8
  store i64 %591, ptr %size_of_type4.i120, align 8, !noalias !165
  %592 = load i64, ptr %cell_index2.i118, align 8, !noalias !165
  %593 = load i64, ptr %size_of_cell.i114, align 8, !noalias !165
  %594 = mul i64 %592, %593
  %595 = add i64 %559, %594
  %596 = load i64, ptr %data_index3.i119, align 8, !noalias !165
  %597 = load i64, ptr %size_of_type4.i120, align 8, !noalias !165
  %598 = mul i64 %596, %597
  %599 = add i64 %595, %598
  call void @llvm.lifetime.end.p0(i64 8, ptr %43)
  call void @llvm.lifetime.end.p0(i64 8, ptr %44)
  call void @llvm.lifetime.end.p0(i64 8, ptr %45)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i113)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i114)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i115)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i116)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i117)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i118)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i119)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i120)
  br label %"runtime::map_cell_index_dynamic.exit124"

"runtime::map_cell_index_dynamic.exit124":        ; preds = %switch.default.body.i123, %switch.case.body1.i121, %switch.case.body.i122
  %600 = phi i64 [ %573, %switch.case.body.i122 ], [ %585, %switch.case.body1.i121 ], [ %599, %switch.default.body.i123 ]
  store i64 %600, ptr %k_dst16, align 8
  %601 = load i64, ptr %vs, align 8
  %602 = load ptr, ptr %68, align 8
  %603 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %602, i32 0, i32 1
  %604 = load ptr, ptr %603, align 8
  %605 = load i64, ptr %pos, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !168)
  call void @llvm.lifetime.start.p0(i64 8, ptr %46)
  call void @llvm.lifetime.start.p0(i64 8, ptr %47)
  call void @llvm.lifetime.start.p0(i64 8, ptr %48)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i101)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i102)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i103)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i104)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i105)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i106)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i107)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i108)
  store i64 %601, ptr %46, align 8, !noalias !168
  store ptr %604, ptr %47, align 8, !noalias !168
  store i64 %605, ptr %48, align 8, !noalias !168
  %606 = load ptr, ptr %47, align 8, !noalias !168
  %607 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %606, i32 0, i32 3
  %608 = load i64, ptr %607, align 8
  store i64 %608, ptr %elements_per_cell.i101, align 8, !noalias !168
  %609 = load ptr, ptr %47, align 8, !noalias !168
  %610 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %609, i32 0, i32 2
  %611 = load i64, ptr %610, align 8
  store i64 %611, ptr %size_of_cell.i102, align 8, !noalias !168
  %612 = load i64, ptr %elements_per_cell.i101, align 8, !noalias !168
  switch i64 %612, label %switch.default.body.i111 [
    i64 1, label %switch.case.body.i110
    i64 2, label %switch.case.body1.i109
  ]

switch.case.body.i110:                            ; preds = %"runtime::map_cell_index_dynamic.exit124"
  %613 = load i64, ptr %size_of_cell.i102, align 8, !noalias !168
  %614 = mul i64 %605, %613
  %615 = add i64 %601, %614
  call void @llvm.lifetime.end.p0(i64 8, ptr %46)
  call void @llvm.lifetime.end.p0(i64 8, ptr %47)
  call void @llvm.lifetime.end.p0(i64 8, ptr %48)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i101)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i102)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i103)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i104)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i105)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i106)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i107)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i108)
  br label %"runtime::map_cell_index_dynamic.exit112"

switch.case.body1.i109:                           ; preds = %"runtime::map_cell_index_dynamic.exit124"
  %616 = lshr i64 %605, 1
  store i64 %616, ptr %cell_index.i103, align 8, !noalias !168
  %617 = and i64 %605, 1
  store i64 %617, ptr %data_index.i104, align 8, !noalias !168
  %618 = load ptr, ptr %47, align 8, !noalias !168
  %619 = load i64, ptr %618, align 8
  store i64 %619, ptr %size_of_type.i105, align 8, !noalias !168
  %620 = load i64, ptr %cell_index.i103, align 8, !noalias !168
  %621 = load i64, ptr %size_of_cell.i102, align 8, !noalias !168
  %622 = mul i64 %620, %621
  %623 = add i64 %601, %622
  %624 = load i64, ptr %data_index.i104, align 8, !noalias !168
  %625 = load i64, ptr %size_of_type.i105, align 8, !noalias !168
  %626 = mul i64 %624, %625
  %627 = add i64 %623, %626
  call void @llvm.lifetime.end.p0(i64 8, ptr %46)
  call void @llvm.lifetime.end.p0(i64 8, ptr %47)
  call void @llvm.lifetime.end.p0(i64 8, ptr %48)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i101)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i102)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i103)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i104)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i105)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i106)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i107)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i108)
  br label %"runtime::map_cell_index_dynamic.exit112"

switch.default.body.i111:                         ; preds = %"runtime::map_cell_index_dynamic.exit124"
  %628 = load i64, ptr %elements_per_cell.i101, align 8, !noalias !168
  %629 = udiv i64 %605, %628
  store i64 %629, ptr %cell_index2.i106, align 8, !noalias !168
  %630 = load i64, ptr %elements_per_cell.i101, align 8, !noalias !168
  %631 = urem i64 %605, %630
  store i64 %631, ptr %data_index3.i107, align 8, !noalias !168
  %632 = load ptr, ptr %47, align 8, !noalias !168
  %633 = load i64, ptr %632, align 8
  store i64 %633, ptr %size_of_type4.i108, align 8, !noalias !168
  %634 = load i64, ptr %cell_index2.i106, align 8, !noalias !168
  %635 = load i64, ptr %size_of_cell.i102, align 8, !noalias !168
  %636 = mul i64 %634, %635
  %637 = add i64 %601, %636
  %638 = load i64, ptr %data_index3.i107, align 8, !noalias !168
  %639 = load i64, ptr %size_of_type4.i108, align 8, !noalias !168
  %640 = mul i64 %638, %639
  %641 = add i64 %637, %640
  call void @llvm.lifetime.end.p0(i64 8, ptr %46)
  call void @llvm.lifetime.end.p0(i64 8, ptr %47)
  call void @llvm.lifetime.end.p0(i64 8, ptr %48)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i101)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i102)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i103)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i104)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i105)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i106)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i107)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i108)
  br label %"runtime::map_cell_index_dynamic.exit112"

"runtime::map_cell_index_dynamic.exit112":        ; preds = %switch.default.body.i111, %switch.case.body1.i109, %switch.case.body.i110
  %642 = phi i64 [ %615, %switch.case.body.i110 ], [ %627, %switch.case.body1.i109 ], [ %641, %switch.default.body.i111 ]
  store i64 %642, ptr %v_dst17, align 8
  %643 = load i64, ptr %element_hash12, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %17)
  store i64 %643, ptr %17, align 8
  %644 = icmp eq i64 %643, 0
  %645 = zext i1 %644 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  %646 = icmp ne i8 %645, 0
  br i1 %646, label %if.then18, label %if.done21

if.then18:                                        ; preds = %"runtime::map_cell_index_dynamic.exit112"
  %647 = load i64, ptr %k_dst16, align 8
  %648 = inttoptr i64 %647 to ptr
  %649 = load i64, ptr %k, align 8
  %650 = inttoptr i64 %649 to ptr
  %651 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %648, ptr %650, i64 %651, i1 false)
  %652 = load i64, ptr %v_dst17, align 8
  %653 = inttoptr i64 %652 to ptr
  %654 = load i64, ptr %v, align 8
  %655 = inttoptr i64 %654 to ptr
  %656 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %653, ptr %655, i64 %656, i1 false)
  %657 = load ptr, ptr %hs, align 8
  %658 = load i64, ptr %pos, align 8
  %659 = getelementptr i64, ptr %657, i64 %658
  %660 = load i64, ptr %h, align 8
  store i64 %660, ptr %659, align 8
  %661 = load i64, ptr %result, align 8
  %662 = icmp eq i64 %661, 0
  %663 = zext i1 %662 to i8
  %664 = icmp ne i8 %663, 0
  br i1 %664, label %if.then19, label %if.done20

if.then19:                                        ; preds = %if.then18
  %665 = load i64, ptr %k_dst16, align 8
  store i64 %665, ptr %key, align 8
  %666 = load i64, ptr %v_dst17, align 8
  store i64 %666, ptr %result, align 8
  br label %if.done20

if.done20:                                        ; preds = %if.then19, %if.then18
  %667 = load i64, ptr %key, align 8
  %668 = load i64, ptr %result, align 8
  store i64 %667, ptr %key, align 8
  store i64 %668, ptr %result, align 8
  store i64 %667, ptr %5, align 8
  ret i64 %668

if.done21:                                        ; preds = %"runtime::map_cell_index_dynamic.exit112"
  %669 = load i64, ptr %ks, align 8
  %670 = load ptr, ptr %68, align 8
  %671 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %670, i32 0, i32 0
  %672 = load ptr, ptr %671, align 8
  %673 = load i64, ptr %la_pos, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !171)
  call void @llvm.lifetime.start.p0(i64 8, ptr %49)
  call void @llvm.lifetime.start.p0(i64 8, ptr %50)
  call void @llvm.lifetime.start.p0(i64 8, ptr %51)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i89)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i90)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i91)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i92)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i93)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i94)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i95)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i96)
  store i64 %669, ptr %49, align 8, !noalias !171
  store ptr %672, ptr %50, align 8, !noalias !171
  store i64 %673, ptr %51, align 8, !noalias !171
  %674 = load ptr, ptr %50, align 8, !noalias !171
  %675 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %674, i32 0, i32 3
  %676 = load i64, ptr %675, align 8
  store i64 %676, ptr %elements_per_cell.i89, align 8, !noalias !171
  %677 = load ptr, ptr %50, align 8, !noalias !171
  %678 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %677, i32 0, i32 2
  %679 = load i64, ptr %678, align 8
  store i64 %679, ptr %size_of_cell.i90, align 8, !noalias !171
  %680 = load i64, ptr %elements_per_cell.i89, align 8, !noalias !171
  switch i64 %680, label %switch.default.body.i99 [
    i64 1, label %switch.case.body.i98
    i64 2, label %switch.case.body1.i97
  ]

switch.case.body.i98:                             ; preds = %if.done21
  %681 = load i64, ptr %size_of_cell.i90, align 8, !noalias !171
  %682 = mul i64 %673, %681
  %683 = add i64 %669, %682
  call void @llvm.lifetime.end.p0(i64 8, ptr %49)
  call void @llvm.lifetime.end.p0(i64 8, ptr %50)
  call void @llvm.lifetime.end.p0(i64 8, ptr %51)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i89)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i90)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i91)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i92)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i93)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i94)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i95)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i96)
  br label %"runtime::map_cell_index_dynamic.exit100"

switch.case.body1.i97:                            ; preds = %if.done21
  %684 = lshr i64 %673, 1
  store i64 %684, ptr %cell_index.i91, align 8, !noalias !171
  %685 = and i64 %673, 1
  store i64 %685, ptr %data_index.i92, align 8, !noalias !171
  %686 = load ptr, ptr %50, align 8, !noalias !171
  %687 = load i64, ptr %686, align 8
  store i64 %687, ptr %size_of_type.i93, align 8, !noalias !171
  %688 = load i64, ptr %cell_index.i91, align 8, !noalias !171
  %689 = load i64, ptr %size_of_cell.i90, align 8, !noalias !171
  %690 = mul i64 %688, %689
  %691 = add i64 %669, %690
  %692 = load i64, ptr %data_index.i92, align 8, !noalias !171
  %693 = load i64, ptr %size_of_type.i93, align 8, !noalias !171
  %694 = mul i64 %692, %693
  %695 = add i64 %691, %694
  call void @llvm.lifetime.end.p0(i64 8, ptr %49)
  call void @llvm.lifetime.end.p0(i64 8, ptr %50)
  call void @llvm.lifetime.end.p0(i64 8, ptr %51)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i89)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i90)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i91)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i92)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i93)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i94)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i95)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i96)
  br label %"runtime::map_cell_index_dynamic.exit100"

switch.default.body.i99:                          ; preds = %if.done21
  %696 = load i64, ptr %elements_per_cell.i89, align 8, !noalias !171
  %697 = udiv i64 %673, %696
  store i64 %697, ptr %cell_index2.i94, align 8, !noalias !171
  %698 = load i64, ptr %elements_per_cell.i89, align 8, !noalias !171
  %699 = urem i64 %673, %698
  store i64 %699, ptr %data_index3.i95, align 8, !noalias !171
  %700 = load ptr, ptr %50, align 8, !noalias !171
  %701 = load i64, ptr %700, align 8
  store i64 %701, ptr %size_of_type4.i96, align 8, !noalias !171
  %702 = load i64, ptr %cell_index2.i94, align 8, !noalias !171
  %703 = load i64, ptr %size_of_cell.i90, align 8, !noalias !171
  %704 = mul i64 %702, %703
  %705 = add i64 %669, %704
  %706 = load i64, ptr %data_index3.i95, align 8, !noalias !171
  %707 = load i64, ptr %size_of_type4.i96, align 8, !noalias !171
  %708 = mul i64 %706, %707
  %709 = add i64 %705, %708
  call void @llvm.lifetime.end.p0(i64 8, ptr %49)
  call void @llvm.lifetime.end.p0(i64 8, ptr %50)
  call void @llvm.lifetime.end.p0(i64 8, ptr %51)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i89)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i90)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i91)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i92)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i93)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i94)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i95)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i96)
  br label %"runtime::map_cell_index_dynamic.exit100"

"runtime::map_cell_index_dynamic.exit100":        ; preds = %switch.default.body.i99, %switch.case.body1.i97, %switch.case.body.i98
  %710 = phi i64 [ %683, %switch.case.body.i98 ], [ %695, %switch.case.body1.i97 ], [ %709, %switch.default.body.i99 ]
  store i64 %710, ptr %k_src, align 8
  %711 = load i64, ptr %vs, align 8
  %712 = load ptr, ptr %68, align 8
  %713 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %712, i32 0, i32 1
  %714 = load ptr, ptr %713, align 8
  %715 = load i64, ptr %la_pos, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !174)
  call void @llvm.lifetime.start.p0(i64 8, ptr %52)
  call void @llvm.lifetime.start.p0(i64 8, ptr %53)
  call void @llvm.lifetime.start.p0(i64 8, ptr %54)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i77)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i78)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i79)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i80)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i81)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i82)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i83)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i84)
  store i64 %711, ptr %52, align 8, !noalias !174
  store ptr %714, ptr %53, align 8, !noalias !174
  store i64 %715, ptr %54, align 8, !noalias !174
  %716 = load ptr, ptr %53, align 8, !noalias !174
  %717 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %716, i32 0, i32 3
  %718 = load i64, ptr %717, align 8
  store i64 %718, ptr %elements_per_cell.i77, align 8, !noalias !174
  %719 = load ptr, ptr %53, align 8, !noalias !174
  %720 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %719, i32 0, i32 2
  %721 = load i64, ptr %720, align 8
  store i64 %721, ptr %size_of_cell.i78, align 8, !noalias !174
  %722 = load i64, ptr %elements_per_cell.i77, align 8, !noalias !174
  switch i64 %722, label %switch.default.body.i87 [
    i64 1, label %switch.case.body.i86
    i64 2, label %switch.case.body1.i85
  ]

switch.case.body.i86:                             ; preds = %"runtime::map_cell_index_dynamic.exit100"
  %723 = load i64, ptr %size_of_cell.i78, align 8, !noalias !174
  %724 = mul i64 %715, %723
  %725 = add i64 %711, %724
  call void @llvm.lifetime.end.p0(i64 8, ptr %52)
  call void @llvm.lifetime.end.p0(i64 8, ptr %53)
  call void @llvm.lifetime.end.p0(i64 8, ptr %54)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i77)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i78)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i79)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i80)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i81)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i82)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i83)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i84)
  br label %"runtime::map_cell_index_dynamic.exit88"

switch.case.body1.i85:                            ; preds = %"runtime::map_cell_index_dynamic.exit100"
  %726 = lshr i64 %715, 1
  store i64 %726, ptr %cell_index.i79, align 8, !noalias !174
  %727 = and i64 %715, 1
  store i64 %727, ptr %data_index.i80, align 8, !noalias !174
  %728 = load ptr, ptr %53, align 8, !noalias !174
  %729 = load i64, ptr %728, align 8
  store i64 %729, ptr %size_of_type.i81, align 8, !noalias !174
  %730 = load i64, ptr %cell_index.i79, align 8, !noalias !174
  %731 = load i64, ptr %size_of_cell.i78, align 8, !noalias !174
  %732 = mul i64 %730, %731
  %733 = add i64 %711, %732
  %734 = load i64, ptr %data_index.i80, align 8, !noalias !174
  %735 = load i64, ptr %size_of_type.i81, align 8, !noalias !174
  %736 = mul i64 %734, %735
  %737 = add i64 %733, %736
  call void @llvm.lifetime.end.p0(i64 8, ptr %52)
  call void @llvm.lifetime.end.p0(i64 8, ptr %53)
  call void @llvm.lifetime.end.p0(i64 8, ptr %54)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i77)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i78)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i79)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i80)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i81)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i82)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i83)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i84)
  br label %"runtime::map_cell_index_dynamic.exit88"

switch.default.body.i87:                          ; preds = %"runtime::map_cell_index_dynamic.exit100"
  %738 = load i64, ptr %elements_per_cell.i77, align 8, !noalias !174
  %739 = udiv i64 %715, %738
  store i64 %739, ptr %cell_index2.i82, align 8, !noalias !174
  %740 = load i64, ptr %elements_per_cell.i77, align 8, !noalias !174
  %741 = urem i64 %715, %740
  store i64 %741, ptr %data_index3.i83, align 8, !noalias !174
  %742 = load ptr, ptr %53, align 8, !noalias !174
  %743 = load i64, ptr %742, align 8
  store i64 %743, ptr %size_of_type4.i84, align 8, !noalias !174
  %744 = load i64, ptr %cell_index2.i82, align 8, !noalias !174
  %745 = load i64, ptr %size_of_cell.i78, align 8, !noalias !174
  %746 = mul i64 %744, %745
  %747 = add i64 %711, %746
  %748 = load i64, ptr %data_index3.i83, align 8, !noalias !174
  %749 = load i64, ptr %size_of_type4.i84, align 8, !noalias !174
  %750 = mul i64 %748, %749
  %751 = add i64 %747, %750
  call void @llvm.lifetime.end.p0(i64 8, ptr %52)
  call void @llvm.lifetime.end.p0(i64 8, ptr %53)
  call void @llvm.lifetime.end.p0(i64 8, ptr %54)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i77)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i78)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i79)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i80)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i81)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i82)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i83)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i84)
  br label %"runtime::map_cell_index_dynamic.exit88"

"runtime::map_cell_index_dynamic.exit88":         ; preds = %switch.default.body.i87, %switch.case.body1.i85, %switch.case.body.i86
  %752 = phi i64 [ %725, %switch.case.body.i86 ], [ %737, %switch.case.body1.i85 ], [ %751, %switch.default.body.i87 ]
  store i64 %752, ptr %v_src, align 8
  %753 = load i64, ptr %element_hash12, align 8
  %754 = load i64, ptr %la_pos, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %capacity.i223)
  store i64 %753, ptr %10, align 8
  store i64 %754, ptr %11, align 8
  %755 = load i64, ptr %0, align 8
  %756 = and i64 %755, 63
  %757 = shl i64 1, %756
  store i64 %757, ptr %capacity.i223, align 8
  %758 = load i64, ptr %capacity.i223, align 8
  %759 = add i64 %754, %758
  call void @llvm.lifetime.start.p0(i64 8, ptr %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr %capacity.i.i222)
  store i64 %753, ptr %9, align 8
  %760 = load i64, ptr %0, align 8
  %761 = and i64 %760, 63
  %762 = shl i64 1, %761
  store i64 %762, ptr %capacity.i.i222, align 8
  %763 = load i64, ptr %capacity.i.i222, align 8
  %764 = sub i64 %763, 1
  %765 = and i64 %753, %764
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %capacity.i.i222)
  %766 = sub i64 %759, %765
  %767 = load i64, ptr %capacity.i223, align 8
  %768 = sub i64 %767, 1
  %769 = and i64 %766, %768
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %capacity.i223)
  store i64 %769, ptr %probe_distance22, align 8
  %770 = load i64, ptr %probe_distance22, align 8
  %771 = load i64, ptr %look_ahead, align 8
  %772 = icmp ult i64 %770, %771
  %773 = zext i1 %772 to i8
  %774 = icmp ne i8 %773, 0
  br i1 %774, label %if.then23, label %if.else

if.then23:                                        ; preds = %"runtime::map_cell_index_dynamic.exit88"
  %775 = load i64, ptr %result, align 8
  %776 = icmp eq i64 %775, 0
  %777 = zext i1 %776 to i8
  %778 = icmp ne i8 %777, 0
  br i1 %778, label %if.then24, label %if.done25

if.then24:                                        ; preds = %if.then23
  %779 = load i64, ptr %k_dst16, align 8
  store i64 %779, ptr %key, align 8
  %780 = load i64, ptr %v_dst17, align 8
  store i64 %780, ptr %result, align 8
  br label %if.done25

if.done25:                                        ; preds = %if.then24, %if.then23
  %781 = load i64, ptr %k_dst16, align 8
  %782 = inttoptr i64 %781 to ptr
  %783 = load i64, ptr %k, align 8
  %784 = inttoptr i64 %783 to ptr
  %785 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %782, ptr %784, i64 %785, i1 false)
  %786 = load i64, ptr %v_dst17, align 8
  %787 = inttoptr i64 %786 to ptr
  %788 = load i64, ptr %v, align 8
  %789 = inttoptr i64 %788 to ptr
  %790 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %787, ptr %789, i64 %790, i1 false)
  %791 = load ptr, ptr %hs, align 8
  %792 = load i64, ptr %pos, align 8
  %793 = getelementptr i64, ptr %791, i64 %792
  %794 = load i64, ptr %h, align 8
  store i64 %794, ptr %793, align 8
  %795 = load i64, ptr %la_pos, align 8
  %796 = load i64, ptr %probe_distance22, align 8
  %797 = sub i64 %795, %796
  %798 = load i64, ptr %mask, align 8
  %799 = and i64 %797, %798
  store i64 %799, ptr %pos, align 8
  %800 = load i64, ptr %probe_distance22, align 8
  %801 = load i64, ptr %look_ahead, align 8
  %802 = sub i64 %801, %800
  store i64 %802, ptr %look_ahead, align 8
  br label %for.loop

for.loop:                                         ; preds = %"runtime::map_cell_index_dynamic.exit", %if.done25
  %803 = load i64, ptr %probe_distance22, align 8
  %804 = icmp ne i64 %803, 0
  %805 = zext i1 %804 to i8
  %806 = icmp ne i8 %805, 0
  br i1 %806, label %for.body26, label %for.done33

for.body26:                                       ; preds = %for.loop
  %807 = load i64, ptr %ks, align 8
  %808 = load ptr, ptr %68, align 8
  %809 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %808, i32 0, i32 0
  %810 = load ptr, ptr %809, align 8
  %811 = load i64, ptr %pos, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !177)
  call void @llvm.lifetime.start.p0(i64 8, ptr %55)
  call void @llvm.lifetime.start.p0(i64 8, ptr %56)
  call void @llvm.lifetime.start.p0(i64 8, ptr %57)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i65)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i66)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i67)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i68)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i69)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i70)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i71)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i72)
  store i64 %807, ptr %55, align 8, !noalias !177
  store ptr %810, ptr %56, align 8, !noalias !177
  store i64 %811, ptr %57, align 8, !noalias !177
  %812 = load ptr, ptr %56, align 8, !noalias !177
  %813 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %812, i32 0, i32 3
  %814 = load i64, ptr %813, align 8
  store i64 %814, ptr %elements_per_cell.i65, align 8, !noalias !177
  %815 = load ptr, ptr %56, align 8, !noalias !177
  %816 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %815, i32 0, i32 2
  %817 = load i64, ptr %816, align 8
  store i64 %817, ptr %size_of_cell.i66, align 8, !noalias !177
  %818 = load i64, ptr %elements_per_cell.i65, align 8, !noalias !177
  switch i64 %818, label %switch.default.body.i75 [
    i64 1, label %switch.case.body.i74
    i64 2, label %switch.case.body1.i73
  ]

switch.case.body.i74:                             ; preds = %for.body26
  %819 = load i64, ptr %size_of_cell.i66, align 8, !noalias !177
  %820 = mul i64 %811, %819
  %821 = add i64 %807, %820
  call void @llvm.lifetime.end.p0(i64 8, ptr %55)
  call void @llvm.lifetime.end.p0(i64 8, ptr %56)
  call void @llvm.lifetime.end.p0(i64 8, ptr %57)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i65)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i66)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i67)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i68)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i69)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i70)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i71)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i72)
  br label %"runtime::map_cell_index_dynamic.exit76"

switch.case.body1.i73:                            ; preds = %for.body26
  %822 = lshr i64 %811, 1
  store i64 %822, ptr %cell_index.i67, align 8, !noalias !177
  %823 = and i64 %811, 1
  store i64 %823, ptr %data_index.i68, align 8, !noalias !177
  %824 = load ptr, ptr %56, align 8, !noalias !177
  %825 = load i64, ptr %824, align 8
  store i64 %825, ptr %size_of_type.i69, align 8, !noalias !177
  %826 = load i64, ptr %cell_index.i67, align 8, !noalias !177
  %827 = load i64, ptr %size_of_cell.i66, align 8, !noalias !177
  %828 = mul i64 %826, %827
  %829 = add i64 %807, %828
  %830 = load i64, ptr %data_index.i68, align 8, !noalias !177
  %831 = load i64, ptr %size_of_type.i69, align 8, !noalias !177
  %832 = mul i64 %830, %831
  %833 = add i64 %829, %832
  call void @llvm.lifetime.end.p0(i64 8, ptr %55)
  call void @llvm.lifetime.end.p0(i64 8, ptr %56)
  call void @llvm.lifetime.end.p0(i64 8, ptr %57)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i65)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i66)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i67)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i68)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i69)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i70)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i71)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i72)
  br label %"runtime::map_cell_index_dynamic.exit76"

switch.default.body.i75:                          ; preds = %for.body26
  %834 = load i64, ptr %elements_per_cell.i65, align 8, !noalias !177
  %835 = udiv i64 %811, %834
  store i64 %835, ptr %cell_index2.i70, align 8, !noalias !177
  %836 = load i64, ptr %elements_per_cell.i65, align 8, !noalias !177
  %837 = urem i64 %811, %836
  store i64 %837, ptr %data_index3.i71, align 8, !noalias !177
  %838 = load ptr, ptr %56, align 8, !noalias !177
  %839 = load i64, ptr %838, align 8
  store i64 %839, ptr %size_of_type4.i72, align 8, !noalias !177
  %840 = load i64, ptr %cell_index2.i70, align 8, !noalias !177
  %841 = load i64, ptr %size_of_cell.i66, align 8, !noalias !177
  %842 = mul i64 %840, %841
  %843 = add i64 %807, %842
  %844 = load i64, ptr %data_index3.i71, align 8, !noalias !177
  %845 = load i64, ptr %size_of_type4.i72, align 8, !noalias !177
  %846 = mul i64 %844, %845
  %847 = add i64 %843, %846
  call void @llvm.lifetime.end.p0(i64 8, ptr %55)
  call void @llvm.lifetime.end.p0(i64 8, ptr %56)
  call void @llvm.lifetime.end.p0(i64 8, ptr %57)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i65)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i66)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i67)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i68)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i69)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i70)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i71)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i72)
  br label %"runtime::map_cell_index_dynamic.exit76"

"runtime::map_cell_index_dynamic.exit76":         ; preds = %switch.default.body.i75, %switch.case.body1.i73, %switch.case.body.i74
  %848 = phi i64 [ %821, %switch.case.body.i74 ], [ %833, %switch.case.body1.i73 ], [ %847, %switch.default.body.i75 ]
  store i64 %848, ptr %k_dst16, align 8
  %849 = load i64, ptr %vs, align 8
  %850 = load ptr, ptr %68, align 8
  %851 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %850, i32 0, i32 1
  %852 = load ptr, ptr %851, align 8
  %853 = load i64, ptr %pos, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !180)
  call void @llvm.lifetime.start.p0(i64 8, ptr %58)
  call void @llvm.lifetime.start.p0(i64 8, ptr %59)
  call void @llvm.lifetime.start.p0(i64 8, ptr %60)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i53)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i54)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i55)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i56)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i57)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i58)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i59)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i60)
  store i64 %849, ptr %58, align 8, !noalias !180
  store ptr %852, ptr %59, align 8, !noalias !180
  store i64 %853, ptr %60, align 8, !noalias !180
  %854 = load ptr, ptr %59, align 8, !noalias !180
  %855 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %854, i32 0, i32 3
  %856 = load i64, ptr %855, align 8
  store i64 %856, ptr %elements_per_cell.i53, align 8, !noalias !180
  %857 = load ptr, ptr %59, align 8, !noalias !180
  %858 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %857, i32 0, i32 2
  %859 = load i64, ptr %858, align 8
  store i64 %859, ptr %size_of_cell.i54, align 8, !noalias !180
  %860 = load i64, ptr %elements_per_cell.i53, align 8, !noalias !180
  switch i64 %860, label %switch.default.body.i63 [
    i64 1, label %switch.case.body.i62
    i64 2, label %switch.case.body1.i61
  ]

switch.case.body.i62:                             ; preds = %"runtime::map_cell_index_dynamic.exit76"
  %861 = load i64, ptr %size_of_cell.i54, align 8, !noalias !180
  %862 = mul i64 %853, %861
  %863 = add i64 %849, %862
  call void @llvm.lifetime.end.p0(i64 8, ptr %58)
  call void @llvm.lifetime.end.p0(i64 8, ptr %59)
  call void @llvm.lifetime.end.p0(i64 8, ptr %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i53)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i54)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i55)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i56)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i57)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i58)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i59)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i60)
  br label %"runtime::map_cell_index_dynamic.exit64"

switch.case.body1.i61:                            ; preds = %"runtime::map_cell_index_dynamic.exit76"
  %864 = lshr i64 %853, 1
  store i64 %864, ptr %cell_index.i55, align 8, !noalias !180
  %865 = and i64 %853, 1
  store i64 %865, ptr %data_index.i56, align 8, !noalias !180
  %866 = load ptr, ptr %59, align 8, !noalias !180
  %867 = load i64, ptr %866, align 8
  store i64 %867, ptr %size_of_type.i57, align 8, !noalias !180
  %868 = load i64, ptr %cell_index.i55, align 8, !noalias !180
  %869 = load i64, ptr %size_of_cell.i54, align 8, !noalias !180
  %870 = mul i64 %868, %869
  %871 = add i64 %849, %870
  %872 = load i64, ptr %data_index.i56, align 8, !noalias !180
  %873 = load i64, ptr %size_of_type.i57, align 8, !noalias !180
  %874 = mul i64 %872, %873
  %875 = add i64 %871, %874
  call void @llvm.lifetime.end.p0(i64 8, ptr %58)
  call void @llvm.lifetime.end.p0(i64 8, ptr %59)
  call void @llvm.lifetime.end.p0(i64 8, ptr %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i53)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i54)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i55)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i56)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i57)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i58)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i59)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i60)
  br label %"runtime::map_cell_index_dynamic.exit64"

switch.default.body.i63:                          ; preds = %"runtime::map_cell_index_dynamic.exit76"
  %876 = load i64, ptr %elements_per_cell.i53, align 8, !noalias !180
  %877 = udiv i64 %853, %876
  store i64 %877, ptr %cell_index2.i58, align 8, !noalias !180
  %878 = load i64, ptr %elements_per_cell.i53, align 8, !noalias !180
  %879 = urem i64 %853, %878
  store i64 %879, ptr %data_index3.i59, align 8, !noalias !180
  %880 = load ptr, ptr %59, align 8, !noalias !180
  %881 = load i64, ptr %880, align 8
  store i64 %881, ptr %size_of_type4.i60, align 8, !noalias !180
  %882 = load i64, ptr %cell_index2.i58, align 8, !noalias !180
  %883 = load i64, ptr %size_of_cell.i54, align 8, !noalias !180
  %884 = mul i64 %882, %883
  %885 = add i64 %849, %884
  %886 = load i64, ptr %data_index3.i59, align 8, !noalias !180
  %887 = load i64, ptr %size_of_type4.i60, align 8, !noalias !180
  %888 = mul i64 %886, %887
  %889 = add i64 %885, %888
  call void @llvm.lifetime.end.p0(i64 8, ptr %58)
  call void @llvm.lifetime.end.p0(i64 8, ptr %59)
  call void @llvm.lifetime.end.p0(i64 8, ptr %60)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i53)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i54)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i55)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i56)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i57)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i58)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i59)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i60)
  br label %"runtime::map_cell_index_dynamic.exit64"

"runtime::map_cell_index_dynamic.exit64":         ; preds = %switch.default.body.i63, %switch.case.body1.i61, %switch.case.body.i62
  %890 = phi i64 [ %863, %switch.case.body.i62 ], [ %875, %switch.case.body1.i61 ], [ %889, %switch.default.body.i63 ]
  store i64 %890, ptr %v_dst17, align 8
  %891 = load i64, ptr %k_dst16, align 8
  %892 = inttoptr i64 %891 to ptr
  %893 = load i64, ptr %k_src, align 8
  %894 = inttoptr i64 %893 to ptr
  %895 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %892, ptr %894, i64 %895, i1 false)
  %896 = load i64, ptr %v_dst17, align 8
  %897 = inttoptr i64 %896 to ptr
  %898 = load i64, ptr %v_src, align 8
  %899 = inttoptr i64 %898 to ptr
  %900 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %897, ptr %899, i64 %900, i1 false)
  %901 = load ptr, ptr %hs, align 8
  %902 = load i64, ptr %pos, align 8
  %903 = getelementptr i64, ptr %901, i64 %902
  %904 = load i64, ptr %element_hash12, align 8
  store i64 %904, ptr %903, align 8
  %905 = load ptr, ptr %hs, align 8
  %906 = load i64, ptr %la_pos, align 8
  %907 = getelementptr i64, ptr %905, i64 %906
  store i64 0, ptr %907, align 8
  %908 = load i64, ptr %pos, align 8
  %909 = add i64 %908, 1
  %910 = load i64, ptr %mask, align 8
  %911 = and i64 %909, %910
  store i64 %911, ptr %pos, align 8
  %912 = load i64, ptr %la_pos, align 8
  %913 = add i64 %912, 1
  %914 = load i64, ptr %mask, align 8
  %915 = and i64 %913, %914
  store i64 %915, ptr %la_pos, align 8
  %916 = load i64, ptr %la_pos, align 8
  %917 = load i64, ptr %pos, align 8
  %918 = sub i64 %916, %917
  %919 = load i64, ptr %mask, align 8
  %920 = and i64 %918, %919
  store i64 %920, ptr %look_ahead, align 8
  %921 = load ptr, ptr %hs, align 8
  %922 = load i64, ptr %la_pos, align 8
  %923 = getelementptr i64, ptr %921, i64 %922
  %924 = load i64, ptr %923, align 8
  store i64 %924, ptr %element_hash12, align 8
  %925 = load i64, ptr %element_hash12, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %18)
  store i64 %925, ptr %18, align 8
  %926 = icmp eq i64 %925, 0
  %927 = zext i1 %926 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  %928 = icmp ne i8 %927, 0
  br i1 %928, label %if.then27, label %if.done28

if.then27:                                        ; preds = %"runtime::map_cell_index_dynamic.exit64"
  %929 = load i64, ptr %key, align 8
  %930 = load i64, ptr %result, align 8
  store i64 %929, ptr %key, align 8
  store i64 %930, ptr %result, align 8
  store i64 %929, ptr %5, align 8
  ret i64 %930

if.done28:                                        ; preds = %"runtime::map_cell_index_dynamic.exit64"
  %931 = load i64, ptr %element_hash12, align 8
  %932 = load i64, ptr %la_pos, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %13)
  call void @llvm.lifetime.start.p0(i64 8, ptr %14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %capacity.i221)
  store i64 %931, ptr %13, align 8
  store i64 %932, ptr %14, align 8
  %933 = load i64, ptr %0, align 8
  %934 = and i64 %933, 63
  %935 = shl i64 1, %934
  store i64 %935, ptr %capacity.i221, align 8
  %936 = load i64, ptr %capacity.i221, align 8
  %937 = add i64 %932, %936
  call void @llvm.lifetime.start.p0(i64 8, ptr %12)
  call void @llvm.lifetime.start.p0(i64 8, ptr %capacity.i.i)
  store i64 %931, ptr %12, align 8
  %938 = load i64, ptr %0, align 8
  %939 = and i64 %938, 63
  %940 = shl i64 1, %939
  store i64 %940, ptr %capacity.i.i, align 8
  %941 = load i64, ptr %capacity.i.i, align 8
  %942 = sub i64 %941, 1
  %943 = and i64 %931, %942
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %capacity.i.i)
  %944 = sub i64 %937, %943
  %945 = load i64, ptr %capacity.i221, align 8
  %946 = sub i64 %945, 1
  %947 = and i64 %944, %946
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %capacity.i221)
  store i64 %947, ptr %probe_distance22, align 8
  %948 = load i64, ptr %probe_distance22, align 8
  %949 = icmp eq i64 %948, 0
  %950 = zext i1 %949 to i8
  %951 = icmp ne i8 %950, 0
  br i1 %951, label %if.then29, label %if.done30

if.then29:                                        ; preds = %if.done28
  %952 = load i64, ptr %key, align 8
  %953 = load i64, ptr %result, align 8
  store i64 %952, ptr %key, align 8
  store i64 %953, ptr %result, align 8
  store i64 %952, ptr %5, align 8
  ret i64 %953

if.done30:                                        ; preds = %if.done28
  %954 = load i64, ptr %probe_distance22, align 8
  %955 = load i64, ptr %look_ahead, align 8
  %956 = icmp ult i64 %954, %955
  %957 = zext i1 %956 to i8
  %958 = icmp ne i8 %957, 0
  br i1 %958, label %if.then31, label %if.done32

if.then31:                                        ; preds = %if.done30
  %959 = load i64, ptr %la_pos, align 8
  %960 = load i64, ptr %probe_distance22, align 8
  %961 = sub i64 %959, %960
  %962 = load i64, ptr %mask, align 8
  %963 = and i64 %961, %962
  store i64 %963, ptr %pos, align 8
  br label %if.done32

if.done32:                                        ; preds = %if.then31, %if.done30
  %964 = load i64, ptr %ks, align 8
  %965 = load ptr, ptr %68, align 8
  %966 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %965, i32 0, i32 0
  %967 = load ptr, ptr %966, align 8
  %968 = load i64, ptr %la_pos, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !183)
  call void @llvm.lifetime.start.p0(i64 8, ptr %61)
  call void @llvm.lifetime.start.p0(i64 8, ptr %62)
  call void @llvm.lifetime.start.p0(i64 8, ptr %63)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i41)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i42)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i43)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i44)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i45)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i46)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i47)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i48)
  store i64 %964, ptr %61, align 8, !noalias !183
  store ptr %967, ptr %62, align 8, !noalias !183
  store i64 %968, ptr %63, align 8, !noalias !183
  %969 = load ptr, ptr %62, align 8, !noalias !183
  %970 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %969, i32 0, i32 3
  %971 = load i64, ptr %970, align 8
  store i64 %971, ptr %elements_per_cell.i41, align 8, !noalias !183
  %972 = load ptr, ptr %62, align 8, !noalias !183
  %973 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %972, i32 0, i32 2
  %974 = load i64, ptr %973, align 8
  store i64 %974, ptr %size_of_cell.i42, align 8, !noalias !183
  %975 = load i64, ptr %elements_per_cell.i41, align 8, !noalias !183
  switch i64 %975, label %switch.default.body.i51 [
    i64 1, label %switch.case.body.i50
    i64 2, label %switch.case.body1.i49
  ]

switch.case.body.i50:                             ; preds = %if.done32
  %976 = load i64, ptr %size_of_cell.i42, align 8, !noalias !183
  %977 = mul i64 %968, %976
  %978 = add i64 %964, %977
  call void @llvm.lifetime.end.p0(i64 8, ptr %61)
  call void @llvm.lifetime.end.p0(i64 8, ptr %62)
  call void @llvm.lifetime.end.p0(i64 8, ptr %63)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i41)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i42)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i43)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i44)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i45)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i46)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i47)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i48)
  br label %"runtime::map_cell_index_dynamic.exit52"

switch.case.body1.i49:                            ; preds = %if.done32
  %979 = lshr i64 %968, 1
  store i64 %979, ptr %cell_index.i43, align 8, !noalias !183
  %980 = and i64 %968, 1
  store i64 %980, ptr %data_index.i44, align 8, !noalias !183
  %981 = load ptr, ptr %62, align 8, !noalias !183
  %982 = load i64, ptr %981, align 8
  store i64 %982, ptr %size_of_type.i45, align 8, !noalias !183
  %983 = load i64, ptr %cell_index.i43, align 8, !noalias !183
  %984 = load i64, ptr %size_of_cell.i42, align 8, !noalias !183
  %985 = mul i64 %983, %984
  %986 = add i64 %964, %985
  %987 = load i64, ptr %data_index.i44, align 8, !noalias !183
  %988 = load i64, ptr %size_of_type.i45, align 8, !noalias !183
  %989 = mul i64 %987, %988
  %990 = add i64 %986, %989
  call void @llvm.lifetime.end.p0(i64 8, ptr %61)
  call void @llvm.lifetime.end.p0(i64 8, ptr %62)
  call void @llvm.lifetime.end.p0(i64 8, ptr %63)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i41)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i42)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i43)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i44)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i45)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i46)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i47)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i48)
  br label %"runtime::map_cell_index_dynamic.exit52"

switch.default.body.i51:                          ; preds = %if.done32
  %991 = load i64, ptr %elements_per_cell.i41, align 8, !noalias !183
  %992 = udiv i64 %968, %991
  store i64 %992, ptr %cell_index2.i46, align 8, !noalias !183
  %993 = load i64, ptr %elements_per_cell.i41, align 8, !noalias !183
  %994 = urem i64 %968, %993
  store i64 %994, ptr %data_index3.i47, align 8, !noalias !183
  %995 = load ptr, ptr %62, align 8, !noalias !183
  %996 = load i64, ptr %995, align 8
  store i64 %996, ptr %size_of_type4.i48, align 8, !noalias !183
  %997 = load i64, ptr %cell_index2.i46, align 8, !noalias !183
  %998 = load i64, ptr %size_of_cell.i42, align 8, !noalias !183
  %999 = mul i64 %997, %998
  %1000 = add i64 %964, %999
  %1001 = load i64, ptr %data_index3.i47, align 8, !noalias !183
  %1002 = load i64, ptr %size_of_type4.i48, align 8, !noalias !183
  %1003 = mul i64 %1001, %1002
  %1004 = add i64 %1000, %1003
  call void @llvm.lifetime.end.p0(i64 8, ptr %61)
  call void @llvm.lifetime.end.p0(i64 8, ptr %62)
  call void @llvm.lifetime.end.p0(i64 8, ptr %63)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i41)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i42)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i43)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i44)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i45)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i46)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i47)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i48)
  br label %"runtime::map_cell_index_dynamic.exit52"

"runtime::map_cell_index_dynamic.exit52":         ; preds = %switch.default.body.i51, %switch.case.body1.i49, %switch.case.body.i50
  %1005 = phi i64 [ %978, %switch.case.body.i50 ], [ %990, %switch.case.body1.i49 ], [ %1004, %switch.default.body.i51 ]
  store i64 %1005, ptr %k_src, align 8
  %1006 = load i64, ptr %vs, align 8
  %1007 = load ptr, ptr %68, align 8
  %1008 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %1007, i32 0, i32 1
  %1009 = load ptr, ptr %1008, align 8
  %1010 = load i64, ptr %la_pos, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !186)
  call void @llvm.lifetime.start.p0(i64 8, ptr %64)
  call void @llvm.lifetime.start.p0(i64 8, ptr %65)
  call void @llvm.lifetime.start.p0(i64 8, ptr %66)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i)
  store i64 %1006, ptr %64, align 8, !noalias !186
  store ptr %1009, ptr %65, align 8, !noalias !186
  store i64 %1010, ptr %66, align 8, !noalias !186
  %1011 = load ptr, ptr %65, align 8, !noalias !186
  %1012 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %1011, i32 0, i32 3
  %1013 = load i64, ptr %1012, align 8
  store i64 %1013, ptr %elements_per_cell.i, align 8, !noalias !186
  %1014 = load ptr, ptr %65, align 8, !noalias !186
  %1015 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %1014, i32 0, i32 2
  %1016 = load i64, ptr %1015, align 8
  store i64 %1016, ptr %size_of_cell.i, align 8, !noalias !186
  %1017 = load i64, ptr %elements_per_cell.i, align 8, !noalias !186
  switch i64 %1017, label %switch.default.body.i [
    i64 1, label %switch.case.body.i
    i64 2, label %switch.case.body1.i
  ]

switch.case.body.i:                               ; preds = %"runtime::map_cell_index_dynamic.exit52"
  %1018 = load i64, ptr %size_of_cell.i, align 8, !noalias !186
  %1019 = mul i64 %1010, %1018
  %1020 = add i64 %1006, %1019
  call void @llvm.lifetime.end.p0(i64 8, ptr %64)
  call void @llvm.lifetime.end.p0(i64 8, ptr %65)
  call void @llvm.lifetime.end.p0(i64 8, ptr %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i)
  br label %"runtime::map_cell_index_dynamic.exit"

switch.case.body1.i:                              ; preds = %"runtime::map_cell_index_dynamic.exit52"
  %1021 = lshr i64 %1010, 1
  store i64 %1021, ptr %cell_index.i, align 8, !noalias !186
  %1022 = and i64 %1010, 1
  store i64 %1022, ptr %data_index.i, align 8, !noalias !186
  %1023 = load ptr, ptr %65, align 8, !noalias !186
  %1024 = load i64, ptr %1023, align 8
  store i64 %1024, ptr %size_of_type.i, align 8, !noalias !186
  %1025 = load i64, ptr %cell_index.i, align 8, !noalias !186
  %1026 = load i64, ptr %size_of_cell.i, align 8, !noalias !186
  %1027 = mul i64 %1025, %1026
  %1028 = add i64 %1006, %1027
  %1029 = load i64, ptr %data_index.i, align 8, !noalias !186
  %1030 = load i64, ptr %size_of_type.i, align 8, !noalias !186
  %1031 = mul i64 %1029, %1030
  %1032 = add i64 %1028, %1031
  call void @llvm.lifetime.end.p0(i64 8, ptr %64)
  call void @llvm.lifetime.end.p0(i64 8, ptr %65)
  call void @llvm.lifetime.end.p0(i64 8, ptr %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i)
  br label %"runtime::map_cell_index_dynamic.exit"

switch.default.body.i:                            ; preds = %"runtime::map_cell_index_dynamic.exit52"
  %1033 = load i64, ptr %elements_per_cell.i, align 8, !noalias !186
  %1034 = udiv i64 %1010, %1033
  store i64 %1034, ptr %cell_index2.i, align 8, !noalias !186
  %1035 = load i64, ptr %elements_per_cell.i, align 8, !noalias !186
  %1036 = urem i64 %1010, %1035
  store i64 %1036, ptr %data_index3.i, align 8, !noalias !186
  %1037 = load ptr, ptr %65, align 8, !noalias !186
  %1038 = load i64, ptr %1037, align 8
  store i64 %1038, ptr %size_of_type4.i, align 8, !noalias !186
  %1039 = load i64, ptr %cell_index2.i, align 8, !noalias !186
  %1040 = load i64, ptr %size_of_cell.i, align 8, !noalias !186
  %1041 = mul i64 %1039, %1040
  %1042 = add i64 %1006, %1041
  %1043 = load i64, ptr %data_index3.i, align 8, !noalias !186
  %1044 = load i64, ptr %size_of_type4.i, align 8, !noalias !186
  %1045 = mul i64 %1043, %1044
  %1046 = add i64 %1042, %1045
  call void @llvm.lifetime.end.p0(i64 8, ptr %64)
  call void @llvm.lifetime.end.p0(i64 8, ptr %65)
  call void @llvm.lifetime.end.p0(i64 8, ptr %66)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i)
  br label %"runtime::map_cell_index_dynamic.exit"

"runtime::map_cell_index_dynamic.exit":           ; preds = %switch.default.body.i, %switch.case.body1.i, %switch.case.body.i
  %1047 = phi i64 [ %1020, %switch.case.body.i ], [ %1032, %switch.case.body1.i ], [ %1046, %switch.default.body.i ]
  store i64 %1047, ptr %v_src, align 8
  br label %for.loop

for.done33:                                       ; preds = %for.loop
  %1048 = load i64, ptr %key, align 8
  %1049 = load i64, ptr %result, align 8
  store i64 %1048, ptr %key, align 8
  store i64 %1049, ptr %result, align 8
  store i64 %1048, ptr %5, align 8
  ret i64 %1049

if.else:                                          ; preds = %"runtime::map_cell_index_dynamic.exit88"
  %1050 = load i64, ptr %distance, align 8
  %1051 = load i64, ptr %probe_distance22, align 8
  %1052 = load i64, ptr %look_ahead, align 8
  %1053 = sub i64 %1051, %1052
  %1054 = icmp ult i64 %1050, %1053
  %1055 = zext i1 %1054 to i8
  %1056 = icmp ne i8 %1055, 0
  br i1 %1056, label %if.then34, label %if.else35

if.then34:                                        ; preds = %if.else
  %1057 = load i64, ptr %k_dst16, align 8
  %1058 = inttoptr i64 %1057 to ptr
  %1059 = load i64, ptr %k_src, align 8
  %1060 = inttoptr i64 %1059 to ptr
  %1061 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %1058, ptr %1060, i64 %1061, i1 false)
  %1062 = load i64, ptr %v_dst17, align 8
  %1063 = inttoptr i64 %1062 to ptr
  %1064 = load i64, ptr %v_src, align 8
  %1065 = inttoptr i64 %1064 to ptr
  %1066 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %1063, ptr %1065, i64 %1066, i1 false)
  %1067 = load ptr, ptr %hs, align 8
  %1068 = load i64, ptr %pos, align 8
  %1069 = getelementptr i64, ptr %1067, i64 %1068
  %1070 = load i64, ptr %element_hash12, align 8
  store i64 %1070, ptr %1069, align 8
  %1071 = load ptr, ptr %hs, align 8
  %1072 = load i64, ptr %la_pos, align 8
  %1073 = getelementptr i64, ptr %1071, i64 %1072
  store i64 0, ptr %1073, align 8
  br label %if.done38

if.else35:                                        ; preds = %if.else
  %1074 = load i64, ptr %result, align 8
  %1075 = icmp eq i64 %1074, 0
  %1076 = zext i1 %1075 to i8
  %1077 = icmp ne i8 %1076, 0
  br i1 %1077, label %if.then36, label %if.done37

if.then36:                                        ; preds = %if.else35
  %1078 = load i64, ptr %k_dst16, align 8
  store i64 %1078, ptr %key, align 8
  %1079 = load i64, ptr %v_dst17, align 8
  store i64 %1079, ptr %result, align 8
  br label %if.done37

if.done37:                                        ; preds = %if.then36, %if.else35
  %1080 = load i64, ptr %k_dst16, align 8
  %1081 = inttoptr i64 %1080 to ptr
  %1082 = load i64, ptr %k, align 8
  %1083 = inttoptr i64 %1082 to ptr
  %1084 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %1081, ptr %1083, i64 %1084, i1 false)
  %1085 = load i64, ptr %v_dst17, align 8
  %1086 = inttoptr i64 %1085 to ptr
  %1087 = load i64, ptr %v, align 8
  %1088 = inttoptr i64 %1087 to ptr
  %1089 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %1086, ptr %1088, i64 %1089, i1 false)
  %1090 = load ptr, ptr %hs, align 8
  %1091 = load i64, ptr %pos, align 8
  %1092 = getelementptr i64, ptr %1090, i64 %1091
  %1093 = load i64, ptr %h, align 8
  store i64 %1093, ptr %1092, align 8
  %1094 = load i64, ptr %k, align 8
  %1095 = inttoptr i64 %1094 to ptr
  %1096 = load i64, ptr %k_src, align 8
  %1097 = inttoptr i64 %1096 to ptr
  %1098 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %1095, ptr %1097, i64 %1098, i1 false)
  %1099 = load i64, ptr %v, align 8
  %1100 = inttoptr i64 %1099 to ptr
  %1101 = load i64, ptr %v_src, align 8
  %1102 = inttoptr i64 %1101 to ptr
  %1103 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %1100, ptr %1102, i64 %1103, i1 false)
  %1104 = load ptr, ptr %hs, align 8
  %1105 = load i64, ptr %la_pos, align 8
  %1106 = getelementptr i64, ptr %1104, i64 %1105
  %1107 = load i64, ptr %1106, align 8
  store i64 %1107, ptr %h, align 8
  %1108 = load ptr, ptr %hs, align 8
  %1109 = load i64, ptr %la_pos, align 8
  %1110 = getelementptr i64, ptr %1108, i64 %1109
  store i64 0, ptr %1110, align 8
  %1111 = load i64, ptr %probe_distance22, align 8
  %1112 = load i64, ptr %look_ahead, align 8
  %1113 = sub i64 %1111, %1112
  store i64 %1113, ptr %distance, align 8
  br label %if.done38

if.done38:                                        ; preds = %if.done37, %if.then34
  br label %if.done39

if.done39:                                        ; preds = %if.done38
  %1114 = load i64, ptr %pos, align 8
  %1115 = add i64 %1114, 1
  %1116 = load i64, ptr %mask, align 8
  %1117 = and i64 %1115, %1116
  store i64 %1117, ptr %pos, align 8
  %1118 = load i64, ptr %distance, align 8
  %1119 = add i64 %1118, 1
  store i64 %1119, ptr %distance, align 8
  br label %for.body11

for.done40:                                       ; No predecessors!
  unreachable
}

define void @"runtime::[core.odin]::__init_context"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = icmp eq ptr %0, null
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  %5 = load ptr, ptr %1, align 8
  %6 = getelementptr inbounds nuw %"runtime::Context", ptr %5, i32 0, i32 0
  %7 = getelementptr inbounds nuw %"runtime::Allocator", ptr %6, i32 0, i32 0
  store ptr @"runtime::heap_allocator_proc", ptr %7, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr inbounds nuw %"runtime::Context", ptr %8, i32 0, i32 0
  %10 = getelementptr inbounds nuw %"runtime::Allocator", ptr %9, i32 0, i32 1
  store ptr null, ptr %10, align 8
  %11 = load ptr, ptr %1, align 8
  %12 = getelementptr inbounds nuw %"runtime::Context", ptr %11, i32 0, i32 1
  %13 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 0
  store ptr @"runtime::default_temp_allocator_proc", ptr %13, align 8
  %14 = load ptr, ptr %1, align 8
  %15 = getelementptr inbounds nuw %"runtime::Context", ptr %14, i32 0, i32 1
  %16 = getelementptr inbounds nuw %"runtime::Allocator", ptr %15, i32 0, i32 1
  store ptr @"runtime::global_default_temp_allocator_data", ptr %16, align 8
  %17 = load ptr, ptr %1, align 8
  %18 = getelementptr inbounds nuw %"runtime::Context", ptr %17, i32 0, i32 2
  store ptr @"runtime::default_assertion_failure_proc", ptr %18, align 8
  %19 = load ptr, ptr %1, align 8
  %20 = getelementptr inbounds nuw %"runtime::Context", ptr %19, i32 0, i32 3
  %21 = getelementptr inbounds nuw %"runtime::Logger", ptr %20, i32 0, i32 0
  store ptr @"runtime::default_logger_proc", ptr %21, align 8
  %22 = load ptr, ptr %1, align 8
  %23 = getelementptr inbounds nuw %"runtime::Context", ptr %22, i32 0, i32 3
  %24 = getelementptr inbounds nuw %"runtime::Logger", ptr %23, i32 0, i32 1
  store ptr null, ptr %24, align 8
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr inbounds nuw %"runtime::Context", ptr %25, i32 0, i32 4
  %27 = getelementptr inbounds nuw %"runtime::Random_Generator", ptr %26, i32 0, i32 0
  store ptr @"runtime::default_random_generator_proc", ptr %27, align 8
  %28 = load ptr, ptr %1, align 8
  %29 = getelementptr inbounds nuw %"runtime::Context", ptr %28, i32 0, i32 4
  %30 = getelementptr inbounds nuw %"runtime::Random_Generator", ptr %29, i32 0, i32 1
  store ptr null, ptr %30, align 8
  ret void
}

define i8 @"runtime::make_slice:proc(T:$[]u8,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[]u8,:runtime::Allocator_Error)"(i64 %0, ptr %1, ptr %2, ptr noalias nonnull %3, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 8
  %6 = alloca { ptr, i64 }, align 8
  %7 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %1, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %6, i8 0, i64 16, i1 false)
  %8 = call i8 @"runtime::make_aligned:proc(T:$[]u8,len:int,alignment:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[]u8,:runtime::Allocator_Error)"(i64 %0, i64 1, ptr %5, ptr %2, ptr %6, ptr %__.context_ptr)
  %9 = load { ptr, i64 }, ptr %6, align 8
  store { ptr, i64 } %9, ptr %3, align 8
  ret i8 %8
}

define i8 @"runtime::make_slice:proc(T:$[]u16,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[]u16,:runtime::Allocator_Error)"(i64 %0, ptr %1, ptr %2, ptr noalias nonnull %3, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 8
  %6 = alloca { ptr, i64 }, align 8
  %7 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %1, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %6, i8 0, i64 16, i1 false)
  %8 = call i8 @"runtime::make_aligned:proc(T:$[]u16,len:int,alignment:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[]u16,:runtime::Allocator_Error)"(i64 %0, i64 2, ptr %5, ptr %2, ptr %6, ptr %__.context_ptr)
  %9 = load { ptr, i64 }, ptr %6, align 8
  store { ptr, i64 } %9, ptr %3, align 8
  ret i8 %8
}

define i8 @"runtime::make_dynamic_array:proc(T:$[dynamic]text_analyzer::Filter,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[dynamic]text_analyzer::Filter,:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nonnull %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca %"runtime::Allocator", align 8
  %4 = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %5 = alloca { { ptr, i64, i64, %"runtime::Allocator" }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %0, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr %4, i8 0, i64 40, i1 false)
  %6 = call i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]text_analyzer::Filter,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]text_analyzer::Filter,err:runtime::Allocator_Error)"(i64 0, i64 0, ptr %3, ptr %1, ptr %4, ptr %__.context_ptr)
  %7 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %4, align 8
  store { ptr, i64, i64, %"runtime::Allocator" } %7, ptr %2, align 8
  ret i8 %6
}

define i8 @"runtime::make_dynamic_array:proc(T:$[dynamic]text_analyzer::DisplayLine,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[dynamic]text_analyzer::DisplayLine,:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nonnull %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca %"runtime::Allocator", align 8
  %4 = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %5 = alloca { { ptr, i64, i64, %"runtime::Allocator" }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %0, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr %4, i8 0, i64 40, i1 false)
  %6 = call i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]text_analyzer::DisplayLine,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]text_analyzer::DisplayLine,err:runtime::Allocator_Error)"(i64 0, i64 0, ptr %3, ptr %1, ptr %4, ptr %__.context_ptr)
  %7 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %4, align 8
  store { ptr, i64, i64, %"runtime::Allocator" } %7, ptr %2, align 8
  ret i8 %6
}

define i8 @"runtime::make_dynamic_array:proc(T:$[dynamic]u8,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[dynamic]u8,:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nonnull %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca %"runtime::Allocator", align 8
  %4 = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %5 = alloca { { ptr, i64, i64, %"runtime::Allocator" }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %0, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr %4, i8 0, i64 40, i1 false)
  %6 = call i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]u8,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]u8,err:runtime::Allocator_Error)"(i64 0, i64 0, ptr %3, ptr %1, ptr %4, ptr %__.context_ptr)
  %7 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %4, align 8
  store { ptr, i64, i64, %"runtime::Allocator" } %7, ptr %2, align 8
  ret i8 %6
}

define i8 @"runtime::make_dynamic_array:proc(T:$[dynamic]int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[dynamic]int,:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nonnull %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca %"runtime::Allocator", align 8
  %4 = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %5 = alloca { { ptr, i64, i64, %"runtime::Allocator" }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %0, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr %4, i8 0, i64 40, i1 false)
  %6 = call i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]int,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]int,err:runtime::Allocator_Error)"(i64 0, i64 0, ptr %3, ptr %1, ptr %4, ptr %__.context_ptr)
  %7 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %4, align 8
  store { ptr, i64, i64, %"runtime::Allocator" } %7, ptr %2, align 8
  ret i8 %6
}

define i8 @"runtime::make_dynamic_array:proc(T:$[dynamic]string,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[dynamic]string,:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nonnull %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca %"runtime::Allocator", align 8
  %4 = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %5 = alloca { { ptr, i64, i64, %"runtime::Allocator" }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %0, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr %4, i8 0, i64 40, i1 false)
  %6 = call i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]string,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]string,err:runtime::Allocator_Error)"(i64 0, i64 0, ptr %3, ptr %1, ptr %4, ptr %__.context_ptr)
  %7 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %4, align 8
  store { ptr, i64, i64, %"runtime::Allocator" } %7, ptr %2, align 8
  ret i8 %6
}

define i8 @"runtime::make_dynamic_array:proc(T:$[dynamic]text_analyzer::Highlight,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:[dynamic]text_analyzer::Highlight,:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nonnull %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca %"runtime::Allocator", align 8
  %4 = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %5 = alloca { { ptr, i64, i64, %"runtime::Allocator" }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %0, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr %4, i8 0, i64 40, i1 false)
  %6 = call i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]text_analyzer::Highlight,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]text_analyzer::Highlight,err:runtime::Allocator_Error)"(i64 0, i64 0, ptr %3, ptr %1, ptr %4, ptr %__.context_ptr)
  %7 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %4, align 8
  store { ptr, i64, i64, %"runtime::Allocator" } %7, ptr %2, align 8
  ret i8 %6
}

define i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]u8,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]u8,err:runtime::Allocator_Error)"(i64 %0, i64 %1, ptr %2, ptr %3, ptr noalias nonnull %4, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca %"runtime::Allocator", align 8
  %array = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %err = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %2, i64 16, i1 false)
  call void @llvm.memset.p0.i64(ptr %array, i8 0, i64 40, i1 false)
  store i8 0, ptr %err, align 1
  %8 = call i8 @"runtime::_make_dynamic_array_len_cap"(ptr %array, i64 1, i64 1, i64 %0, i64 %1, ptr %7, ptr %3, ptr %__.context_ptr)
  store i8 %8, ptr %err, align 1
  %9 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %array, align 8
  %10 = load i8, ptr %err, align 1
  store { ptr, i64, i64, %"runtime::Allocator" } %9, ptr %array, align 8
  store i8 %10, ptr %err, align 1
  store { ptr, i64, i64, %"runtime::Allocator" } %9, ptr %4, align 8
  ret i8 %10
}

; Function Attrs: alwaysinline
define i8 @"runtime::cstring_ne"(ptr %0, ptr %1) #1 {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store ptr %1, ptr %3, align 8
  %4 = call i8 @"runtime::cstring_eq"(ptr %0, ptr %1)
  %5 = icmp eq i8 %4, 0
  %6 = zext i1 %5 to i8
  ret i8 %6
}

define void @"runtime::make_map:proc(T:$map[int]bool,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(m:map[int]bool)"(ptr noalias sret(%"runtime::Raw_Map") %agg.result, ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %2 = alloca %"runtime::Allocator", align 8
  %m = alloca %"runtime::Raw_Map", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %m, i8 0, i64 32, i1 false)
  %3 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %m, i32 0, i32 2
  %4 = load %"runtime::Allocator", ptr %2, align 8
  store %"runtime::Allocator" %4, ptr %3, align 8
  %5 = load %"runtime::Raw_Map", ptr %m, align 8
  store %"runtime::Raw_Map" %5, ptr %m, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %agg.result, ptr %m, i64 32, i1 false)
  ret void
}

; Function Attrs: noreturn
define void @"runtime::default_assertion_failure_proc"(ptr %0, ptr %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) #0 {
decls:
  %3 = alloca %..string, align 8
  %4 = alloca %..string, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %1, i64 16, i1 false)
  call void @"runtime::default_assertion_contextless_failure_proc"(ptr %3, ptr %4, ptr %2)
  unreachable
}

; Function Attrs: noreturn
define void @"runtime::default_assertion_contextless_failure_proc"(ptr %0, ptr %1, ptr %2) #0 {
decls:
  %3 = alloca %..string, align 8
  %4 = alloca %..string, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %0, i64 16, i1 false)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %1, i64 16, i1 false)
  call void @"runtime::print_caller_location"(ptr %2)
  %5 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::default_assertion_contextless_failure_proc$1")
  %6 = call i64 @"runtime::print_string"(ptr %3)
  %7 = getelementptr inbounds nuw %..string, ptr %4, i32 0, i32 1
  %8 = load i64, ptr %7, align 8
  %9 = icmp sgt i64 %8, 0
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %12 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::default_assertion_contextless_failure_proc$2")
  %13 = call i64 @"runtime::print_string"(ptr %4)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %14 = call i64 @"runtime::print_byte"(i8 10)
  call void @llvm.trap()
  unreachable
}

define void @"runtime::ordered_remove:proc(array:^[dynamic]int,index:int,loc:runtime::Source_Code_Location)"(ptr %0, i64 %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca ptr, align 8
  %6 = alloca i64, align 8
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  %10 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  store i64 %1, ptr %3, align 8
  store i64 %11, ptr %4, align 8
  %12 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %2, i32 0, i32 1
  %13 = load i32, ptr %12, align 4
  %14 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %2, i32 0, i32 2
  %15 = load i32, ptr %14, align 4
  call void @"runtime::bounds_check_error"(ptr %2, i32 %13, i32 %15, i64 %1, i64 %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  %16 = add i64 %1, 1
  %17 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 1
  %18 = load i64, ptr %17, align 8
  %19 = icmp slt i64 %16, %18
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %22 = load ptr, ptr %5, align 8
  %23 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %22, i32 0, i32 1
  %24 = load i64, ptr %23, align 8
  %25 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %22, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i64, ptr %26, i64 %1
  %28 = sub i64 %24, %1
  %29 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 0
  store ptr %27, ptr %29, align 8
  %30 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 1
  store i64 %28, ptr %30, align 8
  %31 = load ptr, ptr %5, align 8
  %32 = add i64 %1, 1
  %33 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %31, i32 0, i32 1
  %34 = load i64, ptr %33, align 8
  %35 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %31, i32 0, i32 0
  %36 = load ptr, ptr %35, align 8
  %37 = getelementptr i64, ptr %36, i64 %32
  %38 = sub i64 %34, %32
  %39 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 0
  store ptr %37, ptr %39, align 8
  %40 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 1
  store i64 %38, ptr %40, align 8
  %41 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]int,src:[]int)->(:int)"(ptr %7, ptr %8)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  store ptr %0, ptr %9, align 8
  %42 = load ptr, ptr %9, align 8
  %43 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %42, i32 0, i32 1
  %44 = load i64, ptr %43, align 8
  %45 = sub i64 %44, 1
  store i64 %45, ptr %43, align 8
  ret void
}

; Function Attrs: alwaysinline
define i8 @"runtime::_append_elem"(ptr %0, i64 %1, i64 %2, ptr %3, i1 zeroext %4, ptr %5, ptr noalias nonnull %6, ptr noalias nocapture nonnull %__.context_ptr) #1 {
decls:
  %7 = alloca ptr, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i8, align 1
  %old_size.i = alloca i64, align 8
  %new_size.i = alloca i64, align 8
  %allocator.i = alloca %"runtime::Allocator", align 8
  %new_data.i = alloca { ptr, i64 }, align 8
  %12 = alloca { ptr, i64 }, align 8
  %13 = alloca { ptr, i64 }, align 8
  %14 = alloca ptr, align 8
  %15 = alloca i64, align 8
  %16 = alloca i64, align 8
  %17 = alloca ptr, align 8
  %18 = alloca i8, align 1
  %n = alloca i64, align 8
  %err = alloca i8, align 1
  %cap = alloca i64, align 8
  %data = alloca ptr, align 8
  %19 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %14, align 8
  store i64 %1, ptr %15, align 8
  store i64 %2, ptr %16, align 8
  store ptr %3, ptr %17, align 8
  %20 = zext i1 %4 to i8
  store i8 %20, ptr %18, align 1
  store i64 0, ptr %n, align 8
  store i8 0, ptr %err, align 1
  %21 = icmp eq ptr %0, null
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %24 = load i64, ptr %n, align 8
  %25 = load i8, ptr %err, align 1
  store i64 %24, ptr %n, align 8
  store i8 %25, ptr %err, align 1
  store i64 %24, ptr %6, align 8
  ret i8 %25

if.done:                                          ; preds = %entry
  %26 = load ptr, ptr %14, align 8
  %27 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %26, i32 0, i32 2
  %28 = load i64, ptr %27, align 8
  %29 = load ptr, ptr %14, align 8
  %30 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %29, i32 0, i32 1
  %31 = load i64, ptr %30, align 8
  %32 = add i64 %31, 1
  %33 = icmp slt i64 %28, %32
  %34 = zext i1 %33 to i8
  %35 = icmp ne i8 %34, 0
  br i1 %35, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  %36 = load ptr, ptr %14, align 8
  %37 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %36, i32 0, i32 2
  %38 = load i64, ptr %37, align 8
  %39 = mul i64 2, %38
  %40 = add i64 %39, 8
  store i64 %40, ptr %cap, align 8
  %41 = load i64, ptr %cap, align 8
  %42 = icmp ne i8 %20, 0
  call void @llvm.experimental.noalias.scope.decl(metadata !189)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 1, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %12)
  call void @llvm.lifetime.start.p0(i64 16, ptr %13)
  store ptr %0, ptr %7, align 8, !noalias !189
  store i64 %1, ptr %8, align 8, !noalias !189
  store i64 %2, ptr %9, align 8, !noalias !189
  store i64 %41, ptr %10, align 8, !noalias !189
  %43 = zext i1 %42 to i8
  store i8 %43, ptr %11, align 1, !noalias !189
  %44 = icmp eq ptr %0, null
  %45 = zext i1 %44 to i8
  br i1 %44, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %if.then1
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 1, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done.i:                                        ; preds = %if.then1
  %46 = load ptr, ptr %7, align 8, !noalias !189
  %47 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %46, i32 0, i32 2
  %48 = load i64, ptr %47, align 8, !noalias !189
  %49 = icmp sle i64 %41, %48
  %50 = zext i1 %49 to i8
  br i1 %49, label %if.then1.i, label %if.done2.i

if.then1.i:                                       ; preds = %if.done.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 1, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done2.i:                                       ; preds = %if.done.i
  %51 = load ptr, ptr %7, align 8, !noalias !189
  %52 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %51, i32 0, i32 3
  %53 = load ptr, ptr %52, align 8, !noalias !189
  %54 = icmp eq ptr %53, null
  %55 = zext i1 %54 to i8
  br i1 %54, label %if.then3.i, label %if.done4.i

if.then3.i:                                       ; preds = %if.done2.i
  %56 = load ptr, ptr %7, align 8, !noalias !189
  %57 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %56, i32 0, i32 3
  %58 = load %"runtime::Allocator", ptr %__.context_ptr, align 8, !alias.scope !189
  store %"runtime::Allocator" %58, ptr %57, align 8, !noalias !189
  br label %if.done4.i

if.done4.i:                                       ; preds = %if.then3.i, %if.done2.i
  %59 = load ptr, ptr %7, align 8, !noalias !189
  %60 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %59, i32 0, i32 3
  %61 = load ptr, ptr %60, align 8, !noalias !189
  %62 = icmp ne ptr %61, null
  %63 = zext i1 %62 to i8
  call void @"runtime::assert"(i1 zeroext %62, ptr @"ggv$runtime::_reserve_dynamic_array$1", ptr @"scl$[_reserve_dynamic_array28302]", ptr nonnull %__.context_ptr)
  %64 = load ptr, ptr %7, align 8, !noalias !189
  %65 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %64, i32 0, i32 2
  %66 = load i64, ptr %65, align 8, !noalias !189
  %67 = mul i64 %66, %1
  store i64 %67, ptr %old_size.i, align 8, !noalias !189
  %68 = mul i64 %41, %1
  store i64 %68, ptr %new_size.i, align 8, !noalias !189
  %69 = load ptr, ptr %7, align 8, !noalias !189
  %70 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %69, i32 0, i32 3
  %71 = load %"runtime::Allocator", ptr %70, align 8, !noalias !189
  store %"runtime::Allocator" %71, ptr %allocator.i, align 8, !noalias !189
  call void @llvm.memset.inline.p0.i64(ptr %new_data.i, i8 0, i64 16, i1 false), !noalias !189
  br i1 %42, label %if.then5.i, label %if.else.i

if.then5.i:                                       ; preds = %if.done4.i
  %72 = load ptr, ptr %7, align 8, !noalias !189
  %73 = load ptr, ptr %72, align 8, !noalias !189
  %74 = load i64, ptr %old_size.i, align 8, !noalias !189
  %75 = load i64, ptr %new_size.i, align 8, !noalias !189
  call void @llvm.memset.inline.p0.i64(ptr %12, i8 0, i64 16, i1 false), !noalias !189
  %76 = call i8 @"runtime::mem_resize"(ptr %73, i64 %74, i64 %75, i64 %2, ptr %allocator.i, ptr %5, ptr %12, ptr nonnull %__.context_ptr)
  %77 = load { ptr, i64 }, ptr %12, align 8, !noalias !189
  %78 = icmp eq i8 %76, 0
  br i1 %78, label %or_return.continue.i, label %or_return.return.i

or_return.return.i:                               ; preds = %if.then5.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 1, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  br label %"runtime::_reserve_dynamic_array.exit"

or_return.continue.i:                             ; preds = %if.then5.i
  store { ptr, i64 } %77, ptr %new_data.i, align 8, !noalias !189
  br label %if.done8.i

if.else.i:                                        ; preds = %if.done4.i
  %79 = load ptr, ptr %7, align 8, !noalias !189
  %80 = load ptr, ptr %79, align 8, !noalias !189
  %81 = load i64, ptr %old_size.i, align 8, !noalias !189
  %82 = load i64, ptr %new_size.i, align 8, !noalias !189
  call void @llvm.memset.inline.p0.i64(ptr %13, i8 0, i64 16, i1 false), !noalias !189
  %83 = call i8 @"runtime::non_zero_mem_resize"(ptr %80, i64 %81, i64 %82, i64 %2, ptr %allocator.i, ptr %5, ptr %13, ptr nonnull %__.context_ptr)
  %84 = load { ptr, i64 }, ptr %13, align 8, !noalias !189
  %85 = icmp eq i8 %83, 0
  br i1 %85, label %or_return.continue7.i, label %or_return.return6.i

or_return.return6.i:                              ; preds = %if.else.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 1, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  br label %"runtime::_reserve_dynamic_array.exit"

or_return.continue7.i:                            ; preds = %if.else.i
  store { ptr, i64 } %84, ptr %new_data.i, align 8, !noalias !189
  br label %if.done8.i

if.done8.i:                                       ; preds = %or_return.continue7.i, %or_return.continue.i
  %86 = load ptr, ptr %new_data.i, align 8, !noalias !189
  %87 = icmp eq ptr %86, null
  %88 = zext i1 %87 to i8
  br i1 %87, label %cmp.and.i, label %if.done10.i

cmp.and.i:                                        ; preds = %if.done8.i
  %89 = load i64, ptr %new_size.i, align 8, !noalias !189
  %90 = icmp sgt i64 %89, 0
  %91 = zext i1 %90 to i8
  br i1 %90, label %if.then9.i, label %if.done10.i

if.then9.i:                                       ; preds = %cmp.and.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 1, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done10.i:                                      ; preds = %cmp.and.i, %if.done8.i
  %92 = load ptr, ptr %7, align 8, !noalias !189
  %93 = load ptr, ptr %new_data.i, align 8, !noalias !189
  store ptr %93, ptr %92, align 8, !noalias !189
  %94 = load ptr, ptr %7, align 8, !noalias !189
  %95 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %94, i32 0, i32 2
  store i64 %41, ptr %95, align 8, !noalias !189
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 1, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %12)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  br label %"runtime::_reserve_dynamic_array.exit"

"runtime::_reserve_dynamic_array.exit":           ; preds = %if.done10.i, %if.then9.i, %or_return.return6.i, %or_return.return.i, %if.then1.i, %if.then.i
  %96 = phi i8 [ 0, %if.then.i ], [ 0, %if.then1.i ], [ %76, %or_return.return.i ], [ %83, %or_return.return6.i ], [ 1, %if.then9.i ], [ 0, %if.done10.i ]
  store i8 %96, ptr %err, align 1
  br label %if.done2

if.done2:                                         ; preds = %"runtime::_reserve_dynamic_array.exit", %if.done
  %97 = load ptr, ptr %14, align 8
  %98 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %97, i32 0, i32 2
  %99 = load i64, ptr %98, align 8
  %100 = load ptr, ptr %14, align 8
  %101 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %100, i32 0, i32 1
  %102 = load i64, ptr %101, align 8
  %103 = sub i64 %99, %102
  %104 = icmp sgt i64 %103, 0
  %105 = zext i1 %104 to i8
  %106 = icmp ne i8 %105, 0
  br i1 %106, label %if.then3, label %if.done4

if.then3:                                         ; preds = %if.done2
  %107 = load ptr, ptr %14, align 8
  %108 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %107, i32 0, i32 0
  %109 = load ptr, ptr %108, align 8
  store ptr %109, ptr %data, align 8
  %110 = load ptr, ptr %data, align 8
  %111 = icmp ne ptr %110, null
  %112 = zext i1 %111 to i8
  %113 = icmp ne i8 %112, 0
  call void @"runtime::assert"(i1 zeroext %113, ptr @"ggv$runtime::_append_elem$1", ptr %5, ptr %__.context_ptr)
  %114 = load ptr, ptr %data, align 8
  %115 = load ptr, ptr %14, align 8
  %116 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %115, i32 0, i32 1
  %117 = load i64, ptr %116, align 8
  %118 = mul i64 %117, %1
  %119 = getelementptr i8, ptr %114, i64 %118
  store ptr %119, ptr %19, align 8
  %120 = load ptr, ptr %19, align 8
  store ptr %120, ptr %data, align 8
  %121 = load ptr, ptr %data, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %121, ptr %3, i64 %1, i1 false)
  %122 = load ptr, ptr %14, align 8
  %123 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %122, i32 0, i32 1
  %124 = load i64, ptr %123, align 8
  %125 = add i64 %124, 1
  store i64 %125, ptr %123, align 8
  store i64 1, ptr %n, align 8
  br label %if.done4

if.done4:                                         ; preds = %if.then3, %if.done2
  %126 = load i64, ptr %n, align 8
  %127 = load i8, ptr %err, align 1
  store i64 %126, ptr %n, align 8
  store i8 %127, ptr %err, align 1
  store i64 %126, ptr %6, align 8
  ret i8 %127
}

define void @"runtime::ordered_remove:proc(array:^[dynamic]text_analyzer::Filter,index:int,loc:runtime::Source_Code_Location)"(ptr %0, i64 %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca ptr, align 8
  %6 = alloca i64, align 8
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  %10 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  store i64 %1, ptr %3, align 8
  store i64 %11, ptr %4, align 8
  %12 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %2, i32 0, i32 1
  %13 = load i32, ptr %12, align 4
  %14 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %2, i32 0, i32 2
  %15 = load i32, ptr %14, align 4
  call void @"runtime::bounds_check_error"(ptr %2, i32 %13, i32 %15, i64 %1, i64 %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  %16 = add i64 %1, 1
  %17 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 1
  %18 = load i64, ptr %17, align 8
  %19 = icmp slt i64 %16, %18
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %22 = load ptr, ptr %5, align 8
  %23 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %22, i32 0, i32 1
  %24 = load i64, ptr %23, align 8
  %25 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %22, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr %"text_analyzer::Filter", ptr %26, i64 %1
  %28 = sub i64 %24, %1
  %29 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 0
  store ptr %27, ptr %29, align 8
  %30 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 1
  store i64 %28, ptr %30, align 8
  %31 = load ptr, ptr %5, align 8
  %32 = add i64 %1, 1
  %33 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %31, i32 0, i32 1
  %34 = load i64, ptr %33, align 8
  %35 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %31, i32 0, i32 0
  %36 = load ptr, ptr %35, align 8
  %37 = getelementptr %"text_analyzer::Filter", ptr %36, i64 %32
  %38 = sub i64 %34, %32
  %39 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 0
  store ptr %37, ptr %39, align 8
  %40 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 1
  store i64 %38, ptr %40, align 8
  %41 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]text_analyzer::Filter,src:[]text_analyzer::Filter)->(:int)"(ptr %7, ptr %8)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  store ptr %0, ptr %9, align 8
  %42 = load ptr, ptr %9, align 8
  %43 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %42, i32 0, i32 1
  %44 = load i64, ptr %43, align 8
  %45 = sub i64 %44, 1
  store i64 %45, ptr %43, align 8
  ret void
}

define void @"runtime::ordered_remove:proc(array:^[dynamic]text_analyzer::Highlight,index:int,loc:runtime::Source_Code_Location)"(ptr %0, i64 %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca ptr, align 8
  %6 = alloca i64, align 8
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  %10 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  store i64 %1, ptr %3, align 8
  store i64 %11, ptr %4, align 8
  %12 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %2, i32 0, i32 1
  %13 = load i32, ptr %12, align 4
  %14 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %2, i32 0, i32 2
  %15 = load i32, ptr %14, align 4
  call void @"runtime::bounds_check_error"(ptr %2, i32 %13, i32 %15, i64 %1, i64 %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  %16 = add i64 %1, 1
  %17 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 1
  %18 = load i64, ptr %17, align 8
  %19 = icmp slt i64 %16, %18
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %22 = load ptr, ptr %5, align 8
  %23 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %22, i32 0, i32 1
  %24 = load i64, ptr %23, align 8
  %25 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %22, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr %"text_analyzer::Highlight", ptr %26, i64 %1
  %28 = sub i64 %24, %1
  %29 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 0
  store ptr %27, ptr %29, align 8
  %30 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 1
  store i64 %28, ptr %30, align 8
  %31 = load ptr, ptr %5, align 8
  %32 = add i64 %1, 1
  %33 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %31, i32 0, i32 1
  %34 = load i64, ptr %33, align 8
  %35 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %31, i32 0, i32 0
  %36 = load ptr, ptr %35, align 8
  %37 = getelementptr %"text_analyzer::Highlight", ptr %36, i64 %32
  %38 = sub i64 %34, %32
  %39 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 0
  store ptr %37, ptr %39, align 8
  %40 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 1
  store i64 %38, ptr %40, align 8
  %41 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]text_analyzer::Highlight,src:[]text_analyzer::Highlight)->(:int)"(ptr %7, ptr %8)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  store ptr %0, ptr %9, align 8
  %42 = load ptr, ptr %9, align 8
  %43 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %42, i32 0, i32 1
  %44 = load i64, ptr %43, align 8
  %45 = sub i64 %44, 1
  store i64 %45, ptr %43, align 8
  ret void
}

; Function Attrs: alwaysinline
define i64 @"runtime::string_decode_rune"(ptr %0, ptr noalias nonnull %1) #1 {
decls:
  %2 = alloca %..string, align 8
  %n = alloca i64, align 8
  %s0 = alloca i8, align 1
  %x = alloca i8, align 1
  %mask = alloca i32, align 4
  %sz = alloca i8, align 1
  %accept = alloca %"runtime::string_decode_rune::Accept_Range::$1", align 1
  %b1 = alloca i8, align 1
  %b2 = alloca i8, align 1
  %b3 = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 16, i1 false)
  %3 = getelementptr inbounds nuw %..string, ptr %2, i32 0, i32 1
  %4 = load i64, ptr %3, align 8
  store i64 %4, ptr %n, align 8
  %5 = load i64, ptr %n, align 8
  %6 = icmp slt i64 %5, 1
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store i32 65533, ptr %1, align 4
  ret i64 0

if.done:                                          ; preds = %entry
  %9 = getelementptr inbounds nuw %..string, ptr %2, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr inbounds nuw %..string, ptr %2, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  call void @"runtime::bounds_check_error"(ptr @"ggv$runtime::string_decode_rune$1", i32 630, i32 10, i64 0, i64 %12)
  %13 = getelementptr i8, ptr %10, i64 0
  %14 = load i8, ptr %13, align 1
  store i8 %14, ptr %s0, align 1
  %15 = load i8, ptr %s0, align 1
  %16 = zext i8 %15 to i64
  %17 = getelementptr [256 x i8], ptr @"runtime::string_decode_rune-.accept_sizes-41963", i64 0, i64 %16
  call void @"runtime::bounds_check_error"(ptr @"ggv$runtime::string_decode_rune$2", i32 631, i32 20, i64 %16, i64 256)
  %18 = load i8, ptr %17, align 1
  store i8 %18, ptr %x, align 1
  %19 = load i8, ptr %x, align 1
  %20 = icmp uge i8 %19, -16
  %21 = zext i1 %20 to i8
  %22 = icmp ne i8 %21, 0
  br i1 %22, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  %23 = load i8, ptr %x, align 1
  %24 = zext i8 %23 to i32
  %25 = shl i32 %24, 31
  %26 = select i1 true, i32 %25, i32 0
  %27 = ashr i32 %26, 31
  %28 = select i1 true, i32 %27, i32 0
  store i32 %28, ptr %mask, align 4
  %29 = getelementptr inbounds nuw %..string, ptr %2, i32 0, i32 0
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr inbounds nuw %..string, ptr %2, i32 0, i32 1
  %32 = load i64, ptr %31, align 8
  call void @"runtime::bounds_check_error"(ptr @"ggv$runtime::string_decode_rune$3", i32 634, i32 17, i64 0, i64 %32)
  %33 = getelementptr i8, ptr %30, i64 0
  %34 = load i8, ptr %33, align 1
  %35 = zext i8 %34 to i32
  %36 = load i32, ptr %mask, align 4
  %37 = xor i32 %36, -1
  %38 = and i32 %35, %37
  %39 = load i32, ptr %mask, align 4
  %40 = and i32 65533, %39
  %41 = or i32 %38, %40
  store i32 %41, ptr %1, align 4
  ret i64 1

if.done2:                                         ; preds = %if.done
  %42 = load i8, ptr %x, align 1
  %43 = and i8 %42, 7
  store i8 %43, ptr %sz, align 1
  %44 = load i8, ptr %x, align 1
  %45 = lshr i8 %44, 4
  %46 = select i1 true, i8 %45, i8 0
  %47 = zext i8 %46 to i64
  %48 = getelementptr [5 x %"runtime::string_decode_rune::Accept_Range::$1"], ptr @"runtime::string_decode_rune-.accept_ranges-42885", i64 0, i64 %47
  call void @"runtime::bounds_check_error"(ptr @"ggv$runtime::string_decode_rune$4", i32 637, i32 26, i64 %47, i64 5)
  %49 = load %"runtime::string_decode_rune::Accept_Range::$1", ptr %48, align 1
  store %"runtime::string_decode_rune::Accept_Range::$1" %49, ptr %accept, align 1
  %50 = load i64, ptr %n, align 8
  %51 = load i8, ptr %sz, align 1
  %52 = zext i8 %51 to i64
  %53 = icmp slt i64 %50, %52
  %54 = zext i1 %53 to i8
  %55 = icmp ne i8 %54, 0
  br i1 %55, label %if.then3, label %if.done4

if.then3:                                         ; preds = %if.done2
  store i32 65533, ptr %1, align 4
  ret i64 1

if.done4:                                         ; preds = %if.done2
  %56 = getelementptr inbounds nuw %..string, ptr %2, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  %58 = getelementptr inbounds nuw %..string, ptr %2, i32 0, i32 1
  %59 = load i64, ptr %58, align 8
  call void @"runtime::bounds_check_error"(ptr @"ggv$runtime::string_decode_rune$5", i32 641, i32 10, i64 1, i64 %59)
  %60 = getelementptr i8, ptr %57, i64 1
  %61 = load i8, ptr %60, align 1
  store i8 %61, ptr %b1, align 1
  %62 = load i8, ptr %b1, align 1
  %63 = getelementptr inbounds nuw %"runtime::string_decode_rune::Accept_Range::$1", ptr %accept, i32 0, i32 0
  %64 = load i8, ptr %63, align 1
  %65 = icmp ult i8 %62, %64
  %66 = zext i1 %65 to i8
  %67 = icmp ne i8 %66, 0
  br i1 %67, label %if.then5, label %cmp.or

cmp.or:                                           ; preds = %if.done4
  %68 = getelementptr inbounds nuw %"runtime::string_decode_rune::Accept_Range::$1", ptr %accept, i32 0, i32 1
  %69 = load i8, ptr %68, align 1
  %70 = load i8, ptr %b1, align 1
  %71 = icmp ult i8 %69, %70
  %72 = zext i1 %71 to i8
  %73 = icmp ne i8 %72, 0
  br i1 %73, label %if.then5, label %if.done6

if.then5:                                         ; preds = %cmp.or, %if.done4
  store i32 65533, ptr %1, align 4
  ret i64 1

if.done6:                                         ; preds = %cmp.or
  %74 = load i8, ptr %sz, align 1
  %75 = icmp eq i8 %74, 2
  %76 = zext i1 %75 to i8
  %77 = icmp ne i8 %76, 0
  br i1 %77, label %if.then7, label %if.done8

if.then7:                                         ; preds = %if.done6
  %78 = load i8, ptr %s0, align 1
  %79 = and i8 %78, 31
  %80 = zext i8 %79 to i32
  %81 = shl i32 %80, 6
  %82 = select i1 true, i32 %81, i32 0
  %83 = load i8, ptr %b1, align 1
  %84 = and i8 %83, 63
  %85 = zext i8 %84 to i32
  %86 = or i32 %82, %85
  store i32 %86, ptr %1, align 4
  ret i64 2

if.done8:                                         ; preds = %if.done6
  %87 = getelementptr inbounds nuw %..string, ptr %2, i32 0, i32 0
  %88 = load ptr, ptr %87, align 8
  %89 = getelementptr inbounds nuw %..string, ptr %2, i32 0, i32 1
  %90 = load i64, ptr %89, align 8
  call void @"runtime::bounds_check_error"(ptr @"ggv$runtime::string_decode_rune$6", i32 648, i32 10, i64 2, i64 %90)
  %91 = getelementptr i8, ptr %88, i64 2
  %92 = load i8, ptr %91, align 1
  store i8 %92, ptr %b2, align 1
  %93 = load i8, ptr %b2, align 1
  %94 = icmp ult i8 %93, -128
  %95 = zext i1 %94 to i8
  %96 = icmp ne i8 %95, 0
  br i1 %96, label %if.then10, label %cmp.or9

cmp.or9:                                          ; preds = %if.done8
  %97 = load i8, ptr %b2, align 1
  %98 = icmp ult i8 -65, %97
  %99 = zext i1 %98 to i8
  %100 = icmp ne i8 %99, 0
  br i1 %100, label %if.then10, label %if.done11

if.then10:                                        ; preds = %cmp.or9, %if.done8
  store i32 65533, ptr %1, align 4
  ret i64 1

if.done11:                                        ; preds = %cmp.or9
  %101 = load i8, ptr %sz, align 1
  %102 = icmp eq i8 %101, 3
  %103 = zext i1 %102 to i8
  %104 = icmp ne i8 %103, 0
  br i1 %104, label %if.then12, label %if.done13

if.then12:                                        ; preds = %if.done11
  %105 = load i8, ptr %s0, align 1
  %106 = and i8 %105, 15
  %107 = zext i8 %106 to i32
  %108 = shl i32 %107, 12
  %109 = select i1 true, i32 %108, i32 0
  %110 = load i8, ptr %b1, align 1
  %111 = and i8 %110, 63
  %112 = zext i8 %111 to i32
  %113 = shl i32 %112, 6
  %114 = select i1 true, i32 %113, i32 0
  %115 = or i32 %109, %114
  %116 = load i8, ptr %b2, align 1
  %117 = and i8 %116, 63
  %118 = zext i8 %117 to i32
  %119 = or i32 %115, %118
  store i32 %119, ptr %1, align 4
  ret i64 3

if.done13:                                        ; preds = %if.done11
  %120 = getelementptr inbounds nuw %..string, ptr %2, i32 0, i32 0
  %121 = load ptr, ptr %120, align 8
  %122 = getelementptr inbounds nuw %..string, ptr %2, i32 0, i32 1
  %123 = load i64, ptr %122, align 8
  call void @"runtime::bounds_check_error"(ptr @"ggv$runtime::string_decode_rune$7", i32 655, i32 10, i64 3, i64 %123)
  %124 = getelementptr i8, ptr %121, i64 3
  %125 = load i8, ptr %124, align 1
  store i8 %125, ptr %b3, align 1
  %126 = load i8, ptr %b3, align 1
  %127 = icmp ult i8 %126, -128
  %128 = zext i1 %127 to i8
  %129 = icmp ne i8 %128, 0
  br i1 %129, label %if.then15, label %cmp.or14

cmp.or14:                                         ; preds = %if.done13
  %130 = load i8, ptr %b3, align 1
  %131 = icmp ult i8 -65, %130
  %132 = zext i1 %131 to i8
  %133 = icmp ne i8 %132, 0
  br i1 %133, label %if.then15, label %if.done16

if.then15:                                        ; preds = %cmp.or14, %if.done13
  store i32 65533, ptr %1, align 4
  ret i64 1

if.done16:                                        ; preds = %cmp.or14
  %134 = load i8, ptr %s0, align 1
  %135 = and i8 %134, 7
  %136 = zext i8 %135 to i32
  %137 = shl i32 %136, 18
  %138 = select i1 true, i32 %137, i32 0
  %139 = load i8, ptr %b1, align 1
  %140 = and i8 %139, 63
  %141 = zext i8 %140 to i32
  %142 = shl i32 %141, 12
  %143 = select i1 true, i32 %142, i32 0
  %144 = or i32 %138, %143
  %145 = load i8, ptr %b2, align 1
  %146 = and i8 %145, 63
  %147 = zext i8 %146 to i32
  %148 = shl i32 %147, 6
  %149 = select i1 true, i32 %148, i32 0
  %150 = or i32 %144, %149
  %151 = load i8, ptr %b3, align 1
  %152 = and i8 %151, 63
  %153 = zext i8 %152 to i32
  %154 = or i32 %150, %153
  store i32 %154, ptr %1, align 4
  ret i64 4
}

; Function Attrs: alwaysinline
define i8 @"runtime::_append_elems"(ptr %0, i64 %1, i64 %2, i1 zeroext %3, ptr %4, ptr %5, i64 %6, ptr noalias nonnull %7, ptr noalias nocapture nonnull %__.context_ptr) #1 {
decls:
  %8 = alloca ptr, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca i8, align 1
  %old_size.i = alloca i64, align 8
  %new_size.i = alloca i64, align 8
  %allocator.i = alloca %"runtime::Allocator", align 8
  %new_data.i = alloca { ptr, i64 }, align 8
  %13 = alloca { ptr, i64 }, align 8
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca ptr, align 8
  %16 = alloca i64, align 8
  %17 = alloca i64, align 8
  %18 = alloca i8, align 1
  %19 = alloca ptr, align 8
  %20 = alloca i64, align 8
  %n = alloca i64, align 8
  %err = alloca i8, align 1
  %cap = alloca i64, align 8
  %arg_len = alloca i64, align 8
  %data = alloca ptr, align 8
  %21 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %15, align 8
  store i64 %1, ptr %16, align 8
  store i64 %2, ptr %17, align 8
  %22 = zext i1 %3 to i8
  store i8 %22, ptr %18, align 1
  store ptr %5, ptr %19, align 8
  store i64 %6, ptr %20, align 8
  store i64 0, ptr %n, align 8
  store i8 0, ptr %err, align 1
  %23 = icmp eq ptr %0, null
  %24 = zext i1 %23 to i8
  %25 = icmp ne i8 %24, 0
  br i1 %25, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store i64 0, ptr %n, align 8
  store i8 0, ptr %err, align 1
  store i64 0, ptr %7, align 8
  ret i8 0

if.done:                                          ; preds = %entry
  %26 = icmp sle i64 %6, 0
  %27 = zext i1 %26 to i8
  %28 = icmp ne i8 %27, 0
  br i1 %28, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  store i64 0, ptr %n, align 8
  store i8 0, ptr %err, align 1
  store i64 0, ptr %7, align 8
  ret i8 0

if.done2:                                         ; preds = %if.done
  %29 = load ptr, ptr %15, align 8
  %30 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %29, i32 0, i32 2
  %31 = load i64, ptr %30, align 8
  %32 = load ptr, ptr %15, align 8
  %33 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %32, i32 0, i32 1
  %34 = load i64, ptr %33, align 8
  %35 = add i64 %34, %6
  %36 = icmp slt i64 %31, %35
  %37 = zext i1 %36 to i8
  %38 = icmp ne i8 %37, 0
  br i1 %38, label %if.then3, label %if.done4

if.then3:                                         ; preds = %if.done2
  %39 = load ptr, ptr %15, align 8
  %40 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %39, i32 0, i32 2
  %41 = load i64, ptr %40, align 8
  %42 = mul i64 2, %41
  %43 = icmp sgt i64 8, %6
  %44 = select i1 %43, i64 8, i64 %6
  %45 = add i64 %42, %44
  store i64 %45, ptr %cap, align 8
  %46 = load i64, ptr %cap, align 8
  %47 = icmp ne i8 %22, 0
  call void @llvm.experimental.noalias.scope.decl(metadata !192)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 1, ptr %12)
  call void @llvm.lifetime.start.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %13)
  call void @llvm.lifetime.start.p0(i64 16, ptr %14)
  store ptr %0, ptr %8, align 8, !noalias !192
  store i64 %1, ptr %9, align 8, !noalias !192
  store i64 %2, ptr %10, align 8, !noalias !192
  store i64 %46, ptr %11, align 8, !noalias !192
  %48 = zext i1 %47 to i8
  store i8 %48, ptr %12, align 1, !noalias !192
  %49 = icmp eq ptr %0, null
  %50 = zext i1 %49 to i8
  br i1 %49, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %if.then3
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 1, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done.i:                                        ; preds = %if.then3
  %51 = load ptr, ptr %8, align 8, !noalias !192
  %52 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %51, i32 0, i32 2
  %53 = load i64, ptr %52, align 8, !noalias !192
  %54 = icmp sle i64 %46, %53
  %55 = zext i1 %54 to i8
  br i1 %54, label %if.then1.i, label %if.done2.i

if.then1.i:                                       ; preds = %if.done.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 1, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done2.i:                                       ; preds = %if.done.i
  %56 = load ptr, ptr %8, align 8, !noalias !192
  %57 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %56, i32 0, i32 3
  %58 = load ptr, ptr %57, align 8, !noalias !192
  %59 = icmp eq ptr %58, null
  %60 = zext i1 %59 to i8
  br i1 %59, label %if.then3.i, label %if.done4.i

if.then3.i:                                       ; preds = %if.done2.i
  %61 = load ptr, ptr %8, align 8, !noalias !192
  %62 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %61, i32 0, i32 3
  %63 = load %"runtime::Allocator", ptr %__.context_ptr, align 8, !alias.scope !192
  store %"runtime::Allocator" %63, ptr %62, align 8, !noalias !192
  br label %if.done4.i

if.done4.i:                                       ; preds = %if.then3.i, %if.done2.i
  %64 = load ptr, ptr %8, align 8, !noalias !192
  %65 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %64, i32 0, i32 3
  %66 = load ptr, ptr %65, align 8, !noalias !192
  %67 = icmp ne ptr %66, null
  %68 = zext i1 %67 to i8
  call void @"runtime::assert"(i1 zeroext %67, ptr @"ggv$runtime::_reserve_dynamic_array$1", ptr @"scl$[_reserve_dynamic_array28302]", ptr nonnull %__.context_ptr)
  %69 = load ptr, ptr %8, align 8, !noalias !192
  %70 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %69, i32 0, i32 2
  %71 = load i64, ptr %70, align 8, !noalias !192
  %72 = mul i64 %71, %1
  store i64 %72, ptr %old_size.i, align 8, !noalias !192
  %73 = mul i64 %46, %1
  store i64 %73, ptr %new_size.i, align 8, !noalias !192
  %74 = load ptr, ptr %8, align 8, !noalias !192
  %75 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %74, i32 0, i32 3
  %76 = load %"runtime::Allocator", ptr %75, align 8, !noalias !192
  store %"runtime::Allocator" %76, ptr %allocator.i, align 8, !noalias !192
  call void @llvm.memset.inline.p0.i64(ptr %new_data.i, i8 0, i64 16, i1 false), !noalias !192
  br i1 %47, label %if.then5.i, label %if.else.i

if.then5.i:                                       ; preds = %if.done4.i
  %77 = load ptr, ptr %8, align 8, !noalias !192
  %78 = load ptr, ptr %77, align 8, !noalias !192
  %79 = load i64, ptr %old_size.i, align 8, !noalias !192
  %80 = load i64, ptr %new_size.i, align 8, !noalias !192
  call void @llvm.memset.inline.p0.i64(ptr %13, i8 0, i64 16, i1 false), !noalias !192
  %81 = call i8 @"runtime::mem_resize"(ptr %78, i64 %79, i64 %80, i64 %2, ptr %allocator.i, ptr %4, ptr %13, ptr nonnull %__.context_ptr)
  %82 = load { ptr, i64 }, ptr %13, align 8, !noalias !192
  %83 = icmp eq i8 %81, 0
  br i1 %83, label %or_return.continue.i, label %or_return.return.i

or_return.return.i:                               ; preds = %if.then5.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 1, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  br label %"runtime::_reserve_dynamic_array.exit"

or_return.continue.i:                             ; preds = %if.then5.i
  store { ptr, i64 } %82, ptr %new_data.i, align 8, !noalias !192
  br label %if.done8.i

if.else.i:                                        ; preds = %if.done4.i
  %84 = load ptr, ptr %8, align 8, !noalias !192
  %85 = load ptr, ptr %84, align 8, !noalias !192
  %86 = load i64, ptr %old_size.i, align 8, !noalias !192
  %87 = load i64, ptr %new_size.i, align 8, !noalias !192
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false), !noalias !192
  %88 = call i8 @"runtime::non_zero_mem_resize"(ptr %85, i64 %86, i64 %87, i64 %2, ptr %allocator.i, ptr %4, ptr %14, ptr nonnull %__.context_ptr)
  %89 = load { ptr, i64 }, ptr %14, align 8, !noalias !192
  %90 = icmp eq i8 %88, 0
  br i1 %90, label %or_return.continue7.i, label %or_return.return6.i

or_return.return6.i:                              ; preds = %if.else.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 1, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  br label %"runtime::_reserve_dynamic_array.exit"

or_return.continue7.i:                            ; preds = %if.else.i
  store { ptr, i64 } %89, ptr %new_data.i, align 8, !noalias !192
  br label %if.done8.i

if.done8.i:                                       ; preds = %or_return.continue7.i, %or_return.continue.i
  %91 = load ptr, ptr %new_data.i, align 8, !noalias !192
  %92 = icmp eq ptr %91, null
  %93 = zext i1 %92 to i8
  br i1 %92, label %cmp.and.i, label %if.done10.i

cmp.and.i:                                        ; preds = %if.done8.i
  %94 = load i64, ptr %new_size.i, align 8, !noalias !192
  %95 = icmp sgt i64 %94, 0
  %96 = zext i1 %95 to i8
  br i1 %95, label %if.then9.i, label %if.done10.i

if.then9.i:                                       ; preds = %cmp.and.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 1, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done10.i:                                      ; preds = %cmp.and.i, %if.done8.i
  %97 = load ptr, ptr %8, align 8, !noalias !192
  %98 = load ptr, ptr %new_data.i, align 8, !noalias !192
  store ptr %98, ptr %97, align 8, !noalias !192
  %99 = load ptr, ptr %8, align 8, !noalias !192
  %100 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %99, i32 0, i32 2
  store i64 %46, ptr %100, align 8, !noalias !192
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 1, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %13)
  call void @llvm.lifetime.end.p0(i64 16, ptr %14)
  br label %"runtime::_reserve_dynamic_array.exit"

"runtime::_reserve_dynamic_array.exit":           ; preds = %if.done10.i, %if.then9.i, %or_return.return6.i, %or_return.return.i, %if.then1.i, %if.then.i
  %101 = phi i8 [ 0, %if.then.i ], [ 0, %if.then1.i ], [ %81, %or_return.return.i ], [ %88, %or_return.return6.i ], [ 1, %if.then9.i ], [ 0, %if.done10.i ]
  store i8 %101, ptr %err, align 1
  br label %if.done4

if.done4:                                         ; preds = %"runtime::_reserve_dynamic_array.exit", %if.done2
  store i64 %6, ptr %arg_len, align 8
  %102 = load i64, ptr %arg_len, align 8
  %103 = load ptr, ptr %15, align 8
  %104 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %103, i32 0, i32 2
  %105 = load i64, ptr %104, align 8
  %106 = load ptr, ptr %15, align 8
  %107 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %106, i32 0, i32 1
  %108 = load i64, ptr %107, align 8
  %109 = sub i64 %105, %108
  %110 = icmp slt i64 %109, %102
  %111 = select i1 %110, i64 %109, i64 %102
  store i64 %111, ptr %arg_len, align 8
  %112 = load i64, ptr %arg_len, align 8
  %113 = icmp sgt i64 %112, 0
  %114 = zext i1 %113 to i8
  %115 = icmp ne i8 %114, 0
  br i1 %115, label %if.then5, label %if.done6

if.then5:                                         ; preds = %if.done4
  %116 = load ptr, ptr %15, align 8
  %117 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %116, i32 0, i32 0
  %118 = load ptr, ptr %117, align 8
  store ptr %118, ptr %data, align 8
  %119 = load ptr, ptr %data, align 8
  %120 = icmp ne ptr %119, null
  %121 = zext i1 %120 to i8
  %122 = icmp ne i8 %121, 0
  call void @"runtime::assert"(i1 zeroext %122, ptr @"ggv$runtime::_append_elems$1", ptr %4, ptr %__.context_ptr)
  %123 = load ptr, ptr %data, align 8
  %124 = load ptr, ptr %15, align 8
  %125 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %124, i32 0, i32 1
  %126 = load i64, ptr %125, align 8
  %127 = mul i64 %126, %1
  %128 = getelementptr i8, ptr %123, i64 %127
  store ptr %128, ptr %21, align 8
  %129 = load ptr, ptr %21, align 8
  store ptr %129, ptr %data, align 8
  %130 = load ptr, ptr %data, align 8
  %131 = load i64, ptr %arg_len, align 8
  %132 = mul i64 %1, %131
  call void @llvm.memmove.p0.p0.i64(ptr %130, ptr %5, i64 %132, i1 false)
  %133 = load ptr, ptr %15, align 8
  %134 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %133, i32 0, i32 1
  %135 = load i64, ptr %arg_len, align 8
  %136 = load i64, ptr %134, align 8
  %137 = add i64 %136, %135
  store i64 %137, ptr %134, align 8
  br label %if.done6

if.done6:                                         ; preds = %if.then5, %if.done4
  %138 = load i64, ptr %arg_len, align 8
  %139 = load i8, ptr %err, align 1
  store i64 %138, ptr %n, align 8
  store i8 %139, ptr %err, align 1
  store i64 %138, ptr %7, align 8
  ret i8 %139
}

; Function Attrs: alwaysinline
define i64 @"runtime::map_insert_hash_dynamic"(ptr noalias %0, ptr noalias %1, i64 %2, i64 %3, i64 %4, ptr noalias nocapture nonnull %__.context_ptr) #1 {
decls:
  %5 = alloca ptr, align 8
  %6 = alloca ptr, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %result = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %5, align 8
  store ptr %1, ptr %6, align 8
  store i64 %2, ptr %7, align 8
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  store i64 0, ptr %result, align 8
  store i64 0, ptr %10, align 8
  %12 = call i64 @"runtime::map_insert_hash_dynamic_with_key"(ptr %0, ptr %1, i64 %2, i64 %3, i64 %4, ptr %10, ptr %__.context_ptr)
  store i64 %12, ptr %result, align 8
  %13 = load i64, ptr %result, align 8
  store i64 %13, ptr %result, align 8
  ret i64 %13
}

define i8 @"runtime::map_grow_dynamic"(ptr noalias %0, ptr noalias %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca ptr, align 8
  %log2_capacity = alloca i64, align 8
  %new_capacity = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store ptr %1, ptr %4, align 8
  %5 = load i64, ptr %0, align 8
  %6 = and i64 %5, 63
  store i64 %6, ptr %log2_capacity, align 8
  %7 = load i64, ptr %log2_capacity, align 8
  %8 = add i64 %7, 1
  %9 = icmp ugt i64 %8, 3
  %10 = select i1 %9, i64 %8, i64 3
  %11 = icmp ult i64 %10, 64
  %12 = shl i64 1, %10
  %13 = select i1 %11, i64 %12, i64 0
  store i64 %13, ptr %new_capacity, align 8
  %14 = load i64, ptr %new_capacity, align 8
  %15 = call i8 @"runtime::map_reserve_dynamic"(ptr %0, ptr %1, i64 %14, ptr %2, ptr %__.context_ptr)
  ret i8 %15
}

; Function Attrs: noinline
define i8 @"runtime::map_reserve_dynamic"(ptr noalias %0, ptr noalias %1, i64 %2, ptr %3, ptr noalias nocapture nonnull %__.context_ptr) #2 {
decls:
  %4 = alloca i64, align 8
  %z.i = alloca i64, align 8
  %5 = alloca ptr, align 8
  %6 = alloca ptr, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %result.i = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %mix.i = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca ptr, align 8
  %15 = alloca i64, align 8
  %elements_per_cell.i18 = alloca i64, align 8
  %size_of_cell.i19 = alloca i64, align 8
  %cell_index.i20 = alloca i64, align 8
  %data_index.i21 = alloca i64, align 8
  %size_of_type.i22 = alloca i64, align 8
  %cell_index2.i23 = alloca i64, align 8
  %data_index3.i24 = alloca i64, align 8
  %size_of_type4.i25 = alloca i64, align 8
  %16 = alloca i64, align 8
  %17 = alloca ptr, align 8
  %18 = alloca i64, align 8
  %elements_per_cell.i = alloca i64, align 8
  %size_of_cell.i = alloca i64, align 8
  %cell_index.i = alloca i64, align 8
  %data_index.i = alloca i64, align 8
  %size_of_type.i = alloca i64, align 8
  %cell_index2.i = alloca i64, align 8
  %data_index3.i = alloca i64, align 8
  %size_of_type4.i = alloca i64, align 8
  %19 = alloca ptr, align 8
  %20 = alloca ptr, align 8
  %21 = alloca i64, align 8
  %new_capacity = alloca i64, align 8
  %old_capacity = alloca i64, align 8
  %log2_new_capacity = alloca i64, align 8
  %log2_min_cap = alloca i64, align 8
  %22 = alloca %"runtime::Raw_Map", align 8
  %23 = alloca { %"runtime::Raw_Map", i8 }, align 8
  %24 = alloca %"runtime::Raw_Map", align 8
  %25 = alloca { %"runtime::Raw_Map", i8 }, align 8
  %resized = alloca %"runtime::Raw_Map", align 8
  %26 = alloca i64, align 8
  %27 = alloca i64, align 8
  %28 = alloca ptr, align 8
  %29 = alloca i64, align 8
  %30 = alloca { i64, i64, ptr, i64, i64 }, align 8
  %ks = alloca i64, align 8
  %vs = alloca i64, align 8
  %hs = alloca ptr, align 8
  %n = alloca i64, align 8
  %i = alloca i64, align 8
  %31 = alloca i64, align 8
  %i7 = alloca i64, align 8
  %hash = alloca i64, align 8
  %k = alloca i64, align 8
  %v = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %19, align 8
  store ptr %1, ptr %20, align 8
  store i64 %2, ptr %21, align 8
  %32 = load ptr, ptr %19, align 8
  %33 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %32, i32 0, i32 2
  %34 = getelementptr inbounds nuw %"runtime::Allocator", ptr %33, i32 0, i32 0
  %35 = load ptr, ptr %34, align 8
  %36 = icmp eq ptr %35, null
  %37 = zext i1 %36 to i8
  %38 = icmp ne i8 %37, 0
  br i1 %38, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %39 = load ptr, ptr %19, align 8
  %40 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %39, i32 0, i32 2
  %41 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %42 = load %"runtime::Allocator", ptr %41, align 8
  store %"runtime::Allocator" %42, ptr %40, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  store i64 %2, ptr %new_capacity, align 8
  %43 = load i64, ptr %0, align 8
  %44 = icmp eq i64 %43, 0
  %45 = zext i1 %44 to i8
  br i1 %44, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.done
  br label %"runtime::map_cap.exit"

if.else.i:                                        ; preds = %if.done
  %46 = load i64, ptr %0, align 8
  %47 = and i64 %46, 63
  %48 = icmp ult i64 %47, 64
  %49 = shl i64 1, %47
  %50 = select i1 %48, i64 %49, i64 0
  br label %"runtime::map_cap.exit"

"runtime::map_cap.exit":                          ; preds = %if.then.i, %if.else.i
  %51 = phi i64 [ 0, %if.then.i ], [ %50, %if.else.i ]
  store i64 %51, ptr %old_capacity, align 8
  %52 = load i64, ptr %old_capacity, align 8
  %53 = load i64, ptr %new_capacity, align 8
  %54 = icmp uge i64 %52, %53
  %55 = zext i1 %54 to i8
  %56 = icmp ne i8 %55, 0
  br i1 %56, label %if.then1, label %if.done2

if.then1:                                         ; preds = %"runtime::map_cap.exit"
  ret i8 0

if.done2:                                         ; preds = %"runtime::map_cap.exit"
  %57 = load i64, ptr %new_capacity, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %z.i)
  store i64 %57, ptr %4, align 8
  %58 = call i64 @llvm.ctlz.i64(i64 %57, i1 false)
  store i64 %58, ptr %z.i, align 8
  %59 = load i64, ptr %z.i, align 8
  %60 = icmp ugt i64 %59, 0
  %61 = zext i1 %60 to i8
  br i1 %60, label %cmp.and.i, label %"runtime::map_reserve_dynamic.ceil_log2-0.exit"

cmp.and.i:                                        ; preds = %if.done2
  %62 = sub i64 %57, 1
  %63 = and i64 %57, %62
  %64 = icmp ne i64 %63, 0
  %65 = zext i1 %64 to i8
  br i1 %64, label %if.then.i30, label %"runtime::map_reserve_dynamic.ceil_log2-0.exit"

if.then.i30:                                      ; preds = %cmp.and.i
  %66 = load i64, ptr %z.i, align 8
  %67 = sub i64 %66, 1
  store i64 %67, ptr %z.i, align 8
  br label %"runtime::map_reserve_dynamic.ceil_log2-0.exit"

"runtime::map_reserve_dynamic.ceil_log2-0.exit":  ; preds = %if.done2, %cmp.and.i, %if.then.i30
  %68 = load i64, ptr %z.i, align 8
  %69 = sub i64 63, %68
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %z.i)
  store i64 %69, ptr %log2_new_capacity, align 8
  %70 = load i64, ptr %log2_new_capacity, align 8
  %71 = icmp ugt i64 3, %70
  %72 = select i1 %71, i64 3, i64 %70
  store i64 %72, ptr %log2_min_cap, align 8
  %73 = load ptr, ptr %19, align 8
  %74 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %73, i32 0, i32 0
  %75 = load i64, ptr %74, align 8
  %76 = icmp eq i64 %75, 0
  %77 = zext i1 %76 to i8
  %78 = icmp ne i8 %77, 0
  br i1 %78, label %if.then3, label %if.done4

if.then3:                                         ; preds = %"runtime::map_reserve_dynamic.ceil_log2-0.exit"
  %79 = load i64, ptr %log2_min_cap, align 8
  %80 = load ptr, ptr %19, align 8
  %81 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %80, i32 0, i32 2
  call void @llvm.memset.inline.p0.i64(ptr %22, i8 0, i64 32, i1 false)
  %82 = call i8 @"runtime::map_alloc_dynamic"(ptr %1, i64 %79, ptr %81, ptr %3, ptr %22, ptr %__.context_ptr)
  %83 = load %"runtime::Raw_Map", ptr %22, align 8
  %84 = icmp eq i8 %82, 0
  br i1 %84, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %if.then3
  ret i8 %82

or_return.continue:                               ; preds = %if.then3
  store %"runtime::Raw_Map" %83, ptr %0, align 8
  ret i8 0

if.done4:                                         ; preds = %"runtime::map_reserve_dynamic.ceil_log2-0.exit"
  %85 = load i64, ptr %log2_min_cap, align 8
  %86 = load ptr, ptr %19, align 8
  %87 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %86, i32 0, i32 2
  call void @llvm.memset.inline.p0.i64(ptr %24, i8 0, i64 32, i1 false)
  %88 = call i8 @"runtime::map_alloc_dynamic"(ptr %1, i64 %85, ptr %87, ptr %3, ptr %24, ptr %__.context_ptr)
  %89 = load %"runtime::Raw_Map", ptr %24, align 8
  %90 = icmp eq i8 %88, 0
  br i1 %90, label %or_return.continue6, label %or_return.return5

or_return.return5:                                ; preds = %if.done4
  ret i8 %88

or_return.continue6:                              ; preds = %if.done4
  store %"runtime::Raw_Map" %89, ptr %resized, align 8
  store i64 0, ptr %26, align 8
  store i64 0, ptr %27, align 8
  store ptr null, ptr %28, align 8
  store i64 0, ptr %29, align 8
  %91 = call i64 @"runtime::map_kvh_data_dynamic"(ptr %0, ptr %1, ptr %26, ptr %27, ptr %28, ptr %29)
  %92 = load i64, ptr %26, align 8
  %93 = load i64, ptr %27, align 8
  %94 = load ptr, ptr %28, align 8
  store i64 %92, ptr %ks, align 8
  store i64 %93, ptr %vs, align 8
  store ptr %94, ptr %hs, align 8
  %95 = load ptr, ptr %19, align 8
  %96 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %95, i32 0, i32 1
  %97 = load i64, ptr %96, align 8
  store i64 %97, ptr %n, align 8
  store i64 0, ptr %i, align 8
  store i64 0, ptr %31, align 8
  br label %for.interval.loop

for.interval.loop:                                ; preds = %for.interval.post, %or_return.continue6
  %98 = load i64, ptr %old_capacity, align 8
  %99 = load i64, ptr %i, align 8
  %100 = icmp ult i64 %99, %98
  br i1 %100, label %for.interval.body, label %for.interval.done

for.interval.body:                                ; preds = %for.interval.loop
  %101 = load i64, ptr %i, align 8
  store i64 %101, ptr %i7, align 8
  %102 = load ptr, ptr %hs, align 8
  %103 = load i64, ptr %i7, align 8
  %104 = getelementptr i64, ptr %102, i64 %103
  %105 = load i64, ptr %104, align 8
  store i64 %105, ptr %hash, align 8
  %106 = load i64, ptr %hash, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %12)
  store i64 %106, ptr %12, align 8
  %107 = icmp eq i64 %106, 0
  %108 = zext i1 %107 to i8
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  %109 = icmp ne i8 %108, 0
  br i1 %109, label %if.then8, label %if.done9

if.then8:                                         ; preds = %for.interval.body
  br label %for.interval.post

unreachable:                                      ; No predecessors!
  br label %if.done9

if.done9:                                         ; preds = %unreachable, %for.interval.body
  %110 = load i64, ptr %hash, align 8
  %111 = call i8 @"runtime::map_hash_is_deleted"(i64 %110)
  %112 = icmp ne i8 %111, 0
  br i1 %112, label %if.then10, label %if.done12

if.then10:                                        ; preds = %if.done9
  br label %for.interval.post

unreachable11:                                    ; No predecessors!
  br label %if.done12

if.done12:                                        ; preds = %unreachable11, %if.done9
  %113 = load i64, ptr %ks, align 8
  %114 = load ptr, ptr %20, align 8
  %115 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %114, i32 0, i32 0
  %116 = load ptr, ptr %115, align 8
  %117 = load i64, ptr %i7, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !195)
  call void @llvm.lifetime.start.p0(i64 8, ptr %13)
  call void @llvm.lifetime.start.p0(i64 8, ptr %14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i18)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i19)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i20)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i21)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i22)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i23)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i24)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i25)
  store i64 %113, ptr %13, align 8, !noalias !195
  store ptr %116, ptr %14, align 8, !noalias !195
  store i64 %117, ptr %15, align 8, !noalias !195
  %118 = load ptr, ptr %14, align 8, !noalias !195
  %119 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %118, i32 0, i32 3
  %120 = load i64, ptr %119, align 8
  store i64 %120, ptr %elements_per_cell.i18, align 8, !noalias !195
  %121 = load ptr, ptr %14, align 8, !noalias !195
  %122 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %121, i32 0, i32 2
  %123 = load i64, ptr %122, align 8
  store i64 %123, ptr %size_of_cell.i19, align 8, !noalias !195
  %124 = load i64, ptr %elements_per_cell.i18, align 8, !noalias !195
  switch i64 %124, label %switch.default.body.i28 [
    i64 1, label %switch.case.body.i27
    i64 2, label %switch.case.body1.i26
  ]

switch.case.body.i27:                             ; preds = %if.done12
  %125 = load i64, ptr %size_of_cell.i19, align 8, !noalias !195
  %126 = mul i64 %117, %125
  %127 = add i64 %113, %126
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i22)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i23)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i24)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i25)
  br label %"runtime::map_cell_index_dynamic.exit29"

switch.case.body1.i26:                            ; preds = %if.done12
  %128 = lshr i64 %117, 1
  store i64 %128, ptr %cell_index.i20, align 8, !noalias !195
  %129 = and i64 %117, 1
  store i64 %129, ptr %data_index.i21, align 8, !noalias !195
  %130 = load ptr, ptr %14, align 8, !noalias !195
  %131 = load i64, ptr %130, align 8
  store i64 %131, ptr %size_of_type.i22, align 8, !noalias !195
  %132 = load i64, ptr %cell_index.i20, align 8, !noalias !195
  %133 = load i64, ptr %size_of_cell.i19, align 8, !noalias !195
  %134 = mul i64 %132, %133
  %135 = add i64 %113, %134
  %136 = load i64, ptr %data_index.i21, align 8, !noalias !195
  %137 = load i64, ptr %size_of_type.i22, align 8, !noalias !195
  %138 = mul i64 %136, %137
  %139 = add i64 %135, %138
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i22)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i23)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i24)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i25)
  br label %"runtime::map_cell_index_dynamic.exit29"

switch.default.body.i28:                          ; preds = %if.done12
  %140 = load i64, ptr %elements_per_cell.i18, align 8, !noalias !195
  %141 = udiv i64 %117, %140
  store i64 %141, ptr %cell_index2.i23, align 8, !noalias !195
  %142 = load i64, ptr %elements_per_cell.i18, align 8, !noalias !195
  %143 = urem i64 %117, %142
  store i64 %143, ptr %data_index3.i24, align 8, !noalias !195
  %144 = load ptr, ptr %14, align 8, !noalias !195
  %145 = load i64, ptr %144, align 8
  store i64 %145, ptr %size_of_type4.i25, align 8, !noalias !195
  %146 = load i64, ptr %cell_index2.i23, align 8, !noalias !195
  %147 = load i64, ptr %size_of_cell.i19, align 8, !noalias !195
  %148 = mul i64 %146, %147
  %149 = add i64 %113, %148
  %150 = load i64, ptr %data_index3.i24, align 8, !noalias !195
  %151 = load i64, ptr %size_of_type4.i25, align 8, !noalias !195
  %152 = mul i64 %150, %151
  %153 = add i64 %149, %152
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i22)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i23)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i24)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i25)
  br label %"runtime::map_cell_index_dynamic.exit29"

"runtime::map_cell_index_dynamic.exit29":         ; preds = %switch.default.body.i28, %switch.case.body1.i26, %switch.case.body.i27
  %154 = phi i64 [ %127, %switch.case.body.i27 ], [ %139, %switch.case.body1.i26 ], [ %153, %switch.default.body.i28 ]
  store i64 %154, ptr %k, align 8
  %155 = load i64, ptr %vs, align 8
  %156 = load ptr, ptr %20, align 8
  %157 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %156, i32 0, i32 1
  %158 = load ptr, ptr %157, align 8
  %159 = load i64, ptr %i7, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !198)
  call void @llvm.lifetime.start.p0(i64 8, ptr %16)
  call void @llvm.lifetime.start.p0(i64 8, ptr %17)
  call void @llvm.lifetime.start.p0(i64 8, ptr %18)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i)
  store i64 %155, ptr %16, align 8, !noalias !198
  store ptr %158, ptr %17, align 8, !noalias !198
  store i64 %159, ptr %18, align 8, !noalias !198
  %160 = load ptr, ptr %17, align 8, !noalias !198
  %161 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %160, i32 0, i32 3
  %162 = load i64, ptr %161, align 8
  store i64 %162, ptr %elements_per_cell.i, align 8, !noalias !198
  %163 = load ptr, ptr %17, align 8, !noalias !198
  %164 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %163, i32 0, i32 2
  %165 = load i64, ptr %164, align 8
  store i64 %165, ptr %size_of_cell.i, align 8, !noalias !198
  %166 = load i64, ptr %elements_per_cell.i, align 8, !noalias !198
  switch i64 %166, label %switch.default.body.i [
    i64 1, label %switch.case.body.i
    i64 2, label %switch.case.body1.i
  ]

switch.case.body.i:                               ; preds = %"runtime::map_cell_index_dynamic.exit29"
  %167 = load i64, ptr %size_of_cell.i, align 8, !noalias !198
  %168 = mul i64 %159, %167
  %169 = add i64 %155, %168
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i)
  br label %"runtime::map_cell_index_dynamic.exit"

switch.case.body1.i:                              ; preds = %"runtime::map_cell_index_dynamic.exit29"
  %170 = lshr i64 %159, 1
  store i64 %170, ptr %cell_index.i, align 8, !noalias !198
  %171 = and i64 %159, 1
  store i64 %171, ptr %data_index.i, align 8, !noalias !198
  %172 = load ptr, ptr %17, align 8, !noalias !198
  %173 = load i64, ptr %172, align 8
  store i64 %173, ptr %size_of_type.i, align 8, !noalias !198
  %174 = load i64, ptr %cell_index.i, align 8, !noalias !198
  %175 = load i64, ptr %size_of_cell.i, align 8, !noalias !198
  %176 = mul i64 %174, %175
  %177 = add i64 %155, %176
  %178 = load i64, ptr %data_index.i, align 8, !noalias !198
  %179 = load i64, ptr %size_of_type.i, align 8, !noalias !198
  %180 = mul i64 %178, %179
  %181 = add i64 %177, %180
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i)
  br label %"runtime::map_cell_index_dynamic.exit"

switch.default.body.i:                            ; preds = %"runtime::map_cell_index_dynamic.exit29"
  %182 = load i64, ptr %elements_per_cell.i, align 8, !noalias !198
  %183 = udiv i64 %159, %182
  store i64 %183, ptr %cell_index2.i, align 8, !noalias !198
  %184 = load i64, ptr %elements_per_cell.i, align 8, !noalias !198
  %185 = urem i64 %159, %184
  store i64 %185, ptr %data_index3.i, align 8, !noalias !198
  %186 = load ptr, ptr %17, align 8, !noalias !198
  %187 = load i64, ptr %186, align 8
  store i64 %187, ptr %size_of_type4.i, align 8, !noalias !198
  %188 = load i64, ptr %cell_index2.i, align 8, !noalias !198
  %189 = load i64, ptr %size_of_cell.i, align 8, !noalias !198
  %190 = mul i64 %188, %189
  %191 = add i64 %155, %190
  %192 = load i64, ptr %data_index3.i, align 8, !noalias !198
  %193 = load i64, ptr %size_of_type4.i, align 8, !noalias !198
  %194 = mul i64 %192, %193
  %195 = add i64 %191, %194
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i)
  br label %"runtime::map_cell_index_dynamic.exit"

"runtime::map_cell_index_dynamic.exit":           ; preds = %switch.default.body.i, %switch.case.body1.i, %switch.case.body.i
  %196 = phi i64 [ %169, %switch.case.body.i ], [ %181, %switch.case.body1.i ], [ %195, %switch.default.body.i ]
  store i64 %196, ptr %v, align 8
  %197 = load ptr, ptr %20, align 8
  %198 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %197, i32 0, i32 2
  %199 = load ptr, ptr %198, align 8
  %200 = load i64, ptr %k, align 8
  %201 = inttoptr i64 %200 to ptr
  %202 = load i64, ptr %resized, align 8
  %203 = and i64 %202, -64
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %mix.i)
  store i64 %203, ptr %11, align 8
  %204 = add i64 %203, -7046029254386353131
  store i64 %204, ptr %mix.i, align 8
  %205 = load i64, ptr %mix.i, align 8
  %206 = load i64, ptr %mix.i, align 8
  %207 = lshr i64 %206, 30
  %208 = xor i64 %205, %207
  %209 = mul i64 %208, -4658895280553007687
  store i64 %209, ptr %mix.i, align 8
  %210 = load i64, ptr %mix.i, align 8
  %211 = load i64, ptr %mix.i, align 8
  %212 = lshr i64 %211, 27
  %213 = xor i64 %210, %212
  %214 = mul i64 %213, -7723592293110705685
  store i64 %214, ptr %mix.i, align 8
  %215 = load i64, ptr %mix.i, align 8
  %216 = load i64, ptr %mix.i, align 8
  %217 = lshr i64 %216, 31
  %218 = xor i64 %215, %217
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %mix.i)
  %219 = call i64 %199(ptr %201, i64 %218)
  store i64 %219, ptr %hash, align 8
  %220 = load i64, ptr %hash, align 8
  %221 = load i64, ptr %k, align 8
  %222 = load i64, ptr %v, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !201)
  call void @llvm.experimental.noalias.scope.decl(metadata !204)
  call void @llvm.experimental.noalias.scope.decl(metadata !206)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr %result.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  store ptr %resized, ptr %5, align 8, !noalias !208
  store ptr %1, ptr %6, align 8, !noalias !208
  store i64 %220, ptr %7, align 8, !noalias !208
  store i64 %221, ptr %8, align 8, !noalias !208
  store i64 %222, ptr %9, align 8, !noalias !208
  store i64 0, ptr %result.i, align 8, !noalias !208
  store i64 0, ptr %10, align 8, !noalias !208
  %223 = call i64 @"runtime::map_insert_hash_dynamic_with_key"(ptr %resized, ptr %1, i64 %220, i64 %221, i64 %222, ptr %10, ptr nonnull %__.context_ptr)
  store i64 %223, ptr %result.i, align 8, !noalias !208
  %224 = load i64, ptr %result.i, align 8, !noalias !208
  store i64 %224, ptr %result.i, align 8, !noalias !208
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %result.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  %225 = load i64, ptr %n, align 8
  %226 = sub i64 %225, 1
  store i64 %226, ptr %n, align 8
  %227 = load i64, ptr %n, align 8
  %228 = icmp eq i64 %227, 0
  %229 = zext i1 %228 to i8
  %230 = icmp ne i8 %229, 0
  br i1 %230, label %if.then13, label %if.done15

if.then13:                                        ; preds = %"runtime::map_cell_index_dynamic.exit"
  br label %for.interval.done

unreachable14:                                    ; No predecessors!
  br label %if.done15

if.done15:                                        ; preds = %unreachable14, %"runtime::map_cell_index_dynamic.exit"
  br label %for.interval.post

for.interval.post:                                ; preds = %if.done15, %if.then10, %if.then8
  %231 = load i64, ptr %i, align 8
  %232 = add i64 %231, 1
  store i64 %232, ptr %i, align 8
  %233 = load i64, ptr %31, align 8
  %234 = add i64 %233, 1
  store i64 %234, ptr %31, align 8
  br label %for.interval.loop

for.interval.done:                                ; preds = %if.then13, %for.interval.loop
  %235 = call i8 @"runtime::map_free_dynamic"(ptr %0, ptr %1, ptr %3, ptr %__.context_ptr)
  %236 = icmp eq i8 %235, 0
  br i1 %236, label %or_return.continue17, label %or_return.return16

or_return.return16:                               ; preds = %for.interval.done
  ret i8 %235

or_return.continue17:                             ; preds = %for.interval.done
  %237 = load ptr, ptr %19, align 8
  %238 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %237, i32 0, i32 0
  %239 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %resized, i32 0, i32 0
  %240 = load i64, ptr %239, align 8
  store i64 %240, ptr %238, align 8
  ret i8 0
}

define i8 @"runtime::append_elem:proc(array:^[dynamic]int,arg:int,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr %0, i64 %1, ptr %2, ptr noalias nonnull %3, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i8, align 1
  %old_size.i = alloca i64, align 8
  %new_size.i = alloca i64, align 8
  %allocator.i = alloca %"runtime::Allocator", align 8
  %new_data.i = alloca { ptr, i64 }, align 8
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca ptr, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca ptr, align 8
  %14 = alloca i8, align 1
  %n.i = alloca i64, align 8
  %err.i = alloca i8, align 1
  %cap.i = alloca i64, align 8
  %data.i = alloca ptr, align 8
  %15 = alloca ptr, align 8
  %16 = alloca ptr, align 8
  %17 = alloca i64, align 8
  %n = alloca i64, align 8
  %err = alloca i8, align 1
  %arg = alloca i64, align 8
  %18 = alloca i64, align 8
  %19 = alloca { i64, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %16, align 8
  store i64 %1, ptr %17, align 8
  store i64 0, ptr %n, align 8
  store i8 0, ptr %err, align 1
  store i64 %1, ptr %arg, align 8
  store i64 0, ptr %18, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !209)
  call void @llvm.experimental.noalias.scope.decl(metadata !212)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %12)
  call void @llvm.lifetime.start.p0(i64 8, ptr %13)
  call void @llvm.lifetime.start.p0(i64 1, ptr %14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %15)
  store ptr %0, ptr %10, align 8, !noalias !214
  store i64 8, ptr %11, align 8, !noalias !214
  store i64 8, ptr %12, align 8, !noalias !214
  store ptr %arg, ptr %13, align 8, !noalias !214
  store i8 1, ptr %14, align 1, !noalias !214
  store i64 0, ptr %n.i, align 8, !noalias !214
  store i8 0, ptr %err.i, align 1, !noalias !214
  %20 = icmp eq ptr %0, null
  %21 = zext i1 %20 to i8
  br i1 %20, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %entry
  %22 = load i64, ptr %n.i, align 8, !noalias !214
  %23 = load i8, ptr %err.i, align 1, !noalias !214
  store i64 %22, ptr %n.i, align 8, !noalias !214
  store i8 %23, ptr %err.i, align 1, !noalias !214
  store i64 %22, ptr %18, align 8, !alias.scope !209, !noalias !212
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 1, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  br label %"runtime::_append_elem.exit"

if.done.i:                                        ; preds = %entry
  %24 = load ptr, ptr %10, align 8, !noalias !214
  %25 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %24, i32 0, i32 2
  %26 = load i64, ptr %25, align 8, !noalias !214
  %27 = load ptr, ptr %10, align 8, !noalias !214
  %28 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %27, i32 0, i32 1
  %29 = load i64, ptr %28, align 8, !noalias !214
  %30 = add i64 %29, 1
  %31 = icmp slt i64 %26, %30
  %32 = zext i1 %31 to i8
  br i1 %31, label %if.then1.i, label %if.done2.i

if.then1.i:                                       ; preds = %if.done.i
  %33 = load ptr, ptr %10, align 8, !noalias !214
  %34 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %33, i32 0, i32 2
  %35 = load i64, ptr %34, align 8, !noalias !214
  %36 = mul i64 2, %35
  %37 = add i64 %36, 8
  store i64 %37, ptr %cap.i, align 8, !noalias !214
  %38 = load i64, ptr %cap.i, align 8, !noalias !214
  call void @llvm.experimental.noalias.scope.decl(metadata !215)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 1, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %9)
  store ptr %0, ptr %4, align 8, !noalias !218
  store i64 8, ptr %5, align 8, !noalias !218
  store i64 8, ptr %6, align 8, !noalias !218
  store i64 %38, ptr %7, align 8, !noalias !218
  store i8 1, ptr %8, align 1, !noalias !218
  %39 = icmp eq ptr %0, null
  %40 = zext i1 %39 to i8
  br i1 %39, label %if.then.i6, label %if.done.i1

if.then.i6:                                       ; preds = %if.then1.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done.i1:                                       ; preds = %if.then1.i
  %41 = load ptr, ptr %4, align 8, !noalias !218
  %42 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %41, i32 0, i32 2
  %43 = load i64, ptr %42, align 8, !noalias !218
  %44 = icmp sle i64 %38, %43
  %45 = zext i1 %44 to i8
  br i1 %44, label %if.then1.i5, label %if.done2.i2

if.then1.i5:                                      ; preds = %if.done.i1
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done2.i2:                                      ; preds = %if.done.i1
  %46 = load ptr, ptr %4, align 8, !noalias !218
  %47 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %46, i32 0, i32 3
  %48 = load ptr, ptr %47, align 8, !noalias !218
  %49 = icmp eq ptr %48, null
  %50 = zext i1 %49 to i8
  br i1 %49, label %if.then3.i4, label %if.done4.i3

if.then3.i4:                                      ; preds = %if.done2.i2
  %51 = load ptr, ptr %4, align 8, !noalias !218
  %52 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %51, i32 0, i32 3
  %53 = load %"runtime::Allocator", ptr %__.context_ptr, align 8, !alias.scope !215, !noalias !209
  store %"runtime::Allocator" %53, ptr %52, align 8, !noalias !218
  br label %if.done4.i3

if.done4.i3:                                      ; preds = %if.then3.i4, %if.done2.i2
  %54 = load ptr, ptr %4, align 8, !noalias !218
  %55 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %54, i32 0, i32 3
  %56 = load ptr, ptr %55, align 8, !noalias !218
  %57 = icmp ne ptr %56, null
  %58 = zext i1 %57 to i8
  call void @"runtime::assert"(i1 zeroext %57, ptr @"ggv$runtime::_reserve_dynamic_array$1", ptr @"scl$[_reserve_dynamic_array28302]", ptr nonnull %__.context_ptr), !noalias !209
  %59 = load ptr, ptr %4, align 8, !noalias !218
  %60 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %59, i32 0, i32 2
  %61 = load i64, ptr %60, align 8, !noalias !218
  %62 = mul i64 %61, 8
  store i64 %62, ptr %old_size.i, align 8, !noalias !218
  %63 = mul i64 %38, 8
  store i64 %63, ptr %new_size.i, align 8, !noalias !218
  %64 = load ptr, ptr %4, align 8, !noalias !218
  %65 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %64, i32 0, i32 3
  %66 = load %"runtime::Allocator", ptr %65, align 8, !noalias !218
  store %"runtime::Allocator" %66, ptr %allocator.i, align 8, !noalias !218
  call void @llvm.memset.inline.p0.i64(ptr %new_data.i, i8 0, i64 16, i1 false), !noalias !218
  %67 = load ptr, ptr %4, align 8, !noalias !218
  %68 = load ptr, ptr %67, align 8, !noalias !218
  %69 = load i64, ptr %old_size.i, align 8, !noalias !218
  %70 = load i64, ptr %new_size.i, align 8, !noalias !218
  call void @llvm.memset.inline.p0.i64(ptr %9, i8 0, i64 16, i1 false), !noalias !218
  %71 = call i8 @"runtime::mem_resize"(ptr %68, i64 %69, i64 %70, i64 8, ptr %allocator.i, ptr %2, ptr %9, ptr nonnull %__.context_ptr), !noalias !209
  %72 = load { ptr, i64 }, ptr %9, align 8, !noalias !218
  %73 = icmp eq i8 %71, 0
  br i1 %73, label %or_return.continue.i, label %or_return.return.i

or_return.return.i:                               ; preds = %if.done4.i3
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

or_return.continue.i:                             ; preds = %if.done4.i3
  store { ptr, i64 } %72, ptr %new_data.i, align 8, !noalias !218
  %74 = load ptr, ptr %new_data.i, align 8, !noalias !218
  %75 = icmp eq ptr %74, null
  %76 = zext i1 %75 to i8
  br i1 %75, label %cmp.and.i, label %if.done10.i

cmp.and.i:                                        ; preds = %or_return.continue.i
  %77 = load i64, ptr %new_size.i, align 8, !noalias !218
  %78 = icmp sgt i64 %77, 0
  %79 = zext i1 %78 to i8
  br i1 %78, label %if.then9.i, label %if.done10.i

if.then9.i:                                       ; preds = %cmp.and.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done10.i:                                      ; preds = %cmp.and.i, %or_return.continue.i
  %80 = load ptr, ptr %4, align 8, !noalias !218
  %81 = load ptr, ptr %new_data.i, align 8, !noalias !218
  store ptr %81, ptr %80, align 8, !noalias !218
  %82 = load ptr, ptr %4, align 8, !noalias !218
  %83 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %82, i32 0, i32 2
  store i64 %38, ptr %83, align 8, !noalias !218
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

"runtime::_reserve_dynamic_array.exit":           ; preds = %if.done10.i, %if.then9.i, %or_return.return.i, %if.then1.i5, %if.then.i6
  %84 = phi i8 [ 0, %if.then.i6 ], [ 0, %if.then1.i5 ], [ %71, %or_return.return.i ], [ 1, %if.then9.i ], [ 0, %if.done10.i ]
  store i8 %84, ptr %err.i, align 1, !noalias !214
  br label %if.done2.i

if.done2.i:                                       ; preds = %"runtime::_reserve_dynamic_array.exit", %if.done.i
  %85 = load ptr, ptr %10, align 8, !noalias !214
  %86 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %85, i32 0, i32 2
  %87 = load i64, ptr %86, align 8, !noalias !214
  %88 = load ptr, ptr %10, align 8, !noalias !214
  %89 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %88, i32 0, i32 1
  %90 = load i64, ptr %89, align 8, !noalias !214
  %91 = sub i64 %87, %90
  %92 = icmp sgt i64 %91, 0
  %93 = zext i1 %92 to i8
  br i1 %92, label %if.then3.i, label %if.done4.i

if.then3.i:                                       ; preds = %if.done2.i
  %94 = load ptr, ptr %10, align 8, !noalias !214
  %95 = load ptr, ptr %94, align 8, !noalias !214
  store ptr %95, ptr %data.i, align 8, !noalias !214
  %96 = load ptr, ptr %data.i, align 8, !noalias !214
  %97 = icmp ne ptr %96, null
  %98 = zext i1 %97 to i8
  call void @"runtime::assert"(i1 zeroext %97, ptr @"ggv$runtime::_append_elem$1", ptr %2, ptr nonnull %__.context_ptr), !noalias !209
  %99 = load ptr, ptr %data.i, align 8, !noalias !214
  %100 = load ptr, ptr %10, align 8, !noalias !214
  %101 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %100, i32 0, i32 1
  %102 = load i64, ptr %101, align 8, !noalias !214
  %103 = mul i64 %102, 8
  %104 = getelementptr i8, ptr %99, i64 %103
  store ptr %104, ptr %15, align 8, !noalias !214
  %105 = load ptr, ptr %15, align 8, !noalias !214
  store ptr %105, ptr %data.i, align 8, !noalias !214
  %106 = load ptr, ptr %data.i, align 8, !noalias !214
  call void @llvm.memcpy.p0.p0.i64(ptr %106, ptr %arg, i64 8, i1 false), !noalias !214
  %107 = load ptr, ptr %10, align 8, !noalias !214
  %108 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %107, i32 0, i32 1
  %109 = load i64, ptr %108, align 8, !noalias !214
  %110 = add i64 %109, 1
  store i64 %110, ptr %108, align 8, !noalias !214
  store i64 1, ptr %n.i, align 8, !noalias !214
  br label %if.done4.i

if.done4.i:                                       ; preds = %if.then3.i, %if.done2.i
  %111 = load i64, ptr %n.i, align 8, !noalias !214
  %112 = load i8, ptr %err.i, align 1, !noalias !214
  store i64 %111, ptr %n.i, align 8, !noalias !214
  store i8 %112, ptr %err.i, align 1, !noalias !214
  store i64 %111, ptr %18, align 8, !alias.scope !209, !noalias !212
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 1, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  br label %"runtime::_append_elem.exit"

"runtime::_append_elem.exit":                     ; preds = %if.done4.i, %if.then.i
  %113 = phi i8 [ %23, %if.then.i ], [ %112, %if.done4.i ]
  %114 = load i64, ptr %18, align 8
  store i64 %114, ptr %n, align 8
  store i8 %113, ptr %err, align 1
  store i64 %114, ptr %3, align 8
  ret i8 %113
}

define i8 @"runtime::append_elem:proc(array:^[dynamic]string,arg:string,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr %2, ptr noalias nonnull %3, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i8, align 1
  %old_size.i = alloca i64, align 8
  %new_size.i = alloca i64, align 8
  %allocator.i = alloca %"runtime::Allocator", align 8
  %new_data.i = alloca { ptr, i64 }, align 8
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca ptr, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca ptr, align 8
  %14 = alloca i8, align 1
  %n.i = alloca i64, align 8
  %err.i = alloca i8, align 1
  %cap.i = alloca i64, align 8
  %data.i = alloca ptr, align 8
  %15 = alloca ptr, align 8
  %16 = alloca ptr, align 8
  %17 = alloca %..string, align 8
  %n = alloca i64, align 8
  %err = alloca i8, align 1
  %arg = alloca %..string, align 8
  %18 = alloca i64, align 8
  %19 = alloca { i64, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %16, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %17, ptr %1, i64 16, i1 false)
  store i64 0, ptr %n, align 8
  store i8 0, ptr %err, align 1
  %20 = load %..string, ptr %17, align 8
  store %..string %20, ptr %arg, align 8
  store i64 0, ptr %18, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !219)
  call void @llvm.experimental.noalias.scope.decl(metadata !222)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %12)
  call void @llvm.lifetime.start.p0(i64 8, ptr %13)
  call void @llvm.lifetime.start.p0(i64 1, ptr %14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %15)
  store ptr %0, ptr %10, align 8, !noalias !224
  store i64 16, ptr %11, align 8, !noalias !224
  store i64 8, ptr %12, align 8, !noalias !224
  store ptr %arg, ptr %13, align 8, !noalias !224
  store i8 1, ptr %14, align 1, !noalias !224
  store i64 0, ptr %n.i, align 8, !noalias !224
  store i8 0, ptr %err.i, align 1, !noalias !224
  %21 = icmp eq ptr %0, null
  %22 = zext i1 %21 to i8
  br i1 %21, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %entry
  %23 = load i64, ptr %n.i, align 8, !noalias !224
  %24 = load i8, ptr %err.i, align 1, !noalias !224
  store i64 %23, ptr %n.i, align 8, !noalias !224
  store i8 %24, ptr %err.i, align 1, !noalias !224
  store i64 %23, ptr %18, align 8, !alias.scope !219, !noalias !222
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 1, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  br label %"runtime::_append_elem.exit"

if.done.i:                                        ; preds = %entry
  %25 = load ptr, ptr %10, align 8, !noalias !224
  %26 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %25, i32 0, i32 2
  %27 = load i64, ptr %26, align 8, !noalias !224
  %28 = load ptr, ptr %10, align 8, !noalias !224
  %29 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %28, i32 0, i32 1
  %30 = load i64, ptr %29, align 8, !noalias !224
  %31 = add i64 %30, 1
  %32 = icmp slt i64 %27, %31
  %33 = zext i1 %32 to i8
  br i1 %32, label %if.then1.i, label %if.done2.i

if.then1.i:                                       ; preds = %if.done.i
  %34 = load ptr, ptr %10, align 8, !noalias !224
  %35 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %34, i32 0, i32 2
  %36 = load i64, ptr %35, align 8, !noalias !224
  %37 = mul i64 2, %36
  %38 = add i64 %37, 8
  store i64 %38, ptr %cap.i, align 8, !noalias !224
  %39 = load i64, ptr %cap.i, align 8, !noalias !224
  call void @llvm.experimental.noalias.scope.decl(metadata !225)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 1, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %9)
  store ptr %0, ptr %4, align 8, !noalias !228
  store i64 16, ptr %5, align 8, !noalias !228
  store i64 8, ptr %6, align 8, !noalias !228
  store i64 %39, ptr %7, align 8, !noalias !228
  store i8 1, ptr %8, align 1, !noalias !228
  %40 = icmp eq ptr %0, null
  %41 = zext i1 %40 to i8
  br i1 %40, label %if.then.i6, label %if.done.i1

if.then.i6:                                       ; preds = %if.then1.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done.i1:                                       ; preds = %if.then1.i
  %42 = load ptr, ptr %4, align 8, !noalias !228
  %43 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %42, i32 0, i32 2
  %44 = load i64, ptr %43, align 8, !noalias !228
  %45 = icmp sle i64 %39, %44
  %46 = zext i1 %45 to i8
  br i1 %45, label %if.then1.i5, label %if.done2.i2

if.then1.i5:                                      ; preds = %if.done.i1
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done2.i2:                                      ; preds = %if.done.i1
  %47 = load ptr, ptr %4, align 8, !noalias !228
  %48 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %47, i32 0, i32 3
  %49 = load ptr, ptr %48, align 8, !noalias !228
  %50 = icmp eq ptr %49, null
  %51 = zext i1 %50 to i8
  br i1 %50, label %if.then3.i4, label %if.done4.i3

if.then3.i4:                                      ; preds = %if.done2.i2
  %52 = load ptr, ptr %4, align 8, !noalias !228
  %53 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %52, i32 0, i32 3
  %54 = load %"runtime::Allocator", ptr %__.context_ptr, align 8, !alias.scope !225, !noalias !219
  store %"runtime::Allocator" %54, ptr %53, align 8, !noalias !228
  br label %if.done4.i3

if.done4.i3:                                      ; preds = %if.then3.i4, %if.done2.i2
  %55 = load ptr, ptr %4, align 8, !noalias !228
  %56 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %55, i32 0, i32 3
  %57 = load ptr, ptr %56, align 8, !noalias !228
  %58 = icmp ne ptr %57, null
  %59 = zext i1 %58 to i8
  call void @"runtime::assert"(i1 zeroext %58, ptr @"ggv$runtime::_reserve_dynamic_array$1", ptr @"scl$[_reserve_dynamic_array28302]", ptr nonnull %__.context_ptr), !noalias !219
  %60 = load ptr, ptr %4, align 8, !noalias !228
  %61 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %60, i32 0, i32 2
  %62 = load i64, ptr %61, align 8, !noalias !228
  %63 = mul i64 %62, 16
  store i64 %63, ptr %old_size.i, align 8, !noalias !228
  %64 = mul i64 %39, 16
  store i64 %64, ptr %new_size.i, align 8, !noalias !228
  %65 = load ptr, ptr %4, align 8, !noalias !228
  %66 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %65, i32 0, i32 3
  %67 = load %"runtime::Allocator", ptr %66, align 8, !noalias !228
  store %"runtime::Allocator" %67, ptr %allocator.i, align 8, !noalias !228
  call void @llvm.memset.inline.p0.i64(ptr %new_data.i, i8 0, i64 16, i1 false), !noalias !228
  %68 = load ptr, ptr %4, align 8, !noalias !228
  %69 = load ptr, ptr %68, align 8, !noalias !228
  %70 = load i64, ptr %old_size.i, align 8, !noalias !228
  %71 = load i64, ptr %new_size.i, align 8, !noalias !228
  call void @llvm.memset.inline.p0.i64(ptr %9, i8 0, i64 16, i1 false), !noalias !228
  %72 = call i8 @"runtime::mem_resize"(ptr %69, i64 %70, i64 %71, i64 8, ptr %allocator.i, ptr %2, ptr %9, ptr nonnull %__.context_ptr), !noalias !219
  %73 = load { ptr, i64 }, ptr %9, align 8, !noalias !228
  %74 = icmp eq i8 %72, 0
  br i1 %74, label %or_return.continue.i, label %or_return.return.i

or_return.return.i:                               ; preds = %if.done4.i3
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

or_return.continue.i:                             ; preds = %if.done4.i3
  store { ptr, i64 } %73, ptr %new_data.i, align 8, !noalias !228
  %75 = load ptr, ptr %new_data.i, align 8, !noalias !228
  %76 = icmp eq ptr %75, null
  %77 = zext i1 %76 to i8
  br i1 %76, label %cmp.and.i, label %if.done10.i

cmp.and.i:                                        ; preds = %or_return.continue.i
  %78 = load i64, ptr %new_size.i, align 8, !noalias !228
  %79 = icmp sgt i64 %78, 0
  %80 = zext i1 %79 to i8
  br i1 %79, label %if.then9.i, label %if.done10.i

if.then9.i:                                       ; preds = %cmp.and.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done10.i:                                      ; preds = %cmp.and.i, %or_return.continue.i
  %81 = load ptr, ptr %4, align 8, !noalias !228
  %82 = load ptr, ptr %new_data.i, align 8, !noalias !228
  store ptr %82, ptr %81, align 8, !noalias !228
  %83 = load ptr, ptr %4, align 8, !noalias !228
  %84 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %83, i32 0, i32 2
  store i64 %39, ptr %84, align 8, !noalias !228
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

"runtime::_reserve_dynamic_array.exit":           ; preds = %if.done10.i, %if.then9.i, %or_return.return.i, %if.then1.i5, %if.then.i6
  %85 = phi i8 [ 0, %if.then.i6 ], [ 0, %if.then1.i5 ], [ %72, %or_return.return.i ], [ 1, %if.then9.i ], [ 0, %if.done10.i ]
  store i8 %85, ptr %err.i, align 1, !noalias !224
  br label %if.done2.i

if.done2.i:                                       ; preds = %"runtime::_reserve_dynamic_array.exit", %if.done.i
  %86 = load ptr, ptr %10, align 8, !noalias !224
  %87 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %86, i32 0, i32 2
  %88 = load i64, ptr %87, align 8, !noalias !224
  %89 = load ptr, ptr %10, align 8, !noalias !224
  %90 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %89, i32 0, i32 1
  %91 = load i64, ptr %90, align 8, !noalias !224
  %92 = sub i64 %88, %91
  %93 = icmp sgt i64 %92, 0
  %94 = zext i1 %93 to i8
  br i1 %93, label %if.then3.i, label %if.done4.i

if.then3.i:                                       ; preds = %if.done2.i
  %95 = load ptr, ptr %10, align 8, !noalias !224
  %96 = load ptr, ptr %95, align 8, !noalias !224
  store ptr %96, ptr %data.i, align 8, !noalias !224
  %97 = load ptr, ptr %data.i, align 8, !noalias !224
  %98 = icmp ne ptr %97, null
  %99 = zext i1 %98 to i8
  call void @"runtime::assert"(i1 zeroext %98, ptr @"ggv$runtime::_append_elem$1", ptr %2, ptr nonnull %__.context_ptr), !noalias !219
  %100 = load ptr, ptr %data.i, align 8, !noalias !224
  %101 = load ptr, ptr %10, align 8, !noalias !224
  %102 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %101, i32 0, i32 1
  %103 = load i64, ptr %102, align 8, !noalias !224
  %104 = mul i64 %103, 16
  %105 = getelementptr i8, ptr %100, i64 %104
  store ptr %105, ptr %15, align 8, !noalias !224
  %106 = load ptr, ptr %15, align 8, !noalias !224
  store ptr %106, ptr %data.i, align 8, !noalias !224
  %107 = load ptr, ptr %data.i, align 8, !noalias !224
  call void @llvm.memcpy.p0.p0.i64(ptr %107, ptr %arg, i64 16, i1 false), !noalias !224
  %108 = load ptr, ptr %10, align 8, !noalias !224
  %109 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %108, i32 0, i32 1
  %110 = load i64, ptr %109, align 8, !noalias !224
  %111 = add i64 %110, 1
  store i64 %111, ptr %109, align 8, !noalias !224
  store i64 1, ptr %n.i, align 8, !noalias !224
  br label %if.done4.i

if.done4.i:                                       ; preds = %if.then3.i, %if.done2.i
  %112 = load i64, ptr %n.i, align 8, !noalias !224
  %113 = load i8, ptr %err.i, align 1, !noalias !224
  store i64 %112, ptr %n.i, align 8, !noalias !224
  store i8 %113, ptr %err.i, align 1, !noalias !224
  store i64 %112, ptr %18, align 8, !alias.scope !219, !noalias !222
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 1, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  br label %"runtime::_append_elem.exit"

"runtime::_append_elem.exit":                     ; preds = %if.done4.i, %if.then.i
  %114 = phi i8 [ %24, %if.then.i ], [ %113, %if.done4.i ]
  %115 = load i64, ptr %18, align 8
  store i64 %115, ptr %n, align 8
  store i8 %114, ptr %err, align 1
  store i64 %115, ptr %3, align 8
  ret i8 %114
}

define i8 @"runtime::append_elem:proc(array:^[dynamic]text_analyzer::DisplayLine,arg:text_analyzer::DisplayLine,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr %2, ptr noalias nonnull %3, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i8, align 1
  %old_size.i = alloca i64, align 8
  %new_size.i = alloca i64, align 8
  %allocator.i = alloca %"runtime::Allocator", align 8
  %new_data.i = alloca { ptr, i64 }, align 8
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca ptr, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca ptr, align 8
  %14 = alloca i8, align 1
  %n.i = alloca i64, align 8
  %err.i = alloca i8, align 1
  %cap.i = alloca i64, align 8
  %data.i = alloca ptr, align 8
  %15 = alloca ptr, align 8
  %16 = alloca ptr, align 8
  %n = alloca i64, align 8
  %err = alloca i8, align 1
  %arg = alloca %"text_analyzer::DisplayLine", align 8
  %17 = alloca i64, align 8
  %18 = alloca { i64, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %16, align 8
  store i64 0, ptr %n, align 8
  store i8 0, ptr %err, align 1
  %19 = load %"text_analyzer::DisplayLine", ptr %1, align 8
  call void @llvm.memset.inline.p0.i64(ptr %arg, i8 0, i64 32, i1 false)
  store %"text_analyzer::DisplayLine" %19, ptr %arg, align 8
  store i64 0, ptr %17, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !229)
  call void @llvm.experimental.noalias.scope.decl(metadata !232)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %12)
  call void @llvm.lifetime.start.p0(i64 8, ptr %13)
  call void @llvm.lifetime.start.p0(i64 1, ptr %14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %15)
  store ptr %0, ptr %10, align 8, !noalias !234
  store i64 32, ptr %11, align 8, !noalias !234
  store i64 8, ptr %12, align 8, !noalias !234
  store ptr %arg, ptr %13, align 8, !noalias !234
  store i8 1, ptr %14, align 1, !noalias !234
  store i64 0, ptr %n.i, align 8, !noalias !234
  store i8 0, ptr %err.i, align 1, !noalias !234
  %20 = icmp eq ptr %0, null
  %21 = zext i1 %20 to i8
  br i1 %20, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %entry
  %22 = load i64, ptr %n.i, align 8, !noalias !234
  %23 = load i8, ptr %err.i, align 1, !noalias !234
  store i64 %22, ptr %n.i, align 8, !noalias !234
  store i8 %23, ptr %err.i, align 1, !noalias !234
  store i64 %22, ptr %17, align 8, !alias.scope !229, !noalias !232
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 1, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  br label %"runtime::_append_elem.exit"

if.done.i:                                        ; preds = %entry
  %24 = load ptr, ptr %10, align 8, !noalias !234
  %25 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %24, i32 0, i32 2
  %26 = load i64, ptr %25, align 8, !noalias !234
  %27 = load ptr, ptr %10, align 8, !noalias !234
  %28 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %27, i32 0, i32 1
  %29 = load i64, ptr %28, align 8, !noalias !234
  %30 = add i64 %29, 1
  %31 = icmp slt i64 %26, %30
  %32 = zext i1 %31 to i8
  br i1 %31, label %if.then1.i, label %if.done2.i

if.then1.i:                                       ; preds = %if.done.i
  %33 = load ptr, ptr %10, align 8, !noalias !234
  %34 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %33, i32 0, i32 2
  %35 = load i64, ptr %34, align 8, !noalias !234
  %36 = mul i64 2, %35
  %37 = add i64 %36, 8
  store i64 %37, ptr %cap.i, align 8, !noalias !234
  %38 = load i64, ptr %cap.i, align 8, !noalias !234
  call void @llvm.experimental.noalias.scope.decl(metadata !235)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 1, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %9)
  store ptr %0, ptr %4, align 8, !noalias !238
  store i64 32, ptr %5, align 8, !noalias !238
  store i64 8, ptr %6, align 8, !noalias !238
  store i64 %38, ptr %7, align 8, !noalias !238
  store i8 1, ptr %8, align 1, !noalias !238
  %39 = icmp eq ptr %0, null
  %40 = zext i1 %39 to i8
  br i1 %39, label %if.then.i6, label %if.done.i1

if.then.i6:                                       ; preds = %if.then1.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done.i1:                                       ; preds = %if.then1.i
  %41 = load ptr, ptr %4, align 8, !noalias !238
  %42 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %41, i32 0, i32 2
  %43 = load i64, ptr %42, align 8, !noalias !238
  %44 = icmp sle i64 %38, %43
  %45 = zext i1 %44 to i8
  br i1 %44, label %if.then1.i5, label %if.done2.i2

if.then1.i5:                                      ; preds = %if.done.i1
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done2.i2:                                      ; preds = %if.done.i1
  %46 = load ptr, ptr %4, align 8, !noalias !238
  %47 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %46, i32 0, i32 3
  %48 = load ptr, ptr %47, align 8, !noalias !238
  %49 = icmp eq ptr %48, null
  %50 = zext i1 %49 to i8
  br i1 %49, label %if.then3.i4, label %if.done4.i3

if.then3.i4:                                      ; preds = %if.done2.i2
  %51 = load ptr, ptr %4, align 8, !noalias !238
  %52 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %51, i32 0, i32 3
  %53 = load %"runtime::Allocator", ptr %__.context_ptr, align 8, !alias.scope !235, !noalias !229
  store %"runtime::Allocator" %53, ptr %52, align 8, !noalias !238
  br label %if.done4.i3

if.done4.i3:                                      ; preds = %if.then3.i4, %if.done2.i2
  %54 = load ptr, ptr %4, align 8, !noalias !238
  %55 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %54, i32 0, i32 3
  %56 = load ptr, ptr %55, align 8, !noalias !238
  %57 = icmp ne ptr %56, null
  %58 = zext i1 %57 to i8
  call void @"runtime::assert"(i1 zeroext %57, ptr @"ggv$runtime::_reserve_dynamic_array$1", ptr @"scl$[_reserve_dynamic_array28302]", ptr nonnull %__.context_ptr), !noalias !229
  %59 = load ptr, ptr %4, align 8, !noalias !238
  %60 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %59, i32 0, i32 2
  %61 = load i64, ptr %60, align 8, !noalias !238
  %62 = mul i64 %61, 32
  store i64 %62, ptr %old_size.i, align 8, !noalias !238
  %63 = mul i64 %38, 32
  store i64 %63, ptr %new_size.i, align 8, !noalias !238
  %64 = load ptr, ptr %4, align 8, !noalias !238
  %65 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %64, i32 0, i32 3
  %66 = load %"runtime::Allocator", ptr %65, align 8, !noalias !238
  store %"runtime::Allocator" %66, ptr %allocator.i, align 8, !noalias !238
  call void @llvm.memset.inline.p0.i64(ptr %new_data.i, i8 0, i64 16, i1 false), !noalias !238
  %67 = load ptr, ptr %4, align 8, !noalias !238
  %68 = load ptr, ptr %67, align 8, !noalias !238
  %69 = load i64, ptr %old_size.i, align 8, !noalias !238
  %70 = load i64, ptr %new_size.i, align 8, !noalias !238
  call void @llvm.memset.inline.p0.i64(ptr %9, i8 0, i64 16, i1 false), !noalias !238
  %71 = call i8 @"runtime::mem_resize"(ptr %68, i64 %69, i64 %70, i64 8, ptr %allocator.i, ptr %2, ptr %9, ptr nonnull %__.context_ptr), !noalias !229
  %72 = load { ptr, i64 }, ptr %9, align 8, !noalias !238
  %73 = icmp eq i8 %71, 0
  br i1 %73, label %or_return.continue.i, label %or_return.return.i

or_return.return.i:                               ; preds = %if.done4.i3
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

or_return.continue.i:                             ; preds = %if.done4.i3
  store { ptr, i64 } %72, ptr %new_data.i, align 8, !noalias !238
  %74 = load ptr, ptr %new_data.i, align 8, !noalias !238
  %75 = icmp eq ptr %74, null
  %76 = zext i1 %75 to i8
  br i1 %75, label %cmp.and.i, label %if.done10.i

cmp.and.i:                                        ; preds = %or_return.continue.i
  %77 = load i64, ptr %new_size.i, align 8, !noalias !238
  %78 = icmp sgt i64 %77, 0
  %79 = zext i1 %78 to i8
  br i1 %78, label %if.then9.i, label %if.done10.i

if.then9.i:                                       ; preds = %cmp.and.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done10.i:                                      ; preds = %cmp.and.i, %or_return.continue.i
  %80 = load ptr, ptr %4, align 8, !noalias !238
  %81 = load ptr, ptr %new_data.i, align 8, !noalias !238
  store ptr %81, ptr %80, align 8, !noalias !238
  %82 = load ptr, ptr %4, align 8, !noalias !238
  %83 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %82, i32 0, i32 2
  store i64 %38, ptr %83, align 8, !noalias !238
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

"runtime::_reserve_dynamic_array.exit":           ; preds = %if.done10.i, %if.then9.i, %or_return.return.i, %if.then1.i5, %if.then.i6
  %84 = phi i8 [ 0, %if.then.i6 ], [ 0, %if.then1.i5 ], [ %71, %or_return.return.i ], [ 1, %if.then9.i ], [ 0, %if.done10.i ]
  store i8 %84, ptr %err.i, align 1, !noalias !234
  br label %if.done2.i

if.done2.i:                                       ; preds = %"runtime::_reserve_dynamic_array.exit", %if.done.i
  %85 = load ptr, ptr %10, align 8, !noalias !234
  %86 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %85, i32 0, i32 2
  %87 = load i64, ptr %86, align 8, !noalias !234
  %88 = load ptr, ptr %10, align 8, !noalias !234
  %89 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %88, i32 0, i32 1
  %90 = load i64, ptr %89, align 8, !noalias !234
  %91 = sub i64 %87, %90
  %92 = icmp sgt i64 %91, 0
  %93 = zext i1 %92 to i8
  br i1 %92, label %if.then3.i, label %if.done4.i

if.then3.i:                                       ; preds = %if.done2.i
  %94 = load ptr, ptr %10, align 8, !noalias !234
  %95 = load ptr, ptr %94, align 8, !noalias !234
  store ptr %95, ptr %data.i, align 8, !noalias !234
  %96 = load ptr, ptr %data.i, align 8, !noalias !234
  %97 = icmp ne ptr %96, null
  %98 = zext i1 %97 to i8
  call void @"runtime::assert"(i1 zeroext %97, ptr @"ggv$runtime::_append_elem$1", ptr %2, ptr nonnull %__.context_ptr), !noalias !229
  %99 = load ptr, ptr %data.i, align 8, !noalias !234
  %100 = load ptr, ptr %10, align 8, !noalias !234
  %101 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %100, i32 0, i32 1
  %102 = load i64, ptr %101, align 8, !noalias !234
  %103 = mul i64 %102, 32
  %104 = getelementptr i8, ptr %99, i64 %103
  store ptr %104, ptr %15, align 8, !noalias !234
  %105 = load ptr, ptr %15, align 8, !noalias !234
  store ptr %105, ptr %data.i, align 8, !noalias !234
  %106 = load ptr, ptr %data.i, align 8, !noalias !234
  call void @llvm.memcpy.p0.p0.i64(ptr %106, ptr %arg, i64 32, i1 false), !noalias !234
  %107 = load ptr, ptr %10, align 8, !noalias !234
  %108 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %107, i32 0, i32 1
  %109 = load i64, ptr %108, align 8, !noalias !234
  %110 = add i64 %109, 1
  store i64 %110, ptr %108, align 8, !noalias !234
  store i64 1, ptr %n.i, align 8, !noalias !234
  br label %if.done4.i

if.done4.i:                                       ; preds = %if.then3.i, %if.done2.i
  %111 = load i64, ptr %n.i, align 8, !noalias !234
  %112 = load i8, ptr %err.i, align 1, !noalias !234
  store i64 %111, ptr %n.i, align 8, !noalias !234
  store i8 %112, ptr %err.i, align 1, !noalias !234
  store i64 %111, ptr %17, align 8, !alias.scope !229, !noalias !232
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 1, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  br label %"runtime::_append_elem.exit"

"runtime::_append_elem.exit":                     ; preds = %if.done4.i, %if.then.i
  %113 = phi i8 [ %23, %if.then.i ], [ %112, %if.done4.i ]
  %114 = load i64, ptr %17, align 8
  store i64 %114, ptr %n, align 8
  store i8 %113, ptr %err, align 1
  store i64 %114, ptr %3, align 8
  ret i8 %113
}

define i8 @"runtime::append_elem:proc(array:^[dynamic]text_analyzer::Highlight,arg:text_analyzer::Highlight,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr %2, ptr noalias nonnull %3, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i8, align 1
  %old_size.i = alloca i64, align 8
  %new_size.i = alloca i64, align 8
  %allocator.i = alloca %"runtime::Allocator", align 8
  %new_data.i = alloca { ptr, i64 }, align 8
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca ptr, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca ptr, align 8
  %14 = alloca i8, align 1
  %n.i = alloca i64, align 8
  %err.i = alloca i8, align 1
  %cap.i = alloca i64, align 8
  %data.i = alloca ptr, align 8
  %15 = alloca ptr, align 8
  %16 = alloca ptr, align 8
  %n = alloca i64, align 8
  %err = alloca i8, align 1
  %arg = alloca %"text_analyzer::Highlight", align 8
  %17 = alloca i64, align 8
  %18 = alloca { i64, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %16, align 8
  store i64 0, ptr %n, align 8
  store i8 0, ptr %err, align 1
  %19 = load %"text_analyzer::Highlight", ptr %1, align 8
  call void @llvm.memset.inline.p0.i64(ptr %arg, i8 0, i64 32, i1 false)
  store %"text_analyzer::Highlight" %19, ptr %arg, align 8
  store i64 0, ptr %17, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !239)
  call void @llvm.experimental.noalias.scope.decl(metadata !242)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %12)
  call void @llvm.lifetime.start.p0(i64 8, ptr %13)
  call void @llvm.lifetime.start.p0(i64 1, ptr %14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %15)
  store ptr %0, ptr %10, align 8, !noalias !244
  store i64 32, ptr %11, align 8, !noalias !244
  store i64 8, ptr %12, align 8, !noalias !244
  store ptr %arg, ptr %13, align 8, !noalias !244
  store i8 1, ptr %14, align 1, !noalias !244
  store i64 0, ptr %n.i, align 8, !noalias !244
  store i8 0, ptr %err.i, align 1, !noalias !244
  %20 = icmp eq ptr %0, null
  %21 = zext i1 %20 to i8
  br i1 %20, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %entry
  %22 = load i64, ptr %n.i, align 8, !noalias !244
  %23 = load i8, ptr %err.i, align 1, !noalias !244
  store i64 %22, ptr %n.i, align 8, !noalias !244
  store i8 %23, ptr %err.i, align 1, !noalias !244
  store i64 %22, ptr %17, align 8, !alias.scope !239, !noalias !242
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 1, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  br label %"runtime::_append_elem.exit"

if.done.i:                                        ; preds = %entry
  %24 = load ptr, ptr %10, align 8, !noalias !244
  %25 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %24, i32 0, i32 2
  %26 = load i64, ptr %25, align 8, !noalias !244
  %27 = load ptr, ptr %10, align 8, !noalias !244
  %28 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %27, i32 0, i32 1
  %29 = load i64, ptr %28, align 8, !noalias !244
  %30 = add i64 %29, 1
  %31 = icmp slt i64 %26, %30
  %32 = zext i1 %31 to i8
  br i1 %31, label %if.then1.i, label %if.done2.i

if.then1.i:                                       ; preds = %if.done.i
  %33 = load ptr, ptr %10, align 8, !noalias !244
  %34 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %33, i32 0, i32 2
  %35 = load i64, ptr %34, align 8, !noalias !244
  %36 = mul i64 2, %35
  %37 = add i64 %36, 8
  store i64 %37, ptr %cap.i, align 8, !noalias !244
  %38 = load i64, ptr %cap.i, align 8, !noalias !244
  call void @llvm.experimental.noalias.scope.decl(metadata !245)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 1, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %9)
  store ptr %0, ptr %4, align 8, !noalias !248
  store i64 32, ptr %5, align 8, !noalias !248
  store i64 8, ptr %6, align 8, !noalias !248
  store i64 %38, ptr %7, align 8, !noalias !248
  store i8 1, ptr %8, align 1, !noalias !248
  %39 = icmp eq ptr %0, null
  %40 = zext i1 %39 to i8
  br i1 %39, label %if.then.i6, label %if.done.i1

if.then.i6:                                       ; preds = %if.then1.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done.i1:                                       ; preds = %if.then1.i
  %41 = load ptr, ptr %4, align 8, !noalias !248
  %42 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %41, i32 0, i32 2
  %43 = load i64, ptr %42, align 8, !noalias !248
  %44 = icmp sle i64 %38, %43
  %45 = zext i1 %44 to i8
  br i1 %44, label %if.then1.i5, label %if.done2.i2

if.then1.i5:                                      ; preds = %if.done.i1
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done2.i2:                                      ; preds = %if.done.i1
  %46 = load ptr, ptr %4, align 8, !noalias !248
  %47 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %46, i32 0, i32 3
  %48 = load ptr, ptr %47, align 8, !noalias !248
  %49 = icmp eq ptr %48, null
  %50 = zext i1 %49 to i8
  br i1 %49, label %if.then3.i4, label %if.done4.i3

if.then3.i4:                                      ; preds = %if.done2.i2
  %51 = load ptr, ptr %4, align 8, !noalias !248
  %52 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %51, i32 0, i32 3
  %53 = load %"runtime::Allocator", ptr %__.context_ptr, align 8, !alias.scope !245, !noalias !239
  store %"runtime::Allocator" %53, ptr %52, align 8, !noalias !248
  br label %if.done4.i3

if.done4.i3:                                      ; preds = %if.then3.i4, %if.done2.i2
  %54 = load ptr, ptr %4, align 8, !noalias !248
  %55 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %54, i32 0, i32 3
  %56 = load ptr, ptr %55, align 8, !noalias !248
  %57 = icmp ne ptr %56, null
  %58 = zext i1 %57 to i8
  call void @"runtime::assert"(i1 zeroext %57, ptr @"ggv$runtime::_reserve_dynamic_array$1", ptr @"scl$[_reserve_dynamic_array28302]", ptr nonnull %__.context_ptr), !noalias !239
  %59 = load ptr, ptr %4, align 8, !noalias !248
  %60 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %59, i32 0, i32 2
  %61 = load i64, ptr %60, align 8, !noalias !248
  %62 = mul i64 %61, 32
  store i64 %62, ptr %old_size.i, align 8, !noalias !248
  %63 = mul i64 %38, 32
  store i64 %63, ptr %new_size.i, align 8, !noalias !248
  %64 = load ptr, ptr %4, align 8, !noalias !248
  %65 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %64, i32 0, i32 3
  %66 = load %"runtime::Allocator", ptr %65, align 8, !noalias !248
  store %"runtime::Allocator" %66, ptr %allocator.i, align 8, !noalias !248
  call void @llvm.memset.inline.p0.i64(ptr %new_data.i, i8 0, i64 16, i1 false), !noalias !248
  %67 = load ptr, ptr %4, align 8, !noalias !248
  %68 = load ptr, ptr %67, align 8, !noalias !248
  %69 = load i64, ptr %old_size.i, align 8, !noalias !248
  %70 = load i64, ptr %new_size.i, align 8, !noalias !248
  call void @llvm.memset.inline.p0.i64(ptr %9, i8 0, i64 16, i1 false), !noalias !248
  %71 = call i8 @"runtime::mem_resize"(ptr %68, i64 %69, i64 %70, i64 8, ptr %allocator.i, ptr %2, ptr %9, ptr nonnull %__.context_ptr), !noalias !239
  %72 = load { ptr, i64 }, ptr %9, align 8, !noalias !248
  %73 = icmp eq i8 %71, 0
  br i1 %73, label %or_return.continue.i, label %or_return.return.i

or_return.return.i:                               ; preds = %if.done4.i3
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

or_return.continue.i:                             ; preds = %if.done4.i3
  store { ptr, i64 } %72, ptr %new_data.i, align 8, !noalias !248
  %74 = load ptr, ptr %new_data.i, align 8, !noalias !248
  %75 = icmp eq ptr %74, null
  %76 = zext i1 %75 to i8
  br i1 %75, label %cmp.and.i, label %if.done10.i

cmp.and.i:                                        ; preds = %or_return.continue.i
  %77 = load i64, ptr %new_size.i, align 8, !noalias !248
  %78 = icmp sgt i64 %77, 0
  %79 = zext i1 %78 to i8
  br i1 %78, label %if.then9.i, label %if.done10.i

if.then9.i:                                       ; preds = %cmp.and.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done10.i:                                      ; preds = %cmp.and.i, %or_return.continue.i
  %80 = load ptr, ptr %4, align 8, !noalias !248
  %81 = load ptr, ptr %new_data.i, align 8, !noalias !248
  store ptr %81, ptr %80, align 8, !noalias !248
  %82 = load ptr, ptr %4, align 8, !noalias !248
  %83 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %82, i32 0, i32 2
  store i64 %38, ptr %83, align 8, !noalias !248
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

"runtime::_reserve_dynamic_array.exit":           ; preds = %if.done10.i, %if.then9.i, %or_return.return.i, %if.then1.i5, %if.then.i6
  %84 = phi i8 [ 0, %if.then.i6 ], [ 0, %if.then1.i5 ], [ %71, %or_return.return.i ], [ 1, %if.then9.i ], [ 0, %if.done10.i ]
  store i8 %84, ptr %err.i, align 1, !noalias !244
  br label %if.done2.i

if.done2.i:                                       ; preds = %"runtime::_reserve_dynamic_array.exit", %if.done.i
  %85 = load ptr, ptr %10, align 8, !noalias !244
  %86 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %85, i32 0, i32 2
  %87 = load i64, ptr %86, align 8, !noalias !244
  %88 = load ptr, ptr %10, align 8, !noalias !244
  %89 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %88, i32 0, i32 1
  %90 = load i64, ptr %89, align 8, !noalias !244
  %91 = sub i64 %87, %90
  %92 = icmp sgt i64 %91, 0
  %93 = zext i1 %92 to i8
  br i1 %92, label %if.then3.i, label %if.done4.i

if.then3.i:                                       ; preds = %if.done2.i
  %94 = load ptr, ptr %10, align 8, !noalias !244
  %95 = load ptr, ptr %94, align 8, !noalias !244
  store ptr %95, ptr %data.i, align 8, !noalias !244
  %96 = load ptr, ptr %data.i, align 8, !noalias !244
  %97 = icmp ne ptr %96, null
  %98 = zext i1 %97 to i8
  call void @"runtime::assert"(i1 zeroext %97, ptr @"ggv$runtime::_append_elem$1", ptr %2, ptr nonnull %__.context_ptr), !noalias !239
  %99 = load ptr, ptr %data.i, align 8, !noalias !244
  %100 = load ptr, ptr %10, align 8, !noalias !244
  %101 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %100, i32 0, i32 1
  %102 = load i64, ptr %101, align 8, !noalias !244
  %103 = mul i64 %102, 32
  %104 = getelementptr i8, ptr %99, i64 %103
  store ptr %104, ptr %15, align 8, !noalias !244
  %105 = load ptr, ptr %15, align 8, !noalias !244
  store ptr %105, ptr %data.i, align 8, !noalias !244
  %106 = load ptr, ptr %data.i, align 8, !noalias !244
  call void @llvm.memcpy.p0.p0.i64(ptr %106, ptr %arg, i64 32, i1 false), !noalias !244
  %107 = load ptr, ptr %10, align 8, !noalias !244
  %108 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %107, i32 0, i32 1
  %109 = load i64, ptr %108, align 8, !noalias !244
  %110 = add i64 %109, 1
  store i64 %110, ptr %108, align 8, !noalias !244
  store i64 1, ptr %n.i, align 8, !noalias !244
  br label %if.done4.i

if.done4.i:                                       ; preds = %if.then3.i, %if.done2.i
  %111 = load i64, ptr %n.i, align 8, !noalias !244
  %112 = load i8, ptr %err.i, align 1, !noalias !244
  store i64 %111, ptr %n.i, align 8, !noalias !244
  store i8 %112, ptr %err.i, align 1, !noalias !244
  store i64 %111, ptr %17, align 8, !alias.scope !239, !noalias !242
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 1, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  br label %"runtime::_append_elem.exit"

"runtime::_append_elem.exit":                     ; preds = %if.done4.i, %if.then.i
  %113 = phi i8 [ %23, %if.then.i ], [ %112, %if.done4.i ]
  %114 = load i64, ptr %17, align 8
  store i64 %114, ptr %n, align 8
  store i8 %113, ptr %err, align 1
  store i64 %114, ptr %3, align 8
  ret i8 %113
}

define i8 @"runtime::append_elem:proc(array:^[dynamic]text_analyzer::Filter,arg:text_analyzer::Filter,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr %2, ptr noalias nonnull %3, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i8, align 1
  %old_size.i = alloca i64, align 8
  %new_size.i = alloca i64, align 8
  %allocator.i = alloca %"runtime::Allocator", align 8
  %new_data.i = alloca { ptr, i64 }, align 8
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca ptr, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca ptr, align 8
  %14 = alloca i8, align 1
  %n.i = alloca i64, align 8
  %err.i = alloca i8, align 1
  %cap.i = alloca i64, align 8
  %data.i = alloca ptr, align 8
  %15 = alloca ptr, align 8
  %16 = alloca ptr, align 8
  %n = alloca i64, align 8
  %err = alloca i8, align 1
  %arg = alloca %"text_analyzer::Filter", align 8
  %17 = alloca i64, align 8
  %18 = alloca { i64, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %16, align 8
  store i64 0, ptr %n, align 8
  store i8 0, ptr %err, align 1
  %19 = load %"text_analyzer::Filter", ptr %1, align 8
  call void @llvm.memset.inline.p0.i64(ptr %arg, i8 0, i64 32, i1 false)
  store %"text_analyzer::Filter" %19, ptr %arg, align 8
  store i64 0, ptr %17, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !249)
  call void @llvm.experimental.noalias.scope.decl(metadata !252)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %12)
  call void @llvm.lifetime.start.p0(i64 8, ptr %13)
  call void @llvm.lifetime.start.p0(i64 1, ptr %14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %15)
  store ptr %0, ptr %10, align 8, !noalias !254
  store i64 32, ptr %11, align 8, !noalias !254
  store i64 8, ptr %12, align 8, !noalias !254
  store ptr %arg, ptr %13, align 8, !noalias !254
  store i8 1, ptr %14, align 1, !noalias !254
  store i64 0, ptr %n.i, align 8, !noalias !254
  store i8 0, ptr %err.i, align 1, !noalias !254
  %20 = icmp eq ptr %0, null
  %21 = zext i1 %20 to i8
  br i1 %20, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %entry
  %22 = load i64, ptr %n.i, align 8, !noalias !254
  %23 = load i8, ptr %err.i, align 1, !noalias !254
  store i64 %22, ptr %n.i, align 8, !noalias !254
  store i8 %23, ptr %err.i, align 1, !noalias !254
  store i64 %22, ptr %17, align 8, !alias.scope !249, !noalias !252
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 1, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  br label %"runtime::_append_elem.exit"

if.done.i:                                        ; preds = %entry
  %24 = load ptr, ptr %10, align 8, !noalias !254
  %25 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %24, i32 0, i32 2
  %26 = load i64, ptr %25, align 8, !noalias !254
  %27 = load ptr, ptr %10, align 8, !noalias !254
  %28 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %27, i32 0, i32 1
  %29 = load i64, ptr %28, align 8, !noalias !254
  %30 = add i64 %29, 1
  %31 = icmp slt i64 %26, %30
  %32 = zext i1 %31 to i8
  br i1 %31, label %if.then1.i, label %if.done2.i

if.then1.i:                                       ; preds = %if.done.i
  %33 = load ptr, ptr %10, align 8, !noalias !254
  %34 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %33, i32 0, i32 2
  %35 = load i64, ptr %34, align 8, !noalias !254
  %36 = mul i64 2, %35
  %37 = add i64 %36, 8
  store i64 %37, ptr %cap.i, align 8, !noalias !254
  %38 = load i64, ptr %cap.i, align 8, !noalias !254
  call void @llvm.experimental.noalias.scope.decl(metadata !255)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 1, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %9)
  store ptr %0, ptr %4, align 8, !noalias !258
  store i64 32, ptr %5, align 8, !noalias !258
  store i64 8, ptr %6, align 8, !noalias !258
  store i64 %38, ptr %7, align 8, !noalias !258
  store i8 1, ptr %8, align 1, !noalias !258
  %39 = icmp eq ptr %0, null
  %40 = zext i1 %39 to i8
  br i1 %39, label %if.then.i6, label %if.done.i1

if.then.i6:                                       ; preds = %if.then1.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done.i1:                                       ; preds = %if.then1.i
  %41 = load ptr, ptr %4, align 8, !noalias !258
  %42 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %41, i32 0, i32 2
  %43 = load i64, ptr %42, align 8, !noalias !258
  %44 = icmp sle i64 %38, %43
  %45 = zext i1 %44 to i8
  br i1 %44, label %if.then1.i5, label %if.done2.i2

if.then1.i5:                                      ; preds = %if.done.i1
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done2.i2:                                      ; preds = %if.done.i1
  %46 = load ptr, ptr %4, align 8, !noalias !258
  %47 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %46, i32 0, i32 3
  %48 = load ptr, ptr %47, align 8, !noalias !258
  %49 = icmp eq ptr %48, null
  %50 = zext i1 %49 to i8
  br i1 %49, label %if.then3.i4, label %if.done4.i3

if.then3.i4:                                      ; preds = %if.done2.i2
  %51 = load ptr, ptr %4, align 8, !noalias !258
  %52 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %51, i32 0, i32 3
  %53 = load %"runtime::Allocator", ptr %__.context_ptr, align 8, !alias.scope !255, !noalias !249
  store %"runtime::Allocator" %53, ptr %52, align 8, !noalias !258
  br label %if.done4.i3

if.done4.i3:                                      ; preds = %if.then3.i4, %if.done2.i2
  %54 = load ptr, ptr %4, align 8, !noalias !258
  %55 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %54, i32 0, i32 3
  %56 = load ptr, ptr %55, align 8, !noalias !258
  %57 = icmp ne ptr %56, null
  %58 = zext i1 %57 to i8
  call void @"runtime::assert"(i1 zeroext %57, ptr @"ggv$runtime::_reserve_dynamic_array$1", ptr @"scl$[_reserve_dynamic_array28302]", ptr nonnull %__.context_ptr), !noalias !249
  %59 = load ptr, ptr %4, align 8, !noalias !258
  %60 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %59, i32 0, i32 2
  %61 = load i64, ptr %60, align 8, !noalias !258
  %62 = mul i64 %61, 32
  store i64 %62, ptr %old_size.i, align 8, !noalias !258
  %63 = mul i64 %38, 32
  store i64 %63, ptr %new_size.i, align 8, !noalias !258
  %64 = load ptr, ptr %4, align 8, !noalias !258
  %65 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %64, i32 0, i32 3
  %66 = load %"runtime::Allocator", ptr %65, align 8, !noalias !258
  store %"runtime::Allocator" %66, ptr %allocator.i, align 8, !noalias !258
  call void @llvm.memset.inline.p0.i64(ptr %new_data.i, i8 0, i64 16, i1 false), !noalias !258
  %67 = load ptr, ptr %4, align 8, !noalias !258
  %68 = load ptr, ptr %67, align 8, !noalias !258
  %69 = load i64, ptr %old_size.i, align 8, !noalias !258
  %70 = load i64, ptr %new_size.i, align 8, !noalias !258
  call void @llvm.memset.inline.p0.i64(ptr %9, i8 0, i64 16, i1 false), !noalias !258
  %71 = call i8 @"runtime::mem_resize"(ptr %68, i64 %69, i64 %70, i64 8, ptr %allocator.i, ptr %2, ptr %9, ptr nonnull %__.context_ptr), !noalias !249
  %72 = load { ptr, i64 }, ptr %9, align 8, !noalias !258
  %73 = icmp eq i8 %71, 0
  br i1 %73, label %or_return.continue.i, label %or_return.return.i

or_return.return.i:                               ; preds = %if.done4.i3
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

or_return.continue.i:                             ; preds = %if.done4.i3
  store { ptr, i64 } %72, ptr %new_data.i, align 8, !noalias !258
  %74 = load ptr, ptr %new_data.i, align 8, !noalias !258
  %75 = icmp eq ptr %74, null
  %76 = zext i1 %75 to i8
  br i1 %75, label %cmp.and.i, label %if.done10.i

cmp.and.i:                                        ; preds = %or_return.continue.i
  %77 = load i64, ptr %new_size.i, align 8, !noalias !258
  %78 = icmp sgt i64 %77, 0
  %79 = zext i1 %78 to i8
  br i1 %78, label %if.then9.i, label %if.done10.i

if.then9.i:                                       ; preds = %cmp.and.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done10.i:                                      ; preds = %cmp.and.i, %or_return.continue.i
  %80 = load ptr, ptr %4, align 8, !noalias !258
  %81 = load ptr, ptr %new_data.i, align 8, !noalias !258
  store ptr %81, ptr %80, align 8, !noalias !258
  %82 = load ptr, ptr %4, align 8, !noalias !258
  %83 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %82, i32 0, i32 2
  store i64 %38, ptr %83, align 8, !noalias !258
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

"runtime::_reserve_dynamic_array.exit":           ; preds = %if.done10.i, %if.then9.i, %or_return.return.i, %if.then1.i5, %if.then.i6
  %84 = phi i8 [ 0, %if.then.i6 ], [ 0, %if.then1.i5 ], [ %71, %or_return.return.i ], [ 1, %if.then9.i ], [ 0, %if.done10.i ]
  store i8 %84, ptr %err.i, align 1, !noalias !254
  br label %if.done2.i

if.done2.i:                                       ; preds = %"runtime::_reserve_dynamic_array.exit", %if.done.i
  %85 = load ptr, ptr %10, align 8, !noalias !254
  %86 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %85, i32 0, i32 2
  %87 = load i64, ptr %86, align 8, !noalias !254
  %88 = load ptr, ptr %10, align 8, !noalias !254
  %89 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %88, i32 0, i32 1
  %90 = load i64, ptr %89, align 8, !noalias !254
  %91 = sub i64 %87, %90
  %92 = icmp sgt i64 %91, 0
  %93 = zext i1 %92 to i8
  br i1 %92, label %if.then3.i, label %if.done4.i

if.then3.i:                                       ; preds = %if.done2.i
  %94 = load ptr, ptr %10, align 8, !noalias !254
  %95 = load ptr, ptr %94, align 8, !noalias !254
  store ptr %95, ptr %data.i, align 8, !noalias !254
  %96 = load ptr, ptr %data.i, align 8, !noalias !254
  %97 = icmp ne ptr %96, null
  %98 = zext i1 %97 to i8
  call void @"runtime::assert"(i1 zeroext %97, ptr @"ggv$runtime::_append_elem$1", ptr %2, ptr nonnull %__.context_ptr), !noalias !249
  %99 = load ptr, ptr %data.i, align 8, !noalias !254
  %100 = load ptr, ptr %10, align 8, !noalias !254
  %101 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %100, i32 0, i32 1
  %102 = load i64, ptr %101, align 8, !noalias !254
  %103 = mul i64 %102, 32
  %104 = getelementptr i8, ptr %99, i64 %103
  store ptr %104, ptr %15, align 8, !noalias !254
  %105 = load ptr, ptr %15, align 8, !noalias !254
  store ptr %105, ptr %data.i, align 8, !noalias !254
  %106 = load ptr, ptr %data.i, align 8, !noalias !254
  call void @llvm.memcpy.p0.p0.i64(ptr %106, ptr %arg, i64 32, i1 false), !noalias !254
  %107 = load ptr, ptr %10, align 8, !noalias !254
  %108 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %107, i32 0, i32 1
  %109 = load i64, ptr %108, align 8, !noalias !254
  %110 = add i64 %109, 1
  store i64 %110, ptr %108, align 8, !noalias !254
  store i64 1, ptr %n.i, align 8, !noalias !254
  br label %if.done4.i

if.done4.i:                                       ; preds = %if.then3.i, %if.done2.i
  %111 = load i64, ptr %n.i, align 8, !noalias !254
  %112 = load i8, ptr %err.i, align 1, !noalias !254
  store i64 %111, ptr %n.i, align 8, !noalias !254
  store i8 %112, ptr %err.i, align 1, !noalias !254
  store i64 %111, ptr %17, align 8, !alias.scope !249, !noalias !252
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 1, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  br label %"runtime::_append_elem.exit"

"runtime::_append_elem.exit":                     ; preds = %if.done4.i, %if.then.i
  %113 = phi i8 [ %23, %if.then.i ], [ %112, %if.done4.i ]
  %114 = load i64, ptr %17, align 8
  store i64 %114, ptr %n, align 8
  store i8 %113, ptr %err, align 1
  store i64 %114, ptr %3, align 8
  ret i8 %113
}

define i8 @"runtime::append_elems:proc(array:^[dynamic]u8,args:..u8,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr %2, ptr noalias nonnull %3, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i8, align 1
  %old_size.i = alloca i64, align 8
  %new_size.i = alloca i64, align 8
  %allocator.i = alloca %"runtime::Allocator", align 8
  %new_data.i = alloca { ptr, i64 }, align 8
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca ptr, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca i8, align 1
  %14 = alloca ptr, align 8
  %15 = alloca i64, align 8
  %n.i = alloca i64, align 8
  %err.i = alloca i8, align 1
  %cap.i = alloca i64, align 8
  %arg_len.i = alloca i64, align 8
  %data.i = alloca ptr, align 8
  %16 = alloca ptr, align 8
  %17 = alloca ptr, align 8
  %18 = alloca { ptr, i64 }, align 8
  %n = alloca i64, align 8
  %err = alloca i8, align 1
  %19 = alloca i64, align 8
  %20 = alloca { i64, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %17, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %18, ptr %1, i64 16, i1 false)
  store i64 0, ptr %n, align 8
  store i8 0, ptr %err, align 1
  %21 = getelementptr inbounds nuw { ptr, i64 }, ptr %18, i32 0, i32 0
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr inbounds nuw { ptr, i64 }, ptr %18, i32 0, i32 1
  %24 = load i64, ptr %23, align 8
  store i64 0, ptr %19, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !259)
  call void @llvm.experimental.noalias.scope.decl(metadata !262)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %12)
  call void @llvm.lifetime.start.p0(i64 1, ptr %13)
  call void @llvm.lifetime.start.p0(i64 8, ptr %14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %arg_len.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %16)
  store ptr %0, ptr %10, align 8, !noalias !264
  store i64 1, ptr %11, align 8, !noalias !264
  store i64 1, ptr %12, align 8, !noalias !264
  store i8 1, ptr %13, align 1, !noalias !264
  store ptr %22, ptr %14, align 8, !noalias !264
  store i64 %24, ptr %15, align 8, !noalias !264
  store i64 0, ptr %n.i, align 8, !noalias !264
  store i8 0, ptr %err.i, align 1, !noalias !264
  %25 = icmp eq ptr %0, null
  %26 = zext i1 %25 to i8
  br i1 %25, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %entry
  store i64 0, ptr %n.i, align 8, !noalias !264
  store i8 0, ptr %err.i, align 1, !noalias !264
  store i64 0, ptr %19, align 8, !alias.scope !259, !noalias !262
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %arg_len.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  br label %"runtime::_append_elems.exit"

if.done.i:                                        ; preds = %entry
  %27 = icmp sle i64 %24, 0
  %28 = zext i1 %27 to i8
  br i1 %27, label %if.then1.i, label %if.done2.i

if.then1.i:                                       ; preds = %if.done.i
  store i64 0, ptr %n.i, align 8, !noalias !264
  store i8 0, ptr %err.i, align 1, !noalias !264
  store i64 0, ptr %19, align 8, !alias.scope !259, !noalias !262
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %arg_len.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  br label %"runtime::_append_elems.exit"

if.done2.i:                                       ; preds = %if.done.i
  %29 = load ptr, ptr %10, align 8, !noalias !264
  %30 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %29, i32 0, i32 2
  %31 = load i64, ptr %30, align 8, !noalias !264
  %32 = load ptr, ptr %10, align 8, !noalias !264
  %33 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %32, i32 0, i32 1
  %34 = load i64, ptr %33, align 8, !noalias !264
  %35 = add i64 %34, %24
  %36 = icmp slt i64 %31, %35
  %37 = zext i1 %36 to i8
  br i1 %36, label %if.then3.i, label %if.done4.i

if.then3.i:                                       ; preds = %if.done2.i
  %38 = load ptr, ptr %10, align 8, !noalias !264
  %39 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %38, i32 0, i32 2
  %40 = load i64, ptr %39, align 8, !noalias !264
  %41 = mul i64 2, %40
  %42 = icmp sgt i64 8, %24
  %43 = select i1 %42, i64 8, i64 %24
  %44 = add i64 %41, %43
  store i64 %44, ptr %cap.i, align 8, !noalias !264
  %45 = load i64, ptr %cap.i, align 8, !noalias !264
  call void @llvm.experimental.noalias.scope.decl(metadata !265)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 1, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.start.p0(i64 16, ptr %9)
  store ptr %0, ptr %4, align 8, !noalias !268
  store i64 1, ptr %5, align 8, !noalias !268
  store i64 1, ptr %6, align 8, !noalias !268
  store i64 %45, ptr %7, align 8, !noalias !268
  store i8 1, ptr %8, align 1, !noalias !268
  %46 = icmp eq ptr %0, null
  %47 = zext i1 %46 to i8
  br i1 %46, label %if.then.i7, label %if.done.i1

if.then.i7:                                       ; preds = %if.then3.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done.i1:                                       ; preds = %if.then3.i
  %48 = load ptr, ptr %4, align 8, !noalias !268
  %49 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %48, i32 0, i32 2
  %50 = load i64, ptr %49, align 8, !noalias !268
  %51 = icmp sle i64 %45, %50
  %52 = zext i1 %51 to i8
  br i1 %51, label %if.then1.i6, label %if.done2.i2

if.then1.i6:                                      ; preds = %if.done.i1
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done2.i2:                                      ; preds = %if.done.i1
  %53 = load ptr, ptr %4, align 8, !noalias !268
  %54 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %53, i32 0, i32 3
  %55 = load ptr, ptr %54, align 8, !noalias !268
  %56 = icmp eq ptr %55, null
  %57 = zext i1 %56 to i8
  br i1 %56, label %if.then3.i5, label %if.done4.i3

if.then3.i5:                                      ; preds = %if.done2.i2
  %58 = load ptr, ptr %4, align 8, !noalias !268
  %59 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %58, i32 0, i32 3
  %60 = load %"runtime::Allocator", ptr %__.context_ptr, align 8, !alias.scope !265, !noalias !259
  store %"runtime::Allocator" %60, ptr %59, align 8, !noalias !268
  br label %if.done4.i3

if.done4.i3:                                      ; preds = %if.then3.i5, %if.done2.i2
  %61 = load ptr, ptr %4, align 8, !noalias !268
  %62 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %61, i32 0, i32 3
  %63 = load ptr, ptr %62, align 8, !noalias !268
  %64 = icmp ne ptr %63, null
  %65 = zext i1 %64 to i8
  call void @"runtime::assert"(i1 zeroext %64, ptr @"ggv$runtime::_reserve_dynamic_array$1", ptr @"scl$[_reserve_dynamic_array28302]", ptr nonnull %__.context_ptr), !noalias !259
  %66 = load ptr, ptr %4, align 8, !noalias !268
  %67 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %66, i32 0, i32 2
  %68 = load i64, ptr %67, align 8, !noalias !268
  store i64 %68, ptr %old_size.i, align 8, !noalias !268
  store i64 %45, ptr %new_size.i, align 8, !noalias !268
  %69 = load ptr, ptr %4, align 8, !noalias !268
  %70 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %69, i32 0, i32 3
  %71 = load %"runtime::Allocator", ptr %70, align 8, !noalias !268
  store %"runtime::Allocator" %71, ptr %allocator.i, align 8, !noalias !268
  call void @llvm.memset.inline.p0.i64(ptr %new_data.i, i8 0, i64 16, i1 false), !noalias !268
  %72 = load ptr, ptr %4, align 8, !noalias !268
  %73 = load ptr, ptr %72, align 8, !noalias !268
  %74 = load i64, ptr %old_size.i, align 8, !noalias !268
  %75 = load i64, ptr %new_size.i, align 8, !noalias !268
  call void @llvm.memset.inline.p0.i64(ptr %9, i8 0, i64 16, i1 false), !noalias !268
  %76 = call i8 @"runtime::mem_resize"(ptr %73, i64 %74, i64 %75, i64 1, ptr %allocator.i, ptr %2, ptr %9, ptr nonnull %__.context_ptr), !noalias !259
  %77 = load { ptr, i64 }, ptr %9, align 8, !noalias !268
  %78 = icmp eq i8 %76, 0
  br i1 %78, label %or_return.continue.i, label %or_return.return.i

or_return.return.i:                               ; preds = %if.done4.i3
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

or_return.continue.i:                             ; preds = %if.done4.i3
  store { ptr, i64 } %77, ptr %new_data.i, align 8, !noalias !268
  %79 = load ptr, ptr %new_data.i, align 8, !noalias !268
  %80 = icmp eq ptr %79, null
  %81 = zext i1 %80 to i8
  br i1 %80, label %cmp.and.i, label %if.done10.i

cmp.and.i:                                        ; preds = %or_return.continue.i
  %82 = load i64, ptr %new_size.i, align 8, !noalias !268
  %83 = icmp sgt i64 %82, 0
  %84 = zext i1 %83 to i8
  br i1 %83, label %if.then9.i, label %if.done10.i

if.then9.i:                                       ; preds = %cmp.and.i
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

if.done10.i:                                      ; preds = %cmp.and.i, %or_return.continue.i
  %85 = load ptr, ptr %4, align 8, !noalias !268
  %86 = load ptr, ptr %new_data.i, align 8, !noalias !268
  store ptr %86, ptr %85, align 8, !noalias !268
  %87 = load ptr, ptr %4, align 8, !noalias !268
  %88 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %87, i32 0, i32 2
  store i64 %45, ptr %88, align 8, !noalias !268
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 1, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %old_size.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %new_size.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %allocator.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %new_data.i)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  br label %"runtime::_reserve_dynamic_array.exit"

"runtime::_reserve_dynamic_array.exit":           ; preds = %if.done10.i, %if.then9.i, %or_return.return.i, %if.then1.i6, %if.then.i7
  %89 = phi i8 [ 0, %if.then.i7 ], [ 0, %if.then1.i6 ], [ %76, %or_return.return.i ], [ 1, %if.then9.i ], [ 0, %if.done10.i ]
  store i8 %89, ptr %err.i, align 1, !noalias !264
  br label %if.done4.i

if.done4.i:                                       ; preds = %"runtime::_reserve_dynamic_array.exit", %if.done2.i
  store i64 %24, ptr %arg_len.i, align 8, !noalias !264
  %90 = load i64, ptr %arg_len.i, align 8, !noalias !264
  %91 = load ptr, ptr %10, align 8, !noalias !264
  %92 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %91, i32 0, i32 2
  %93 = load i64, ptr %92, align 8, !noalias !264
  %94 = load ptr, ptr %10, align 8, !noalias !264
  %95 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %94, i32 0, i32 1
  %96 = load i64, ptr %95, align 8, !noalias !264
  %97 = sub i64 %93, %96
  %98 = icmp slt i64 %97, %90
  %99 = select i1 %98, i64 %97, i64 %90
  store i64 %99, ptr %arg_len.i, align 8, !noalias !264
  %100 = load i64, ptr %arg_len.i, align 8, !noalias !264
  %101 = icmp sgt i64 %100, 0
  %102 = zext i1 %101 to i8
  br i1 %101, label %if.then5.i, label %if.done6.i

if.then5.i:                                       ; preds = %if.done4.i
  %103 = load ptr, ptr %10, align 8, !noalias !264
  %104 = load ptr, ptr %103, align 8, !noalias !264
  store ptr %104, ptr %data.i, align 8, !noalias !264
  %105 = load ptr, ptr %data.i, align 8, !noalias !264
  %106 = icmp ne ptr %105, null
  %107 = zext i1 %106 to i8
  call void @"runtime::assert"(i1 zeroext %106, ptr @"ggv$runtime::_append_elems$1", ptr %2, ptr nonnull %__.context_ptr), !noalias !259
  %108 = load ptr, ptr %data.i, align 8, !noalias !264
  %109 = load ptr, ptr %10, align 8, !noalias !264
  %110 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %109, i32 0, i32 1
  %111 = load i64, ptr %110, align 8, !noalias !264
  %112 = getelementptr i8, ptr %108, i64 %111
  store ptr %112, ptr %16, align 8, !noalias !264
  %113 = load ptr, ptr %16, align 8, !noalias !264
  store ptr %113, ptr %data.i, align 8, !noalias !264
  %114 = load ptr, ptr %data.i, align 8, !noalias !264
  %115 = load i64, ptr %arg_len.i, align 8, !noalias !264
  call void @llvm.memmove.p0.p0.i64(ptr %114, ptr %22, i64 %115, i1 false), !noalias !264
  %116 = load ptr, ptr %10, align 8, !noalias !264
  %117 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %116, i32 0, i32 1
  %118 = load i64, ptr %arg_len.i, align 8, !noalias !264
  %119 = load i64, ptr %117, align 8, !noalias !264
  %120 = add i64 %119, %118
  store i64 %120, ptr %117, align 8, !noalias !264
  br label %if.done6.i

if.done6.i:                                       ; preds = %if.then5.i, %if.done4.i
  %121 = load i64, ptr %arg_len.i, align 8, !noalias !264
  %122 = load i8, ptr %err.i, align 1, !noalias !264
  store i64 %121, ptr %n.i, align 8, !noalias !264
  store i8 %122, ptr %err.i, align 1, !noalias !264
  store i64 %121, ptr %19, align 8, !alias.scope !259, !noalias !262
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 1, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %n.i)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cap.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %arg_len.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  br label %"runtime::_append_elems.exit"

"runtime::_append_elems.exit":                    ; preds = %if.done6.i, %if.then1.i, %if.then.i
  %123 = phi i8 [ 0, %if.then.i ], [ 0, %if.then1.i ], [ %122, %if.done6.i ]
  %124 = load i64, ptr %19, align 8
  store i64 %124, ptr %n, align 8
  store i8 %123, ptr %err, align 1
  store i64 %124, ptr %3, align 8
  ret i8 %123
}

; Function Attrs: noinline
define i8 @"runtime::map_free_dynamic"(ptr %0, ptr %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) #2 {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca ptr, align 8
  %10 = alloca i64, align 8
  %elements_per_cell.i37.i = alloca i64, align 8
  %size_of_cell.i38.i = alloca i64, align 8
  %cell_index.i39.i = alloca i64, align 8
  %data_index.i40.i = alloca i64, align 8
  %size_of_type.i41.i = alloca i64, align 8
  %cell_index2.i42.i = alloca i64, align 8
  %data_index3.i43.i = alloca i64, align 8
  %size_of_type4.i44.i = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i64, align 8
  %elements_per_cell.i25.i = alloca i64, align 8
  %size_of_cell.i26.i = alloca i64, align 8
  %cell_index.i27.i = alloca i64, align 8
  %data_index.i28.i = alloca i64, align 8
  %size_of_type.i29.i = alloca i64, align 8
  %cell_index2.i30.i = alloca i64, align 8
  %data_index3.i31.i = alloca i64, align 8
  %size_of_type4.i32.i = alloca i64, align 8
  %14 = alloca i64, align 8
  %15 = alloca ptr, align 8
  %16 = alloca i64, align 8
  %elements_per_cell.i13.i = alloca i64, align 8
  %size_of_cell.i14.i = alloca i64, align 8
  %cell_index.i15.i = alloca i64, align 8
  %data_index.i16.i = alloca i64, align 8
  %size_of_type.i17.i = alloca i64, align 8
  %cell_index2.i18.i = alloca i64, align 8
  %data_index3.i19.i = alloca i64, align 8
  %size_of_type4.i20.i = alloca i64, align 8
  %17 = alloca i64, align 8
  %18 = alloca ptr, align 8
  %19 = alloca i64, align 8
  %elements_per_cell.i1.i = alloca i64, align 8
  %size_of_cell.i2.i = alloca i64, align 8
  %cell_index.i3.i = alloca i64, align 8
  %data_index.i4.i = alloca i64, align 8
  %size_of_type.i5.i = alloca i64, align 8
  %cell_index2.i6.i = alloca i64, align 8
  %data_index3.i7.i = alloca i64, align 8
  %size_of_type4.i8.i = alloca i64, align 8
  %20 = alloca i64, align 8
  %21 = alloca ptr, align 8
  %22 = alloca i64, align 8
  %elements_per_cell.i.i = alloca i64, align 8
  %size_of_cell.i.i = alloca i64, align 8
  %cell_index.i.i = alloca i64, align 8
  %data_index.i.i = alloca i64, align 8
  %size_of_type.i.i = alloca i64, align 8
  %cell_index2.i.i = alloca i64, align 8
  %data_index3.i.i = alloca i64, align 8
  %size_of_type4.i.i = alloca i64, align 8
  %23 = alloca i64, align 8
  %24 = alloca ptr, align 8
  %INFO_HS.i = alloca ptr, align 8
  %size.i = alloca i64, align 8
  %25 = alloca ptr, align 8
  %26 = alloca i64, align 8
  %27 = alloca %"runtime::Allocator", align 8
  %28 = alloca { ptr, i64 }, align 8
  %err.i = alloca i8, align 1
  %29 = alloca ptr, align 8
  %ptr = alloca ptr, align 8
  %size = alloca i64, align 8
  %err = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %1, ptr %29, align 8
  %30 = load i64, ptr %0, align 8
  %31 = and i64 %30, -64
  %32 = inttoptr i64 %31 to ptr
  store ptr %32, ptr %ptr, align 8
  %33 = load i64, ptr %0, align 8
  %34 = icmp eq i64 %33, 0
  %35 = zext i1 %34 to i8
  br i1 %34, label %if.then.i2, label %if.else.i

if.then.i2:                                       ; preds = %entry
  br label %"runtime::map_cap.exit"

if.else.i:                                        ; preds = %entry
  %36 = load i64, ptr %0, align 8
  %37 = and i64 %36, 63
  %38 = icmp ult i64 %37, 64
  %39 = shl i64 1, %37
  %40 = select i1 %38, i64 %39, i64 0
  br label %"runtime::map_cap.exit"

"runtime::map_cap.exit":                          ; preds = %if.then.i2, %if.else.i
  %41 = phi i64 [ 0, %if.then.i2 ], [ %40, %if.else.i ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %23)
  call void @llvm.lifetime.start.p0(i64 8, ptr %24)
  call void @llvm.lifetime.start.p0(i64 8, ptr %INFO_HS.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size.i)
  store i64 %41, ptr %23, align 8
  store ptr %1, ptr %24, align 8
  store ptr @"ggv$map_cell_info-13197927915248882629", ptr %INFO_HS.i, align 8
  store i64 0, ptr %size.i, align 8
  %42 = load i64, ptr %size.i, align 8
  %43 = load ptr, ptr %24, align 8
  %44 = load ptr, ptr %43, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !269)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 8, ptr %9)
  call void @llvm.lifetime.start.p0(i64 8, ptr %10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i37.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i38.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i39.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i40.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i41.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i42.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i43.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i44.i)
  store i64 %42, ptr %8, align 8, !noalias !269
  store ptr %44, ptr %9, align 8, !noalias !269
  store i64 %41, ptr %10, align 8, !noalias !269
  %45 = load ptr, ptr %9, align 8, !noalias !269
  %46 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %45, i32 0, i32 3
  %47 = load i64, ptr %46, align 8
  store i64 %47, ptr %elements_per_cell.i37.i, align 8, !noalias !269
  %48 = load ptr, ptr %9, align 8, !noalias !269
  %49 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %48, i32 0, i32 2
  %50 = load i64, ptr %49, align 8
  store i64 %50, ptr %size_of_cell.i38.i, align 8, !noalias !269
  %51 = load i64, ptr %elements_per_cell.i37.i, align 8, !noalias !269
  switch i64 %51, label %switch.default.body.i47.i [
    i64 1, label %switch.case.body.i46.i
    i64 2, label %switch.case.body1.i45.i
  ]

switch.case.body.i46.i:                           ; preds = %"runtime::map_cap.exit"
  %52 = load i64, ptr %size_of_cell.i38.i, align 8, !noalias !269
  %53 = mul i64 %41, %52
  %54 = add i64 %42, %53
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i37.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i38.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i39.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i40.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i41.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i42.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i43.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i44.i)
  br label %"runtime::map_cell_index_dynamic.exit48.i"

switch.case.body1.i45.i:                          ; preds = %"runtime::map_cap.exit"
  %55 = lshr i64 %41, 1
  store i64 %55, ptr %cell_index.i39.i, align 8, !noalias !269
  %56 = and i64 %41, 1
  store i64 %56, ptr %data_index.i40.i, align 8, !noalias !269
  %57 = load ptr, ptr %9, align 8, !noalias !269
  %58 = load i64, ptr %57, align 8
  store i64 %58, ptr %size_of_type.i41.i, align 8, !noalias !269
  %59 = load i64, ptr %cell_index.i39.i, align 8, !noalias !269
  %60 = load i64, ptr %size_of_cell.i38.i, align 8, !noalias !269
  %61 = mul i64 %59, %60
  %62 = add i64 %42, %61
  %63 = load i64, ptr %data_index.i40.i, align 8, !noalias !269
  %64 = load i64, ptr %size_of_type.i41.i, align 8, !noalias !269
  %65 = mul i64 %63, %64
  %66 = add i64 %62, %65
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i37.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i38.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i39.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i40.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i41.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i42.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i43.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i44.i)
  br label %"runtime::map_cell_index_dynamic.exit48.i"

switch.default.body.i47.i:                        ; preds = %"runtime::map_cap.exit"
  %67 = load i64, ptr %elements_per_cell.i37.i, align 8, !noalias !269
  %68 = udiv i64 %41, %67
  store i64 %68, ptr %cell_index2.i42.i, align 8, !noalias !269
  %69 = load i64, ptr %elements_per_cell.i37.i, align 8, !noalias !269
  %70 = urem i64 %41, %69
  store i64 %70, ptr %data_index3.i43.i, align 8, !noalias !269
  %71 = load ptr, ptr %9, align 8, !noalias !269
  %72 = load i64, ptr %71, align 8
  store i64 %72, ptr %size_of_type4.i44.i, align 8, !noalias !269
  %73 = load i64, ptr %cell_index2.i42.i, align 8, !noalias !269
  %74 = load i64, ptr %size_of_cell.i38.i, align 8, !noalias !269
  %75 = mul i64 %73, %74
  %76 = add i64 %42, %75
  %77 = load i64, ptr %data_index3.i43.i, align 8, !noalias !269
  %78 = load i64, ptr %size_of_type4.i44.i, align 8, !noalias !269
  %79 = mul i64 %77, %78
  %80 = add i64 %76, %79
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %9)
  call void @llvm.lifetime.end.p0(i64 8, ptr %10)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i37.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i38.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i39.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i40.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i41.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i42.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i43.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i44.i)
  br label %"runtime::map_cell_index_dynamic.exit48.i"

"runtime::map_cell_index_dynamic.exit48.i":       ; preds = %switch.default.body.i47.i, %switch.case.body1.i45.i, %switch.case.body.i46.i
  %81 = phi i64 [ %54, %switch.case.body.i46.i ], [ %66, %switch.case.body1.i45.i ], [ %80, %switch.default.body.i47.i ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  store i64 %81, ptr %3, align 8
  %82 = add i64 %81, 63
  %83 = and i64 %82, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  store i64 %83, ptr %size.i, align 8
  %84 = load i64, ptr %size.i, align 8
  %85 = load ptr, ptr %24, align 8
  %86 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %85, i32 0, i32 1
  %87 = load ptr, ptr %86, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !272)
  call void @llvm.lifetime.start.p0(i64 8, ptr %11)
  call void @llvm.lifetime.start.p0(i64 8, ptr %12)
  call void @llvm.lifetime.start.p0(i64 8, ptr %13)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i25.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i26.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i27.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i28.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i29.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i30.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i31.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i32.i)
  store i64 %84, ptr %11, align 8, !noalias !272
  store ptr %87, ptr %12, align 8, !noalias !272
  store i64 %41, ptr %13, align 8, !noalias !272
  %88 = load ptr, ptr %12, align 8, !noalias !272
  %89 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %88, i32 0, i32 3
  %90 = load i64, ptr %89, align 8
  store i64 %90, ptr %elements_per_cell.i25.i, align 8, !noalias !272
  %91 = load ptr, ptr %12, align 8, !noalias !272
  %92 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %91, i32 0, i32 2
  %93 = load i64, ptr %92, align 8
  store i64 %93, ptr %size_of_cell.i26.i, align 8, !noalias !272
  %94 = load i64, ptr %elements_per_cell.i25.i, align 8, !noalias !272
  switch i64 %94, label %switch.default.body.i35.i [
    i64 1, label %switch.case.body.i34.i
    i64 2, label %switch.case.body1.i33.i
  ]

switch.case.body.i34.i:                           ; preds = %"runtime::map_cell_index_dynamic.exit48.i"
  %95 = load i64, ptr %size_of_cell.i26.i, align 8, !noalias !272
  %96 = mul i64 %41, %95
  %97 = add i64 %84, %96
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i25.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i26.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i27.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i28.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i29.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i30.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i31.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i32.i)
  br label %"runtime::map_cell_index_dynamic.exit36.i"

switch.case.body1.i33.i:                          ; preds = %"runtime::map_cell_index_dynamic.exit48.i"
  %98 = lshr i64 %41, 1
  store i64 %98, ptr %cell_index.i27.i, align 8, !noalias !272
  %99 = and i64 %41, 1
  store i64 %99, ptr %data_index.i28.i, align 8, !noalias !272
  %100 = load ptr, ptr %12, align 8, !noalias !272
  %101 = load i64, ptr %100, align 8
  store i64 %101, ptr %size_of_type.i29.i, align 8, !noalias !272
  %102 = load i64, ptr %cell_index.i27.i, align 8, !noalias !272
  %103 = load i64, ptr %size_of_cell.i26.i, align 8, !noalias !272
  %104 = mul i64 %102, %103
  %105 = add i64 %84, %104
  %106 = load i64, ptr %data_index.i28.i, align 8, !noalias !272
  %107 = load i64, ptr %size_of_type.i29.i, align 8, !noalias !272
  %108 = mul i64 %106, %107
  %109 = add i64 %105, %108
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i25.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i26.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i27.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i28.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i29.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i30.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i31.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i32.i)
  br label %"runtime::map_cell_index_dynamic.exit36.i"

switch.default.body.i35.i:                        ; preds = %"runtime::map_cell_index_dynamic.exit48.i"
  %110 = load i64, ptr %elements_per_cell.i25.i, align 8, !noalias !272
  %111 = udiv i64 %41, %110
  store i64 %111, ptr %cell_index2.i30.i, align 8, !noalias !272
  %112 = load i64, ptr %elements_per_cell.i25.i, align 8, !noalias !272
  %113 = urem i64 %41, %112
  store i64 %113, ptr %data_index3.i31.i, align 8, !noalias !272
  %114 = load ptr, ptr %12, align 8, !noalias !272
  %115 = load i64, ptr %114, align 8
  store i64 %115, ptr %size_of_type4.i32.i, align 8, !noalias !272
  %116 = load i64, ptr %cell_index2.i30.i, align 8, !noalias !272
  %117 = load i64, ptr %size_of_cell.i26.i, align 8, !noalias !272
  %118 = mul i64 %116, %117
  %119 = add i64 %84, %118
  %120 = load i64, ptr %data_index3.i31.i, align 8, !noalias !272
  %121 = load i64, ptr %size_of_type4.i32.i, align 8, !noalias !272
  %122 = mul i64 %120, %121
  %123 = add i64 %119, %122
  call void @llvm.lifetime.end.p0(i64 8, ptr %11)
  call void @llvm.lifetime.end.p0(i64 8, ptr %12)
  call void @llvm.lifetime.end.p0(i64 8, ptr %13)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i25.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i26.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i27.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i28.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i29.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i30.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i31.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i32.i)
  br label %"runtime::map_cell_index_dynamic.exit36.i"

"runtime::map_cell_index_dynamic.exit36.i":       ; preds = %switch.default.body.i35.i, %switch.case.body1.i33.i, %switch.case.body.i34.i
  %124 = phi i64 [ %97, %switch.case.body.i34.i ], [ %109, %switch.case.body1.i33.i ], [ %123, %switch.default.body.i35.i ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  store i64 %124, ptr %4, align 8
  %125 = add i64 %124, 63
  %126 = and i64 %125, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  store i64 %126, ptr %size.i, align 8
  %127 = load i64, ptr %size.i, align 8
  %128 = load ptr, ptr %INFO_HS.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !275)
  call void @llvm.lifetime.start.p0(i64 8, ptr %14)
  call void @llvm.lifetime.start.p0(i64 8, ptr %15)
  call void @llvm.lifetime.start.p0(i64 8, ptr %16)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i13.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i14.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i15.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i16.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i17.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i18.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i19.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i20.i)
  store i64 %127, ptr %14, align 8, !noalias !275
  store ptr %128, ptr %15, align 8, !noalias !275
  store i64 %41, ptr %16, align 8, !noalias !275
  %129 = load ptr, ptr %15, align 8, !noalias !275
  %130 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %129, i32 0, i32 3
  %131 = load i64, ptr %130, align 8
  store i64 %131, ptr %elements_per_cell.i13.i, align 8, !noalias !275
  %132 = load ptr, ptr %15, align 8, !noalias !275
  %133 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %132, i32 0, i32 2
  %134 = load i64, ptr %133, align 8
  store i64 %134, ptr %size_of_cell.i14.i, align 8, !noalias !275
  %135 = load i64, ptr %elements_per_cell.i13.i, align 8, !noalias !275
  switch i64 %135, label %switch.default.body.i23.i [
    i64 1, label %switch.case.body.i22.i
    i64 2, label %switch.case.body1.i21.i
  ]

switch.case.body.i22.i:                           ; preds = %"runtime::map_cell_index_dynamic.exit36.i"
  %136 = load i64, ptr %size_of_cell.i14.i, align 8, !noalias !275
  %137 = mul i64 %41, %136
  %138 = add i64 %127, %137
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i13.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i14.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i15.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i16.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i17.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i18.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i19.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i20.i)
  br label %"runtime::map_cell_index_dynamic.exit24.i"

switch.case.body1.i21.i:                          ; preds = %"runtime::map_cell_index_dynamic.exit36.i"
  %139 = lshr i64 %41, 1
  store i64 %139, ptr %cell_index.i15.i, align 8, !noalias !275
  %140 = and i64 %41, 1
  store i64 %140, ptr %data_index.i16.i, align 8, !noalias !275
  %141 = load ptr, ptr %15, align 8, !noalias !275
  %142 = load i64, ptr %141, align 8
  store i64 %142, ptr %size_of_type.i17.i, align 8, !noalias !275
  %143 = load i64, ptr %cell_index.i15.i, align 8, !noalias !275
  %144 = load i64, ptr %size_of_cell.i14.i, align 8, !noalias !275
  %145 = mul i64 %143, %144
  %146 = add i64 %127, %145
  %147 = load i64, ptr %data_index.i16.i, align 8, !noalias !275
  %148 = load i64, ptr %size_of_type.i17.i, align 8, !noalias !275
  %149 = mul i64 %147, %148
  %150 = add i64 %146, %149
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i13.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i14.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i15.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i16.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i17.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i18.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i19.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i20.i)
  br label %"runtime::map_cell_index_dynamic.exit24.i"

switch.default.body.i23.i:                        ; preds = %"runtime::map_cell_index_dynamic.exit36.i"
  %151 = load i64, ptr %elements_per_cell.i13.i, align 8, !noalias !275
  %152 = udiv i64 %41, %151
  store i64 %152, ptr %cell_index2.i18.i, align 8, !noalias !275
  %153 = load i64, ptr %elements_per_cell.i13.i, align 8, !noalias !275
  %154 = urem i64 %41, %153
  store i64 %154, ptr %data_index3.i19.i, align 8, !noalias !275
  %155 = load ptr, ptr %15, align 8, !noalias !275
  %156 = load i64, ptr %155, align 8
  store i64 %156, ptr %size_of_type4.i20.i, align 8, !noalias !275
  %157 = load i64, ptr %cell_index2.i18.i, align 8, !noalias !275
  %158 = load i64, ptr %size_of_cell.i14.i, align 8, !noalias !275
  %159 = mul i64 %157, %158
  %160 = add i64 %127, %159
  %161 = load i64, ptr %data_index3.i19.i, align 8, !noalias !275
  %162 = load i64, ptr %size_of_type4.i20.i, align 8, !noalias !275
  %163 = mul i64 %161, %162
  %164 = add i64 %160, %163
  call void @llvm.lifetime.end.p0(i64 8, ptr %14)
  call void @llvm.lifetime.end.p0(i64 8, ptr %15)
  call void @llvm.lifetime.end.p0(i64 8, ptr %16)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i13.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i14.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i15.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i16.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i17.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i18.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i19.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i20.i)
  br label %"runtime::map_cell_index_dynamic.exit24.i"

"runtime::map_cell_index_dynamic.exit24.i":       ; preds = %switch.default.body.i23.i, %switch.case.body1.i21.i, %switch.case.body.i22.i
  %165 = phi i64 [ %138, %switch.case.body.i22.i ], [ %150, %switch.case.body1.i21.i ], [ %164, %switch.default.body.i23.i ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  store i64 %165, ptr %5, align 8
  %166 = add i64 %165, 63
  %167 = and i64 %166, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  store i64 %167, ptr %size.i, align 8
  %168 = load i64, ptr %size.i, align 8
  %169 = load ptr, ptr %24, align 8
  %170 = load ptr, ptr %169, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !278)
  call void @llvm.lifetime.start.p0(i64 8, ptr %17)
  call void @llvm.lifetime.start.p0(i64 8, ptr %18)
  call void @llvm.lifetime.start.p0(i64 8, ptr %19)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i1.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i2.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i3.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i4.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i5.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i6.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i7.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i8.i)
  store i64 %168, ptr %17, align 8, !noalias !278
  store ptr %170, ptr %18, align 8, !noalias !278
  store i64 2, ptr %19, align 8, !noalias !278
  %171 = load ptr, ptr %18, align 8, !noalias !278
  %172 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %171, i32 0, i32 3
  %173 = load i64, ptr %172, align 8
  store i64 %173, ptr %elements_per_cell.i1.i, align 8, !noalias !278
  %174 = load ptr, ptr %18, align 8, !noalias !278
  %175 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %174, i32 0, i32 2
  %176 = load i64, ptr %175, align 8
  store i64 %176, ptr %size_of_cell.i2.i, align 8, !noalias !278
  %177 = load i64, ptr %elements_per_cell.i1.i, align 8, !noalias !278
  switch i64 %177, label %switch.default.body.i11.i [
    i64 1, label %switch.case.body.i10.i
    i64 2, label %switch.case.body1.i9.i
  ]

switch.case.body.i10.i:                           ; preds = %"runtime::map_cell_index_dynamic.exit24.i"
  %178 = load i64, ptr %size_of_cell.i2.i, align 8, !noalias !278
  %179 = mul i64 2, %178
  %180 = add i64 %168, %179
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i4.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i5.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i6.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i7.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i8.i)
  br label %"runtime::map_cell_index_dynamic.exit12.i"

switch.case.body1.i9.i:                           ; preds = %"runtime::map_cell_index_dynamic.exit24.i"
  store i64 1, ptr %cell_index.i3.i, align 8, !noalias !278
  store i64 0, ptr %data_index.i4.i, align 8, !noalias !278
  %181 = load ptr, ptr %18, align 8, !noalias !278
  %182 = load i64, ptr %181, align 8
  store i64 %182, ptr %size_of_type.i5.i, align 8, !noalias !278
  %183 = load i64, ptr %cell_index.i3.i, align 8, !noalias !278
  %184 = load i64, ptr %size_of_cell.i2.i, align 8, !noalias !278
  %185 = mul i64 %183, %184
  %186 = add i64 %168, %185
  %187 = load i64, ptr %data_index.i4.i, align 8, !noalias !278
  %188 = load i64, ptr %size_of_type.i5.i, align 8, !noalias !278
  %189 = mul i64 %187, %188
  %190 = add i64 %186, %189
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i4.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i5.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i6.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i7.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i8.i)
  br label %"runtime::map_cell_index_dynamic.exit12.i"

switch.default.body.i11.i:                        ; preds = %"runtime::map_cell_index_dynamic.exit24.i"
  %191 = load i64, ptr %elements_per_cell.i1.i, align 8, !noalias !278
  %192 = udiv i64 2, %191
  store i64 %192, ptr %cell_index2.i6.i, align 8, !noalias !278
  %193 = load i64, ptr %elements_per_cell.i1.i, align 8, !noalias !278
  %194 = urem i64 2, %193
  store i64 %194, ptr %data_index3.i7.i, align 8, !noalias !278
  %195 = load ptr, ptr %18, align 8, !noalias !278
  %196 = load i64, ptr %195, align 8
  store i64 %196, ptr %size_of_type4.i8.i, align 8, !noalias !278
  %197 = load i64, ptr %cell_index2.i6.i, align 8, !noalias !278
  %198 = load i64, ptr %size_of_cell.i2.i, align 8, !noalias !278
  %199 = mul i64 %197, %198
  %200 = add i64 %168, %199
  %201 = load i64, ptr %data_index3.i7.i, align 8, !noalias !278
  %202 = load i64, ptr %size_of_type4.i8.i, align 8, !noalias !278
  %203 = mul i64 %201, %202
  %204 = add i64 %200, %203
  call void @llvm.lifetime.end.p0(i64 8, ptr %17)
  call void @llvm.lifetime.end.p0(i64 8, ptr %18)
  call void @llvm.lifetime.end.p0(i64 8, ptr %19)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i1.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i2.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i3.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i4.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i5.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i6.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i7.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i8.i)
  br label %"runtime::map_cell_index_dynamic.exit12.i"

"runtime::map_cell_index_dynamic.exit12.i":       ; preds = %switch.default.body.i11.i, %switch.case.body1.i9.i, %switch.case.body.i10.i
  %205 = phi i64 [ %180, %switch.case.body.i10.i ], [ %190, %switch.case.body1.i9.i ], [ %204, %switch.default.body.i11.i ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  store i64 %205, ptr %6, align 8
  %206 = add i64 %205, 63
  %207 = and i64 %206, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  store i64 %207, ptr %size.i, align 8
  %208 = load i64, ptr %size.i, align 8
  %209 = load ptr, ptr %24, align 8
  %210 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %209, i32 0, i32 1
  %211 = load ptr, ptr %210, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !281)
  call void @llvm.lifetime.start.p0(i64 8, ptr %20)
  call void @llvm.lifetime.start.p0(i64 8, ptr %21)
  call void @llvm.lifetime.start.p0(i64 8, ptr %22)
  call void @llvm.lifetime.start.p0(i64 8, ptr %elements_per_cell.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_cell.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %cell_index2.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %data_index3.i.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %size_of_type4.i.i)
  store i64 %208, ptr %20, align 8, !noalias !281
  store ptr %211, ptr %21, align 8, !noalias !281
  store i64 2, ptr %22, align 8, !noalias !281
  %212 = load ptr, ptr %21, align 8, !noalias !281
  %213 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %212, i32 0, i32 3
  %214 = load i64, ptr %213, align 8
  store i64 %214, ptr %elements_per_cell.i.i, align 8, !noalias !281
  %215 = load ptr, ptr %21, align 8, !noalias !281
  %216 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %215, i32 0, i32 2
  %217 = load i64, ptr %216, align 8
  store i64 %217, ptr %size_of_cell.i.i, align 8, !noalias !281
  %218 = load i64, ptr %elements_per_cell.i.i, align 8, !noalias !281
  switch i64 %218, label %switch.default.body.i.i [
    i64 1, label %switch.case.body.i.i
    i64 2, label %switch.case.body1.i.i
  ]

switch.case.body.i.i:                             ; preds = %"runtime::map_cell_index_dynamic.exit12.i"
  %219 = load i64, ptr %size_of_cell.i.i, align 8, !noalias !281
  %220 = mul i64 2, %219
  %221 = add i64 %208, %220
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %22)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i.i)
  br label %"runtime::map_total_allocation_size.exit"

switch.case.body1.i.i:                            ; preds = %"runtime::map_cell_index_dynamic.exit12.i"
  store i64 1, ptr %cell_index.i.i, align 8, !noalias !281
  store i64 0, ptr %data_index.i.i, align 8, !noalias !281
  %222 = load ptr, ptr %21, align 8, !noalias !281
  %223 = load i64, ptr %222, align 8
  store i64 %223, ptr %size_of_type.i.i, align 8, !noalias !281
  %224 = load i64, ptr %cell_index.i.i, align 8, !noalias !281
  %225 = load i64, ptr %size_of_cell.i.i, align 8, !noalias !281
  %226 = mul i64 %224, %225
  %227 = add i64 %208, %226
  %228 = load i64, ptr %data_index.i.i, align 8, !noalias !281
  %229 = load i64, ptr %size_of_type.i.i, align 8, !noalias !281
  %230 = mul i64 %228, %229
  %231 = add i64 %227, %230
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %22)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i.i)
  br label %"runtime::map_total_allocation_size.exit"

switch.default.body.i.i:                          ; preds = %"runtime::map_cell_index_dynamic.exit12.i"
  %232 = load i64, ptr %elements_per_cell.i.i, align 8, !noalias !281
  %233 = udiv i64 2, %232
  store i64 %233, ptr %cell_index2.i.i, align 8, !noalias !281
  %234 = load i64, ptr %elements_per_cell.i.i, align 8, !noalias !281
  %235 = urem i64 2, %234
  store i64 %235, ptr %data_index3.i.i, align 8, !noalias !281
  %236 = load ptr, ptr %21, align 8, !noalias !281
  %237 = load i64, ptr %236, align 8
  store i64 %237, ptr %size_of_type4.i.i, align 8, !noalias !281
  %238 = load i64, ptr %cell_index2.i.i, align 8, !noalias !281
  %239 = load i64, ptr %size_of_cell.i.i, align 8, !noalias !281
  %240 = mul i64 %238, %239
  %241 = add i64 %208, %240
  %242 = load i64, ptr %data_index3.i.i, align 8, !noalias !281
  %243 = load i64, ptr %size_of_type4.i.i, align 8, !noalias !281
  %244 = mul i64 %242, %243
  %245 = add i64 %241, %244
  call void @llvm.lifetime.end.p0(i64 8, ptr %20)
  call void @llvm.lifetime.end.p0(i64 8, ptr %21)
  call void @llvm.lifetime.end.p0(i64 8, ptr %22)
  call void @llvm.lifetime.end.p0(i64 8, ptr %elements_per_cell.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_cell.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %cell_index2.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %data_index3.i.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size_of_type4.i.i)
  br label %"runtime::map_total_allocation_size.exit"

"runtime::map_total_allocation_size.exit":        ; preds = %switch.case.body.i.i, %switch.case.body1.i.i, %switch.default.body.i.i
  %246 = phi i64 [ %221, %switch.case.body.i.i ], [ %231, %switch.case.body1.i.i ], [ %245, %switch.default.body.i.i ]
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  store i64 %246, ptr %7, align 8
  %247 = add i64 %246, 63
  %248 = and i64 %247, -64
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  store i64 %248, ptr %size.i, align 8
  %249 = load i64, ptr %size.i, align 8
  call void @llvm.lifetime.end.p0(i64 8, ptr %23)
  call void @llvm.lifetime.end.p0(i64 8, ptr %24)
  call void @llvm.lifetime.end.p0(i64 8, ptr %INFO_HS.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %size.i)
  store i64 %249, ptr %size, align 8
  %250 = load ptr, ptr %ptr, align 8
  %251 = load i64, ptr %size, align 8
  %252 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %0, i32 0, i32 2
  call void @llvm.experimental.noalias.scope.decl(metadata !284)
  call void @llvm.lifetime.start.p0(i64 8, ptr %25)
  call void @llvm.lifetime.start.p0(i64 8, ptr %26)
  call void @llvm.lifetime.start.p0(i64 16, ptr %27)
  call void @llvm.lifetime.start.p0(i64 16, ptr %28)
  call void @llvm.lifetime.start.p0(i64 1, ptr %err.i)
  store ptr %250, ptr %25, align 8, !noalias !284
  store i64 %251, ptr %26, align 8, !noalias !284
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %27, ptr %252, i64 16, i1 false), !noalias !284
  %253 = icmp eq ptr %250, null
  %254 = zext i1 %253 to i8
  br i1 %253, label %if.then.i, label %cmp.or.i

cmp.or.i:                                         ; preds = %"runtime::map_total_allocation_size.exit"
  %255 = load ptr, ptr %27, align 8, !noalias !284
  %256 = icmp eq ptr %255, null
  %257 = zext i1 %256 to i8
  br i1 %256, label %if.then.i, label %if.done.i

if.then.i:                                        ; preds = %cmp.or.i, %"runtime::map_total_allocation_size.exit"
  call void @llvm.lifetime.end.p0(i64 8, ptr %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr %26)
  call void @llvm.lifetime.end.p0(i64 16, ptr %27)
  call void @llvm.lifetime.end.p0(i64 16, ptr %28)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

if.done.i:                                        ; preds = %cmp.or.i
  %258 = load ptr, ptr %27, align 8, !noalias !284
  %259 = getelementptr inbounds nuw %"runtime::Allocator", ptr %27, i32 0, i32 1
  %260 = load ptr, ptr %259, align 8, !noalias !284
  call void @llvm.memset.inline.p0.i64(ptr %28, i8 0, i64 16, i1 false), !noalias !284
  %261 = call i8 %258(ptr %260, i8 1, i64 0, i64 0, ptr %250, i64 %251, ptr %2, ptr %28, ptr nonnull %__.context_ptr)
  store i8 %261, ptr %err.i, align 1, !noalias !284
  %262 = load i8, ptr %err.i, align 1, !noalias !284
  call void @llvm.lifetime.end.p0(i64 8, ptr %25)
  call void @llvm.lifetime.end.p0(i64 8, ptr %26)
  call void @llvm.lifetime.end.p0(i64 16, ptr %27)
  call void @llvm.lifetime.end.p0(i64 16, ptr %28)
  call void @llvm.lifetime.end.p0(i64 1, ptr %err.i)
  br label %"runtime::mem_free_with_size.exit"

"runtime::mem_free_with_size.exit":               ; preds = %if.done.i, %if.then.i
  %263 = phi i8 [ 0, %if.then.i ], [ %262, %if.done.i ]
  store i8 %263, ptr %err, align 1
  %264 = load i8, ptr %err, align 1
  switch i8 %264, label %switch.done [
    i8 0, label %switch.case.body
    i8 4, label %switch.case.body
  ]

switch.case.body:                                 ; preds = %"runtime::mem_free_with_size.exit", %"runtime::mem_free_with_size.exit"
  ret i8 0

switch.done:                                      ; preds = %"runtime::mem_free_with_size.exit"
  %265 = load i8, ptr %err, align 1
  ret i8 %265
}

; Function Attrs: alwaysinline
define i8 @"runtime::_reserve_dynamic_array"(ptr %0, i64 %1, i64 %2, i64 %3, i1 zeroext %4, ptr %5, ptr noalias nocapture nonnull %__.context_ptr) #1 {
decls:
  %6 = alloca ptr, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i8, align 1
  %old_size = alloca i64, align 8
  %new_size = alloca i64, align 8
  %allocator = alloca %"runtime::Allocator", align 8
  %new_data = alloca { ptr, i64 }, align 8
  %11 = alloca { ptr, i64 }, align 8
  %12 = alloca { { ptr, i64 }, i8 }, align 8
  %13 = alloca { ptr, i64 }, align 8
  %14 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %6, align 8
  store i64 %1, ptr %7, align 8
  store i64 %2, ptr %8, align 8
  store i64 %3, ptr %9, align 8
  %15 = zext i1 %4 to i8
  store i8 %15, ptr %10, align 1
  %16 = icmp eq ptr %0, null
  %17 = zext i1 %16 to i8
  %18 = icmp ne i8 %17, 0
  br i1 %18, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %19 = load ptr, ptr %6, align 8
  %20 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %19, i32 0, i32 2
  %21 = load i64, ptr %20, align 8
  %22 = icmp sle i64 %3, %21
  %23 = zext i1 %22 to i8
  %24 = icmp ne i8 %23, 0
  br i1 %24, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  ret i8 0

if.done2:                                         ; preds = %if.done
  %25 = load ptr, ptr %6, align 8
  %26 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %25, i32 0, i32 3
  %27 = getelementptr inbounds nuw %"runtime::Allocator", ptr %26, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = icmp eq ptr %28, null
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %if.then3, label %if.done4

if.then3:                                         ; preds = %if.done2
  %32 = load ptr, ptr %6, align 8
  %33 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %32, i32 0, i32 3
  %34 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %35 = load %"runtime::Allocator", ptr %34, align 8
  store %"runtime::Allocator" %35, ptr %33, align 8
  br label %if.done4

if.done4:                                         ; preds = %if.then3, %if.done2
  %36 = load ptr, ptr %6, align 8
  %37 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %36, i32 0, i32 3
  %38 = getelementptr inbounds nuw %"runtime::Allocator", ptr %37, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = icmp ne ptr %39, null
  %41 = zext i1 %40 to i8
  %42 = icmp ne i8 %41, 0
  call void @"runtime::assert"(i1 zeroext %42, ptr @"ggv$runtime::_reserve_dynamic_array$1", ptr @"scl$[_reserve_dynamic_array28302]", ptr %__.context_ptr)
  %43 = load ptr, ptr %6, align 8
  %44 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %43, i32 0, i32 2
  %45 = load i64, ptr %44, align 8
  %46 = mul i64 %45, %1
  store i64 %46, ptr %old_size, align 8
  %47 = mul i64 %3, %1
  store i64 %47, ptr %new_size, align 8
  %48 = load ptr, ptr %6, align 8
  %49 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %48, i32 0, i32 3
  %50 = load %"runtime::Allocator", ptr %49, align 8
  store %"runtime::Allocator" %50, ptr %allocator, align 8
  call void @llvm.memset.inline.p0.i64(ptr %new_data, i8 0, i64 16, i1 false)
  %51 = icmp ne i8 %15, 0
  br i1 %51, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.done4
  %52 = load ptr, ptr %6, align 8
  %53 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %52, i32 0, i32 0
  %54 = load ptr, ptr %53, align 8
  %55 = load i64, ptr %old_size, align 8
  %56 = load i64, ptr %new_size, align 8
  call void @llvm.memset.inline.p0.i64(ptr %11, i8 0, i64 16, i1 false)
  %57 = call i8 @"runtime::mem_resize"(ptr %54, i64 %55, i64 %56, i64 %2, ptr %allocator, ptr %5, ptr %11, ptr %__.context_ptr)
  %58 = load { ptr, i64 }, ptr %11, align 8
  %59 = icmp eq i8 %57, 0
  br i1 %59, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %if.then5
  ret i8 %57

or_return.continue:                               ; preds = %if.then5
  store { ptr, i64 } %58, ptr %new_data, align 8
  br label %if.done8

if.else:                                          ; preds = %if.done4
  %60 = load ptr, ptr %6, align 8
  %61 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %60, i32 0, i32 0
  %62 = load ptr, ptr %61, align 8
  %63 = load i64, ptr %old_size, align 8
  %64 = load i64, ptr %new_size, align 8
  call void @llvm.memset.inline.p0.i64(ptr %13, i8 0, i64 16, i1 false)
  %65 = call i8 @"runtime::non_zero_mem_resize"(ptr %62, i64 %63, i64 %64, i64 %2, ptr %allocator, ptr %5, ptr %13, ptr %__.context_ptr)
  %66 = load { ptr, i64 }, ptr %13, align 8
  %67 = icmp eq i8 %65, 0
  br i1 %67, label %or_return.continue7, label %or_return.return6

or_return.return6:                                ; preds = %if.else
  ret i8 %65

or_return.continue7:                              ; preds = %if.else
  store { ptr, i64 } %66, ptr %new_data, align 8
  br label %if.done8

if.done8:                                         ; preds = %or_return.continue7, %or_return.continue
  %68 = getelementptr inbounds nuw { ptr, i64 }, ptr %new_data, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  %70 = icmp eq ptr %69, null
  %71 = zext i1 %70 to i8
  %72 = icmp ne i8 %71, 0
  br i1 %72, label %cmp.and, label %if.done10

cmp.and:                                          ; preds = %if.done8
  %73 = load i64, ptr %new_size, align 8
  %74 = icmp sgt i64 %73, 0
  %75 = zext i1 %74 to i8
  %76 = icmp ne i8 %75, 0
  br i1 %76, label %if.then9, label %if.done10

if.then9:                                         ; preds = %cmp.and
  ret i8 1

if.done10:                                        ; preds = %cmp.and, %if.done8
  %77 = load ptr, ptr %6, align 8
  %78 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %77, i32 0, i32 0
  %79 = getelementptr inbounds nuw { ptr, i64 }, ptr %new_data, i32 0, i32 0
  %80 = load ptr, ptr %79, align 8
  store ptr %80, ptr %78, align 8
  %81 = load ptr, ptr %6, align 8
  %82 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %81, i32 0, i32 2
  store i64 %3, ptr %82, align 8
  ret i8 0
}

define half @__truncsfhf2(float %0) {
decls:
  %1 = alloca float, align 4
  %v = alloca { i32 }, align 4
  %i = alloca i32, align 4
  %s = alloca i32, align 4
  %e = alloca i32, align 4
  %m = alloca i32, align 4
  %2 = alloca half, align 16
  %3 = alloca half, align 16
  %4 = alloca half, align 16
  %5 = alloca half, align 16
  %f = alloca i64, align 8
  %j = alloca i64, align 8
  %g = alloca i64, align 8
  %6 = alloca half, align 16
  %7 = alloca half, align 16
  br label %entry

entry:                                            ; preds = %decls
  store float %0, ptr %1, align 4
  call void @llvm.memset.inline.p0.i64(ptr %v, i8 0, i64 4, i1 false)
  store i32 0, ptr %i, align 4
  store i32 0, ptr %s, align 4
  store i32 0, ptr %e, align 4
  store i32 0, ptr %m, align 4
  store float %0, ptr %v, align 4
  %8 = load i32, ptr %v, align 4
  store i32 %8, ptr %i, align 4
  %9 = load i32, ptr %i, align 4
  %10 = ashr i32 %9, 16
  %11 = select i1 true, i32 %10, i32 0
  %12 = and i32 %11, 32768
  store i32 %12, ptr %s, align 4
  %13 = load i32, ptr %i, align 4
  %14 = ashr i32 %13, 23
  %15 = select i1 true, i32 %14, i32 0
  %16 = and i32 %15, 255
  %17 = sub i32 %16, 112
  store i32 %17, ptr %e, align 4
  %18 = load i32, ptr %i, align 4
  %19 = and i32 %18, 8388607
  store i32 %19, ptr %m, align 4
  %20 = load i32, ptr %e, align 4
  %21 = icmp sle i32 %20, 0
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %24 = load i32, ptr %e, align 4
  %25 = icmp slt i32 %24, -10
  %26 = zext i1 %25 to i8
  %27 = icmp ne i8 %26, 0
  br i1 %27, label %if.then1, label %if.done

if.then1:                                         ; preds = %if.then
  %28 = load i32, ptr %s, align 4
  %29 = trunc i32 %28 to i16
  store i16 %29, ptr %2, align 2
  %30 = load half, ptr %2, align 2
  ret half %30

if.done:                                          ; preds = %if.then
  %31 = load i32, ptr %m, align 4
  %32 = or i32 %31, 8388608
  %33 = load i32, ptr %e, align 4
  %34 = sub i32 1, %33
  %35 = icmp ult i32 %34, 32
  %36 = ashr i32 %32, %34
  %37 = select i1 %35, i32 %36, i32 0
  store i32 %37, ptr %m, align 4
  %38 = load i32, ptr %m, align 4
  %39 = and i32 %38, 4096
  %40 = icmp ne i32 %39, 0
  %41 = zext i1 %40 to i8
  %42 = icmp ne i8 %41, 0
  br i1 %42, label %if.then2, label %if.done3

if.then2:                                         ; preds = %if.done
  %43 = load i32, ptr %m, align 4
  %44 = add i32 %43, 8192
  store i32 %44, ptr %m, align 4
  br label %if.done3

if.done3:                                         ; preds = %if.then2, %if.done
  %45 = load i32, ptr %s, align 4
  %46 = load i32, ptr %m, align 4
  %47 = ashr i32 %46, 13
  %48 = select i1 true, i32 %47, i32 0
  %49 = or i32 %45, %48
  %50 = trunc i32 %49 to i16
  store i16 %50, ptr %3, align 2
  %51 = load half, ptr %3, align 2
  ret half %51

if.else:                                          ; preds = %entry
  %52 = load i32, ptr %e, align 4
  %53 = icmp eq i32 %52, 143
  %54 = zext i1 %53 to i8
  %55 = icmp ne i8 %54, 0
  br i1 %55, label %if.then4, label %if.else8

if.then4:                                         ; preds = %if.else
  %56 = load i32, ptr %m, align 4
  %57 = icmp eq i32 %56, 0
  %58 = zext i1 %57 to i8
  %59 = icmp ne i8 %58, 0
  br i1 %59, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.then4
  %60 = load i32, ptr %s, align 4
  %61 = or i32 %60, 31744
  %62 = trunc i32 %61 to i16
  store i16 %62, ptr %4, align 2
  %63 = load half, ptr %4, align 2
  ret half %63

if.else6:                                         ; preds = %if.then4
  %64 = load i32, ptr %m, align 4
  %65 = ashr i32 %64, 13
  %66 = select i1 true, i32 %65, i32 0
  store i32 %66, ptr %m, align 4
  %67 = load i32, ptr %s, align 4
  %68 = or i32 %67, 31744
  %69 = load i32, ptr %m, align 4
  %70 = or i32 %68, %69
  %71 = load i32, ptr %m, align 4
  %72 = icmp eq i32 %71, 0
  %73 = icmp ne i1 %72, false
  %74 = zext i1 %73 to i32
  %75 = or i32 %70, %74
  %76 = trunc i32 %75 to i16
  store i16 %76, ptr %5, align 2
  %77 = load half, ptr %5, align 2
  ret half %77

if.done7:                                         ; No predecessors!
  br label %if.done15

if.else8:                                         ; preds = %if.else
  %78 = load i32, ptr %m, align 4
  %79 = and i32 %78, 4096
  %80 = icmp ne i32 %79, 0
  %81 = zext i1 %80 to i8
  %82 = icmp ne i8 %81, 0
  br i1 %82, label %if.then9, label %if.done12

if.then9:                                         ; preds = %if.else8
  %83 = load i32, ptr %m, align 4
  %84 = add i32 %83, 8192
  store i32 %84, ptr %m, align 4
  %85 = load i32, ptr %m, align 4
  %86 = and i32 %85, 8388608
  %87 = icmp ne i32 %86, 0
  %88 = zext i1 %87 to i8
  %89 = icmp ne i8 %88, 0
  br i1 %89, label %if.then10, label %if.done11

if.then10:                                        ; preds = %if.then9
  store i32 0, ptr %m, align 4
  %90 = load i32, ptr %e, align 4
  %91 = add i32 %90, 1
  store i32 %91, ptr %e, align 4
  br label %if.done11

if.done11:                                        ; preds = %if.then10, %if.then9
  br label %if.done12

if.done12:                                        ; preds = %if.done11, %if.else8
  %92 = load i32, ptr %e, align 4
  %93 = icmp sgt i32 %92, 30
  %94 = zext i1 %93 to i8
  %95 = icmp ne i8 %94, 0
  br i1 %95, label %if.then13, label %if.done14

if.then13:                                        ; preds = %if.done12
  store i64 1000000000000, ptr %f, align 8
  br label %for.init

for.init:                                         ; preds = %if.then13
  store i64 0, ptr %j, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %96 = load i64, ptr %j, align 8
  %97 = icmp slt i64 %96, 10
  %98 = zext i1 %97 to i8
  %99 = icmp ne i8 %98, 0
  br i1 %99, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %100 = load volatile i64, ptr %f, align 8
  store i64 %100, ptr %g, align 8
  %101 = load i64, ptr %g, align 8
  %102 = load i64, ptr %g, align 8
  %103 = mul i64 %102, %101
  store i64 %103, ptr %g, align 8
  %104 = load i64, ptr %g, align 8
  store volatile i64 %104, ptr %f, align 8
  br label %for.post

for.post:                                         ; preds = %for.body
  %105 = load i64, ptr %j, align 8
  %106 = add i64 %105, 1
  store i64 %106, ptr %j, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %107 = load i32, ptr %s, align 4
  %108 = or i32 %107, 31744
  %109 = trunc i32 %108 to i16
  store i16 %109, ptr %6, align 2
  %110 = load half, ptr %6, align 2
  ret half %110

if.done14:                                        ; preds = %if.done12
  %111 = load i32, ptr %s, align 4
  %112 = load i32, ptr %e, align 4
  %113 = shl i32 %112, 10
  %114 = select i1 true, i32 %113, i32 0
  %115 = or i32 %111, %114
  %116 = load i32, ptr %m, align 4
  %117 = ashr i32 %116, 13
  %118 = select i1 true, i32 %117, i32 0
  %119 = or i32 %115, %118
  %120 = trunc i32 %119 to i16
  store i16 %120, ptr %7, align 2
  %121 = load half, ptr %7, align 2
  ret half %121

if.done15:                                        ; preds = %if.done7
  br label %if.done16

if.done16:                                        ; preds = %if.done15
  unreachable
}

; Function Attrs: alwaysinline
define void @"runtime::map_clear_dynamic"(ptr noalias %0, ptr noalias %1) #1 {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca ptr, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = alloca ptr, align 8
  %7 = alloca i64, align 8
  %8 = alloca { i64, i64, ptr, i64, i64 }, align 8
  %hs = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store ptr %1, ptr %3, align 8
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %9, i32 0, i32 0
  %11 = load i64, ptr %10, align 8
  %12 = icmp eq i64 %11, 0
  %13 = zext i1 %12 to i8
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  store i64 0, ptr %4, align 8
  store i64 0, ptr %5, align 8
  store ptr null, ptr %6, align 8
  store i64 0, ptr %7, align 8
  %15 = call i64 @"runtime::map_kvh_data_dynamic"(ptr %0, ptr %1, ptr %4, ptr %5, ptr %6, ptr %7)
  %16 = load ptr, ptr %6, align 8
  store ptr %16, ptr %hs, align 8
  %17 = load ptr, ptr %hs, align 8
  %18 = load i64, ptr %0, align 8
  %19 = icmp eq i64 %18, 0
  %20 = zext i1 %19 to i8
  br i1 %19, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %if.done
  br label %"runtime::map_cap.exit"

if.else.i:                                        ; preds = %if.done
  %21 = load i64, ptr %0, align 8
  %22 = and i64 %21, 63
  %23 = icmp ult i64 %22, 64
  %24 = shl i64 1, %22
  %25 = select i1 %23, i64 %24, i64 0
  br label %"runtime::map_cap.exit"

"runtime::map_cap.exit":                          ; preds = %if.then.i, %if.else.i
  %26 = phi i64 [ 0, %if.then.i ], [ %25, %if.else.i ]
  %27 = mul i64 %26, 8
  call void @llvm.memset.p0.i64(ptr %17, i8 0, i64 %27, i1 false)
  %28 = load ptr, ptr %2, align 8
  %29 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %28, i32 0, i32 1
  store i64 0, ptr %29, align 8
  ret void
}

define half @__truncdfhf2(double %0) {
decls:
  %1 = alloca double, align 8
  br label %entry

entry:                                            ; preds = %decls
  store double %0, ptr %1, align 8
  %2 = fptrunc double %0 to float
  %3 = call half @__truncsfhf2(float %2)
  ret half %3
}

define float @__gnu_h2f_ieee(half %0) {
decls:
  %1 = alloca half, align 2
  %2 = alloca i16, align 16
  %value = alloca i16, align 2
  %v = alloca %"runtime::gnu_h2f_ieee::fp32::$1", align 4
  %magic = alloca %"runtime::gnu_h2f_ieee::fp32::$1", align 4
  %inf_or_nan = alloca %"runtime::gnu_h2f_ieee::fp32::$1", align 4
  br label %entry

entry:                                            ; preds = %decls
  store half %0, ptr %1, align 2
  store half %0, ptr %2, align 2
  %3 = load i16, ptr %2, align 2
  store i16 %3, ptr %value, align 2
  call void @llvm.memset.inline.p0.i64(ptr %v, i8 0, i64 4, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %magic, i8 0, i64 4, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %inf_or_nan, i8 0, i64 4, i1 false)
  store i32 2004877312, ptr %magic, align 4
  store i32 1199570944, ptr %inf_or_nan, align 4
  %4 = load i16, ptr %value, align 2
  %5 = and i16 %4, 32767
  %6 = zext i16 %5 to i32
  %7 = shl i32 %6, 13
  %8 = select i1 true, i32 %7, i32 0
  store i32 %8, ptr %v, align 4
  %9 = load float, ptr %magic, align 4
  %10 = load float, ptr %v, align 4
  %11 = fmul float %10, %9
  store float %11, ptr %v, align 4
  %12 = load float, ptr %v, align 4
  %13 = load float, ptr %inf_or_nan, align 4
  %14 = fcmp oge float %12, %13
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %17 = load i32, ptr %v, align 4
  %18 = or i32 %17, 2139095040
  store i32 %18, ptr %v, align 4
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %19 = load i16, ptr %value, align 2
  %20 = and i16 %19, -32768
  %21 = zext i16 %20 to i32
  %22 = shl i32 %21, 16
  %23 = select i1 true, i32 %22, i32 0
  %24 = load i32, ptr %v, align 4
  %25 = or i32 %24, %23
  store i32 %25, ptr %v, align 4
  %26 = load float, ptr %v, align 4
  ret float %26
}

define half @__gnu_f2h_ieee(float %0) {
decls:
  %1 = alloca float, align 4
  br label %entry

entry:                                            ; preds = %decls
  store float %0, ptr %1, align 4
  %2 = call half @__truncsfhf2(float %0)
  ret half %2
}

define float @__extendhfsf2(half %0) {
decls:
  %1 = alloca half, align 2
  br label %entry

entry:                                            ; preds = %decls
  store half %0, ptr %1, align 2
  %2 = call float @__gnu_h2f_ieee(half %0)
  ret float %2
}

define double @__floattidf(ptr %0) {
decls:
  %a = alloca i128, align 16
  %s = alloca i128, align 16
  %sd = alloca i128, align 16
  %e = alloca i32, align 4
  %fb = alloca [2 x i32], align 4
  br label %entry

entry:                                            ; preds = %decls
  %1 = load i128, ptr %0, align 16
  %2 = icmp eq i128 %1, 0
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret double 0.000000e+00

if.done:                                          ; preds = %entry
  %5 = load i128, ptr %0, align 16
  store i128 %5, ptr %a, align 16
  %6 = load i128, ptr %a, align 16
  %7 = ashr i128 %6, 127
  %8 = select i1 true, i128 %7, i128 0
  store i128 %8, ptr %s, align 16
  %9 = load i128, ptr %a, align 16
  %10 = load i128, ptr %s, align 16
  %11 = xor i128 %9, %10
  %12 = load i128, ptr %s, align 16
  %13 = sub i128 %11, %12
  store i128 %13, ptr %a, align 16
  %14 = load i128, ptr %a, align 16
  %15 = call i128 @llvm.ctlz.i128(i128 %14, i1 false)
  %16 = sub i128 128, %15
  store i128 %16, ptr %sd, align 16
  %17 = load i128, ptr %sd, align 16
  %18 = sub i128 %17, 1
  %19 = trunc i128 %18 to i32
  store i32 %19, ptr %e, align 4
  %20 = load i128, ptr %sd, align 16
  %21 = icmp sgt i128 %20, 53
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.done
  %24 = load i128, ptr %sd, align 16
  switch i128 %24, label %switch.default.body [
    i128 54, label %switch.case.body
    i128 55, label %switch.case.body2
  ]

switch.case.body:                                 ; preds = %if.then1
  %25 = load i128, ptr %a, align 16
  %26 = shl i128 %25, 1
  %27 = select i1 true, i128 %26, i128 0
  store i128 %27, ptr %a, align 16
  br label %switch.done

switch.case.body2:                                ; preds = %if.then1
  br label %switch.done

switch.default.body:                              ; preds = %if.then1
  %28 = load i128, ptr %a, align 16
  %29 = load i128, ptr %sd, align 16
  %30 = sub i128 %29, 55
  %31 = icmp ult i128 %30, 128
  %32 = lshr i128 %28, %30
  %33 = select i1 %31, i128 %32, i128 0
  %34 = load i128, ptr %a, align 16
  %35 = load i128, ptr %sd, align 16
  %36 = sub i128 183, %35
  %37 = icmp ult i128 %36, 128
  %38 = lshr i128 -1, %36
  %39 = select i1 %37, i128 %38, i128 0
  %40 = and i128 %34, %39
  %41 = icmp ne i128 %40, 0
  %42 = icmp ne i1 %41, false
  %43 = zext i1 %42 to i128
  %44 = or i128 %33, %43
  store i128 %44, ptr %a, align 16
  br label %switch.done

switch.done:                                      ; preds = %switch.default.body, %switch.case.body2, %switch.case.body
  %45 = load i128, ptr %a, align 16
  %46 = and i128 %45, 4
  %47 = icmp ne i128 %46, 0
  %48 = icmp ne i1 %47, false
  %49 = zext i1 %48 to i128
  %50 = load i128, ptr %a, align 16
  %51 = or i128 %50, %49
  store i128 %51, ptr %a, align 16
  %52 = load i128, ptr %a, align 16
  %53 = add i128 %52, 1
  store i128 %53, ptr %a, align 16
  %54 = load i128, ptr %a, align 16
  %55 = ashr i128 %54, 2
  %56 = select i1 true, i128 %55, i128 0
  store i128 %56, ptr %a, align 16
  %57 = load i128, ptr %a, align 16
  %58 = and i128 %57, 9007199254740992
  %59 = icmp ne i128 %58, 0
  %60 = zext i1 %59 to i8
  %61 = icmp ne i8 %60, 0
  br i1 %61, label %if.then3, label %if.done4

if.then3:                                         ; preds = %switch.done
  %62 = load i128, ptr %a, align 16
  %63 = ashr i128 %62, 1
  %64 = select i1 true, i128 %63, i128 0
  store i128 %64, ptr %a, align 16
  %65 = load i32, ptr %e, align 4
  %66 = add i32 %65, 1
  store i32 %66, ptr %e, align 4
  br label %if.done4

if.done4:                                         ; preds = %if.then3, %switch.done
  br label %if.done5

if.else:                                          ; preds = %if.done
  %67 = load i128, ptr %sd, align 16
  %68 = sub i128 53, %67
  %69 = and i128 %68, 127
  %70 = load i128, ptr %a, align 16
  %71 = icmp ult i128 %69, 128
  %72 = shl i128 %70, %69
  %73 = select i1 %71, i128 %72, i128 0
  store i128 %73, ptr %a, align 16
  br label %if.done5

if.done5:                                         ; preds = %if.else, %if.done4
  call void @llvm.memset.inline.p0.i64(ptr %fb, i8 0, i64 8, i1 false)
  %74 = getelementptr [2 x i32], ptr %fb, i64 0, i64 1
  %75 = load i128, ptr %s, align 16
  %76 = trunc i128 %75 to i32
  %77 = and i32 %76, -2147483648
  %78 = load i32, ptr %e, align 4
  %79 = add i32 %78, 1023
  %80 = shl i32 %79, 20
  %81 = select i1 true, i32 %80, i32 0
  %82 = or i32 %77, %81
  %83 = load i128, ptr %a, align 16
  %84 = trunc i128 %83 to i64
  %85 = lshr i64 %84, 32
  %86 = select i1 true, i64 %85, i64 0
  %87 = and i64 %86, 1048575
  %88 = trunc i64 %87 to i32
  %89 = or i32 %82, %88
  store i32 %89, ptr %74, align 4
  %90 = getelementptr [2 x i32], ptr %fb, i64 0, i64 0
  %91 = load i128, ptr %a, align 16
  %92 = trunc i128 %91 to i32
  store i32 %92, ptr %90, align 4
  %93 = load double, ptr %fb, align 8
  ret double %93
}

define i16 @"runtime::__dynamic_map_check_grow"(ptr noalias %0, ptr noalias %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca i64, align 8
  %4 = alloca ptr, align 8
  %5 = alloca ptr, align 8
  %err = alloca i8, align 1
  %has_grown = alloca i8, align 1
  %6 = alloca { i8, i8 }, align 2
  %7 = alloca i16, align 16
  %8 = alloca { i8, i8 }, align 2
  %9 = alloca i16, align 16
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %4, align 8
  store ptr %1, ptr %5, align 8
  store i8 0, ptr %err, align 1
  store i8 0, ptr %has_grown, align 1
  %10 = load ptr, ptr %4, align 8
  %11 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %10, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  %13 = load i64, ptr %0, align 8
  %14 = and i64 %13, 63
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  store i64 %14, ptr %3, align 8
  %15 = icmp ult i64 %14, 64
  %16 = shl i64 1, %14
  %17 = select i1 %15, i64 %16, i64 0
  %18 = mul i64 %17, 75
  %19 = udiv i64 %18, 100
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  %20 = icmp uge i64 %12, %19
  %21 = zext i1 %20 to i8
  %22 = icmp ne i8 %21, 0
  br i1 %22, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %23 = call i8 @"runtime::map_grow_dynamic"(ptr %0, ptr %1, ptr %2, ptr %__.context_ptr)
  store i8 %23, ptr %err, align 1
  store i8 1, ptr %has_grown, align 1
  %24 = getelementptr inbounds nuw { i8, i8 }, ptr %6, i32 0, i32 0
  %25 = getelementptr inbounds nuw { i8, i8 }, ptr %6, i32 0, i32 1
  store i8 %23, ptr %24, align 1
  store i8 1, ptr %25, align 1
  %26 = load { i8, i8 }, ptr %6, align 1
  store { i8, i8 } %26, ptr %7, align 1
  %27 = load i16, ptr %7, align 2
  ret i16 %27

if.done:                                          ; preds = %entry
  store i8 0, ptr %err, align 1
  store i8 0, ptr %has_grown, align 1
  %28 = getelementptr inbounds nuw { i8, i8 }, ptr %8, i32 0, i32 0
  %29 = getelementptr inbounds nuw { i8, i8 }, ptr %8, i32 0, i32 1
  store i8 0, ptr %28, align 1
  store i8 0, ptr %29, align 1
  %30 = load { i8, i8 }, ptr %8, align 1
  store { i8, i8 } %30, ptr %9, align 1
  %31 = load i16, ptr %9, align 2
  ret i16 %31
}

define double @__floattidf_unsigned(ptr %0) {
decls:
  %a = alloca i128, align 16
  %sd = alloca i128, align 16
  %e = alloca i32, align 4
  %fb = alloca [2 x i32], align 4
  br label %entry

entry:                                            ; preds = %decls
  %1 = load i128, ptr %0, align 16
  %2 = icmp eq i128 %1, 0
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret double 0.000000e+00

if.done:                                          ; preds = %entry
  %5 = load i128, ptr %0, align 16
  store i128 %5, ptr %a, align 16
  %6 = load i128, ptr %a, align 16
  %7 = call i128 @llvm.ctlz.i128(i128 %6, i1 false)
  %8 = sub i128 128, %7
  store i128 %8, ptr %sd, align 16
  %9 = load i128, ptr %sd, align 16
  %10 = sub i128 %9, 1
  %11 = trunc i128 %10 to i32
  store i32 %11, ptr %e, align 4
  %12 = load i128, ptr %sd, align 16
  %13 = icmp ugt i128 %12, 53
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.done
  %16 = load i128, ptr %sd, align 16
  switch i128 %16, label %switch.default.body [
    i128 54, label %switch.case.body
    i128 55, label %switch.case.body2
  ]

switch.case.body:                                 ; preds = %if.then1
  %17 = load i128, ptr %a, align 16
  %18 = shl i128 %17, 1
  %19 = select i1 true, i128 %18, i128 0
  store i128 %19, ptr %a, align 16
  br label %switch.done

switch.case.body2:                                ; preds = %if.then1
  br label %switch.done

switch.default.body:                              ; preds = %if.then1
  %20 = load i128, ptr %a, align 16
  %21 = load i128, ptr %sd, align 16
  %22 = sub i128 %21, 55
  %23 = icmp ult i128 %22, 128
  %24 = lshr i128 %20, %22
  %25 = select i1 %23, i128 %24, i128 0
  %26 = load i128, ptr %a, align 16
  %27 = load i128, ptr %sd, align 16
  %28 = sub i128 183, %27
  %29 = icmp ult i128 %28, 128
  %30 = lshr i128 -1, %28
  %31 = select i1 %29, i128 %30, i128 0
  %32 = and i128 %26, %31
  %33 = icmp ne i128 %32, 0
  %34 = icmp ne i1 %33, false
  %35 = zext i1 %34 to i128
  %36 = or i128 %25, %35
  store i128 %36, ptr %a, align 16
  br label %switch.done

switch.done:                                      ; preds = %switch.default.body, %switch.case.body2, %switch.case.body
  %37 = load i128, ptr %a, align 16
  %38 = and i128 %37, 4
  %39 = icmp ne i128 %38, 0
  %40 = icmp ne i1 %39, false
  %41 = zext i1 %40 to i128
  %42 = load i128, ptr %a, align 16
  %43 = or i128 %42, %41
  store i128 %43, ptr %a, align 16
  %44 = load i128, ptr %a, align 16
  %45 = add i128 %44, 1
  store i128 %45, ptr %a, align 16
  %46 = load i128, ptr %a, align 16
  %47 = lshr i128 %46, 2
  %48 = select i1 true, i128 %47, i128 0
  store i128 %48, ptr %a, align 16
  %49 = load i128, ptr %a, align 16
  %50 = and i128 %49, 9007199254740992
  %51 = icmp ne i128 %50, 0
  %52 = zext i1 %51 to i8
  %53 = icmp ne i8 %52, 0
  br i1 %53, label %if.then3, label %if.done4

if.then3:                                         ; preds = %switch.done
  %54 = load i128, ptr %a, align 16
  %55 = lshr i128 %54, 1
  %56 = select i1 true, i128 %55, i128 0
  store i128 %56, ptr %a, align 16
  %57 = load i32, ptr %e, align 4
  %58 = add i32 %57, 1
  store i32 %58, ptr %e, align 4
  br label %if.done4

if.done4:                                         ; preds = %if.then3, %switch.done
  br label %if.done5

if.else:                                          ; preds = %if.done
  %59 = load i128, ptr %sd, align 16
  %60 = sub i128 53, %59
  %61 = load i128, ptr %a, align 16
  %62 = icmp ult i128 %60, 128
  %63 = shl i128 %61, %60
  %64 = select i1 %62, i128 %63, i128 0
  store i128 %64, ptr %a, align 16
  br label %if.done5

if.done5:                                         ; preds = %if.else, %if.done4
  call void @llvm.memset.inline.p0.i64(ptr %fb, i8 0, i64 8, i1 false)
  %65 = getelementptr [2 x i32], ptr %fb, i64 0, i64 1
  %66 = load i32, ptr %e, align 4
  %67 = add i32 %66, 1023
  %68 = shl i32 %67, 20
  %69 = select i1 true, i32 %68, i32 0
  %70 = or i32 0, %69
  %71 = load i128, ptr %a, align 16
  %72 = trunc i128 %71 to i64
  %73 = lshr i64 %72, 32
  %74 = select i1 true, i64 %73, i64 0
  %75 = and i64 %74, 1048575
  %76 = trunc i64 %75 to i32
  %77 = or i32 %70, %76
  store i32 %77, ptr %65, align 4
  %78 = getelementptr [2 x i32], ptr %fb, i64 0, i64 0
  %79 = load i128, ptr %a, align 16
  %80 = trunc i128 %79 to i32
  store i32 %80, ptr %78, align 4
  %81 = load double, ptr %fb, align 8
  ret double %81
}

define <2 x i64> @__umodti3(ptr %0, ptr %1) {
decls:
  %r = alloca i128, align 16
  %2 = alloca i128, align 16
  %3 = alloca i128, align 16
  %4 = alloca i128, align 16
  %5 = alloca <2 x i64>, align 16
  br label %entry

entry:                                            ; preds = %decls
  %6 = load i128, ptr %0, align 16
  %7 = load i128, ptr %1, align 16
  store i128 %6, ptr %2, align 16
  store i128 %7, ptr %3, align 16
  %8 = call <2 x i64> @"runtime::udivmod128"(ptr %2, ptr %3, ptr %r)
  store <2 x i64> %8, ptr %4, align 16
  %9 = load i128, ptr %r, align 16
  store i128 %9, ptr %5, align 16
  %10 = load <2 x i64>, ptr %5, align 16
  ret <2 x i64> %10
}

define <2 x i64> @__udivmodti4(ptr %0, ptr %1, ptr %2) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca i128, align 16
  %5 = alloca i128, align 16
  %6 = alloca i128, align 16
  %7 = alloca <2 x i64>, align 16
  br label %entry

entry:                                            ; preds = %decls
  store ptr %2, ptr %3, align 8
  %8 = load i128, ptr %0, align 16
  %9 = load i128, ptr %1, align 16
  store i128 %8, ptr %4, align 16
  store i128 %9, ptr %5, align 16
  %10 = call <2 x i64> @"runtime::udivmod128"(ptr %4, ptr %5, ptr %2)
  store <2 x i64> %10, ptr %6, align 16
  %11 = load i128, ptr %6, align 16
  store i128 %11, ptr %7, align 16
  %12 = load <2 x i64>, ptr %7, align 16
  ret <2 x i64> %12
}

define <2 x i64> @__udivti3(ptr %0, ptr %1) {
decls:
  %2 = alloca i128, align 16
  %3 = alloca i128, align 16
  %4 = alloca i128, align 16
  %5 = alloca <2 x i64>, align 16
  br label %entry

entry:                                            ; preds = %decls
  %6 = load i128, ptr %0, align 16
  %7 = load i128, ptr %1, align 16
  store i128 %6, ptr %2, align 16
  store i128 %7, ptr %3, align 16
  %8 = call <2 x i64> @__udivmodti4(ptr %2, ptr %3, ptr null)
  store <2 x i64> %8, ptr %4, align 16
  %9 = load i128, ptr %4, align 16
  store i128 %9, ptr %5, align 16
  %10 = load <2 x i64>, ptr %5, align 16
  ret <2 x i64> %10
}

define void @"runtime::assert"(i1 zeroext %0, ptr %1, ptr %2, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %3 = alloca i8, align 1
  %4 = alloca %..string, align 8
  br label %entry

entry:                                            ; preds = %decls
  %5 = zext i1 %0 to i8
  store i8 %5, ptr %3, align 1
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %1, i64 16, i1 false)
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.done, label %if.then

if.then:                                          ; preds = %entry
  call void @"runtime::assert.internal-0"(ptr %4, ptr %2, ptr %__.context_ptr)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noreturn
define void @"runtime::panic"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) #0 {
decls:
  %2 = alloca %..string, align 8
  %p = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 16, i1 false)
  %3 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 2
  %4 = load ptr, ptr %3, align 8
  store ptr %4, ptr %p, align 8
  %5 = load ptr, ptr %p, align 8
  %6 = icmp eq ptr %5, null
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store ptr @"runtime::default_assertion_failure_proc", ptr %p, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %9 = load ptr, ptr %p, align 8
  call void %9(ptr @"ggv$runtime::panic$1", ptr %2, ptr %1, ptr %__.context_ptr)
  unreachable
}

; Function Attrs: alwaysinline
define i64 @"runtime::default_hasher"(ptr %0, i64 %1, i64 %2) #1 {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %h = alloca i64, align 8
  %p = alloca ptr, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store i64 %1, ptr %4, align 8
  store i64 %2, ptr %5, align 8
  %9 = add i64 %1, -3750763034362895579
  store i64 %9, ptr %h, align 8
  store ptr %0, ptr %p, align 8
  store i64 0, ptr %6, align 8
  store i64 0, ptr %7, align 8
  br label %for.interval.loop

for.interval.loop:                                ; preds = %for.interval.post, %entry
  %10 = load i64, ptr %6, align 8
  %11 = icmp slt i64 %10, %2
  br i1 %11, label %for.interval.body, label %for.interval.done

for.interval.body:                                ; preds = %for.interval.loop
  %12 = load i64, ptr %h, align 8
  %13 = load ptr, ptr %p, align 8
  %14 = getelementptr i8, ptr %13, i64 0
  %15 = load i8, ptr %14, align 1
  %16 = zext i8 %15 to i64
  %17 = xor i64 %12, %16
  %18 = mul i64 %17, 1099511628211
  store i64 %18, ptr %h, align 8
  %19 = load ptr, ptr %p, align 8
  %20 = getelementptr i8, ptr %19, i64 1
  store ptr %20, ptr %8, align 8
  %21 = load ptr, ptr %8, align 8
  store ptr %21, ptr %p, align 8
  br label %for.interval.post

for.interval.post:                                ; preds = %for.interval.body
  %22 = load i64, ptr %6, align 8
  %23 = add i64 %22, 1
  store i64 %23, ptr %6, align 8
  %24 = load i64, ptr %7, align 8
  %25 = add i64 %24, 1
  store i64 %25, ptr %7, align 8
  br label %for.interval.loop

for.interval.done:                                ; preds = %for.interval.loop
  %26 = load i64, ptr %h, align 8
  %27 = and i64 %26, 9223372036854775807
  store i64 %27, ptr %h, align 8
  %28 = load i64, ptr %h, align 8
  %29 = load i64, ptr %h, align 8
  %30 = icmp eq i64 %29, 0
  %31 = icmp ne i1 %30, false
  %32 = zext i1 %31 to i64
  %33 = or i64 %28, %32
  ret i64 %33
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.inline.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #4

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.cttz.i64(i64, i1 immarg) #5

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.ctlz.i64(i64, i1 immarg) #5

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #6

define i8 @"runtime::heap_allocator_proc.aligned_alloc-0"(i64 %0, i64 %1, ptr %2, i64 %3, i1 zeroext %4, ptr noalias nonnull %5, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %6 = alloca ptr, align 8
  %7 = alloca i64, align 8
  %8 = alloca ptr, align 8
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i64, align 8
  %14 = alloca i8, align 1
  %a = alloca i64, align 8
  %space = alloca i64, align 8
  %allocated_mem = alloca ptr, align 8
  %force_copy = alloca i8, align 1
  %original_old_ptr = alloca ptr, align 8
  %15 = alloca ptr, align 8
  %aligned_mem = alloca ptr, align 8
  %ptr = alloca i64, align 8
  %aligned_ptr = alloca i64, align 8
  %16 = alloca { ptr, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %10, align 8
  store i64 %1, ptr %11, align 8
  store ptr %2, ptr %12, align 8
  store i64 %3, ptr %13, align 8
  %17 = zext i1 %4 to i8
  store i8 %17, ptr %14, align 1
  %18 = icmp sgt i64 %1, 8
  %19 = select i1 %18, i64 %1, i64 8
  store i64 %19, ptr %a, align 8
  %20 = load i64, ptr %a, align 8
  %21 = sub i64 %20, 1
  %22 = add i64 %21, 8
  %23 = add i64 %22, %0
  store i64 %23, ptr %space, align 8
  store ptr null, ptr %allocated_mem, align 8
  %24 = icmp ne ptr %2, null
  %25 = zext i1 %24 to i8
  %26 = icmp ne i8 %25, 0
  br i1 %26, label %logical.cmp.rhs, label %logical.cmp.done

logical.cmp.rhs:                                  ; preds = %entry
  %27 = icmp sgt i64 %1, 8
  %28 = zext i1 %27 to i8
  %29 = icmp ne i8 %28, 0
  br label %logical.cmp.done

logical.cmp.done:                                 ; preds = %logical.cmp.rhs, %entry
  %30 = phi i1 [ false, %entry ], [ %29, %logical.cmp.rhs ]
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %force_copy, align 1
  %32 = icmp ne ptr %2, null
  %33 = zext i1 %32 to i8
  %34 = icmp ne i8 %33, 0
  br i1 %34, label %cmp.and, label %if.else

cmp.and:                                          ; preds = %logical.cmp.done
  %35 = load i8, ptr %force_copy, align 1
  %36 = icmp ne i8 %35, 0
  br i1 %36, label %if.else, label %if.then

if.then:                                          ; preds = %cmp.and
  %37 = getelementptr ptr, ptr %2, i64 -1
  %38 = load ptr, ptr %37, align 8
  store ptr %38, ptr %original_old_ptr, align 8
  %39 = load ptr, ptr %original_old_ptr, align 8
  %40 = load i64, ptr %space, align 8
  %41 = call ptr @"runtime::heap_resize"(ptr %39, i64 %40)
  store ptr %41, ptr %allocated_mem, align 8
  br label %if.done

if.else:                                          ; preds = %cmp.and, %logical.cmp.done
  %42 = load i64, ptr %space, align 8
  %43 = icmp ne i8 %17, 0
  %44 = call ptr @"runtime::heap_alloc"(i64 %42, i1 zeroext %43)
  store ptr %44, ptr %allocated_mem, align 8
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  %45 = load ptr, ptr %allocated_mem, align 8
  %46 = getelementptr i8, ptr %45, i64 8
  store ptr %46, ptr %15, align 8
  %47 = load ptr, ptr %15, align 8
  store ptr %47, ptr %aligned_mem, align 8
  %48 = load ptr, ptr %aligned_mem, align 8
  %49 = ptrtoint ptr %48 to i64
  store i64 %49, ptr %ptr, align 8
  %50 = load i64, ptr %ptr, align 8
  %51 = load i64, ptr %a, align 8
  %52 = add i64 %50, %51
  %53 = sub i64 %52, 1
  %54 = load i64, ptr %a, align 8
  %55 = sub i64 %54, 1
  %56 = xor i64 %55, -1
  %57 = and i64 %53, %56
  store i64 %57, ptr %aligned_ptr, align 8
  %58 = load ptr, ptr %allocated_mem, align 8
  %59 = icmp eq ptr %58, null
  %60 = zext i1 %59 to i8
  %61 = icmp ne i8 %60, 0
  br i1 %61, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  call void @"runtime::heap_allocator_proc.aligned_free-1"(ptr %2, ptr %__.context_ptr)
  %62 = load ptr, ptr %allocated_mem, align 8
  call void @"runtime::heap_allocator_proc.aligned_free-1"(ptr %62, ptr %__.context_ptr)
  store { ptr, i64 } zeroinitializer, ptr %5, align 8
  ret i8 1

if.done2:                                         ; preds = %if.done
  %63 = load i64, ptr %aligned_ptr, align 8
  %64 = inttoptr i64 %63 to ptr
  store ptr %64, ptr %aligned_mem, align 8
  %65 = load ptr, ptr %aligned_mem, align 8
  %66 = getelementptr ptr, ptr %65, i64 -1
  %67 = load ptr, ptr %allocated_mem, align 8
  store ptr %67, ptr %66, align 8
  %68 = load i8, ptr %force_copy, align 1
  %69 = icmp ne i8 %68, 0
  br i1 %69, label %if.then3, label %if.done4

if.then3:                                         ; preds = %if.done2
  %70 = load ptr, ptr %aligned_mem, align 8
  %71 = icmp slt i64 %3, %0
  %72 = select i1 %71, i64 %3, i64 %0
  %73 = call ptr @"runtime::mem_copy_non_overlapping"(ptr %70, ptr %2, i64 %72)
  call void @"runtime::heap_allocator_proc.aligned_free-1"(ptr %2, ptr %__.context_ptr)
  br label %if.done4

if.done4:                                         ; preds = %if.then3, %if.done2
  %74 = load ptr, ptr %aligned_mem, align 8
  call void @llvm.memset.inline.p0.i64(ptr %16, i8 0, i64 16, i1 false)
  call void @llvm.experimental.noalias.scope.decl(metadata !287)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  call void @llvm.lifetime.start.p0(i64 8, ptr %8)
  call void @llvm.lifetime.start.p0(i64 16, ptr %9)
  store ptr %74, ptr %6, align 8, !noalias !287
  store i64 %0, ptr %7, align 8, !noalias !287
  store ptr %74, ptr %8, align 8, !noalias !287
  %75 = load ptr, ptr %8, align 8, !noalias !287
  %76 = icmp sgt i64 %0, 0
  %77 = select i1 %76, i64 %0, i64 0
  %78 = getelementptr inbounds nuw { ptr, i64 }, ptr %9, i32 0, i32 1
  store ptr %75, ptr %9, align 8, !noalias !287
  store i64 %77, ptr %78, align 8, !noalias !287
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %16, ptr %9, i64 16, i1 false)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  call void @llvm.lifetime.end.p0(i64 8, ptr %8)
  call void @llvm.lifetime.end.p0(i64 16, ptr %9)
  %79 = load { ptr, i64 }, ptr %16, align 8
  store { ptr, i64 } %79, ptr %5, align 8
  ret i8 0
}

define void @"runtime::heap_allocator_proc.aligned_free-1"(ptr %0, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = icmp ne ptr %0, null
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %5 = getelementptr ptr, ptr %0, i64 -1
  %6 = load ptr, ptr %5, align 8
  call void @"runtime::heap_free"(ptr %6)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  ret void
}

define i8 @"runtime::heap_allocator_proc.aligned_resize-2"(ptr %0, i64 %1, i64 %2, i64 %3, i1 zeroext %4, ptr noalias nonnull %5, ptr noalias nocapture nonnull %__.context_ptr) {
decls:
  %6 = alloca ptr, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i8, align 1
  %new_memory = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %11 = alloca { ptr, i64 }, align 8
  %12 = alloca { { ptr, i64 }, i8 }, align 8
  %13 = alloca { ptr, i64 }, align 8
  %14 = alloca { { ptr, i64 }, i8 }, align 8
  %15 = alloca { ptr, i64 }, align 8
  %new_region = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %6, align 8
  store i64 %1, ptr %7, align 8
  store i64 %2, ptr %8, align 8
  store i64 %3, ptr %9, align 8
  %16 = zext i1 %4 to i8
  store i8 %16, ptr %10, align 1
  call void @llvm.memset.inline.p0.i64(ptr %new_memory, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %17 = icmp eq ptr %0, null
  %18 = zext i1 %17 to i8
  %19 = icmp ne i8 %18, 0
  br i1 %19, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %20 = icmp ne i8 %16, 0
  call void @llvm.memset.inline.p0.i64(ptr %11, i8 0, i64 16, i1 false)
  %21 = call i8 @"runtime::heap_allocator_proc.aligned_alloc-0"(i64 %2, i64 %3, ptr null, i64 %1, i1 zeroext %20, ptr %11, ptr %__.context_ptr)
  %22 = load { ptr, i64 }, ptr %11, align 8
  store { ptr, i64 } %22, ptr %new_memory, align 8
  store i8 %21, ptr %err, align 1
  store { ptr, i64 } %22, ptr %5, align 8
  ret i8 %21

if.done:                                          ; preds = %entry
  %23 = icmp ne i8 %16, 0
  call void @llvm.memset.inline.p0.i64(ptr %13, i8 0, i64 16, i1 false)
  %24 = call i8 @"runtime::heap_allocator_proc.aligned_alloc-0"(i64 %2, i64 %3, ptr %0, i64 %1, i1 zeroext %23, ptr %13, ptr %__.context_ptr)
  %25 = load { ptr, i64 }, ptr %13, align 8
  %26 = icmp eq i8 %24, 0
  br i1 %26, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %if.done
  store i8 %24, ptr %err, align 1
  %27 = load { ptr, i64 }, ptr %new_memory, align 8
  %28 = load i8, ptr %err, align 1
  store { ptr, i64 } %27, ptr %new_memory, align 8
  store i8 %28, ptr %err, align 1
  store { ptr, i64 } %27, ptr %5, align 8
  ret i8 %28

or_return.continue:                               ; preds = %if.done
  store { ptr, i64 } %25, ptr %new_memory, align 8
  %29 = icmp ne i8 %16, 0
  br i1 %29, label %cmp.and, label %if.done2

cmp.and:                                          ; preds = %or_return.continue
  %30 = icmp sgt i64 %2, %1
  %31 = zext i1 %30 to i8
  %32 = icmp ne i8 %31, 0
  br i1 %32, label %if.then1, label %if.done2

if.then1:                                         ; preds = %cmp.and
  %33 = getelementptr inbounds nuw { ptr, i64 }, ptr %new_memory, i32 0, i32 1
  %34 = load i64, ptr %33, align 8
  call void @"runtime::slice_expr_error_lo_hi"(ptr @"ggv$runtime::heap_allocator_proc.aligned_resize-2$1", i32 75, i32 37, i64 %1, i64 %34, i64 %34)
  %35 = getelementptr inbounds nuw { ptr, i64 }, ptr %new_memory, i32 0, i32 0
  %36 = load ptr, ptr %35, align 8
  %37 = getelementptr i8, ptr %36, i64 %1
  %38 = sub i64 %34, %1
  %39 = getelementptr inbounds nuw { ptr, i64 }, ptr %15, i32 0, i32 0
  store ptr %37, ptr %39, align 8
  %40 = getelementptr inbounds nuw { ptr, i64 }, ptr %15, i32 0, i32 1
  store i64 %38, ptr %40, align 8
  %41 = getelementptr inbounds nuw { ptr, i64 }, ptr %15, i32 0, i32 0
  %42 = load ptr, ptr %41, align 8
  store ptr %42, ptr %new_region, align 8
  %43 = load ptr, ptr %new_region, align 8
  %44 = sub i64 %2, %1
  call void @llvm.memset.p0.i64(ptr %43, i8 0, i64 %44, i1 false)
  br label %if.done2

if.done2:                                         ; preds = %if.then1, %cmp.and, %or_return.continue
  %45 = load { ptr, i64 }, ptr %new_memory, align 8
  %46 = load i8, ptr %err, align 1
  store { ptr, i64 } %45, ptr %new_memory, align 8
  store i8 %46, ptr %err, align 1
  store { ptr, i64 } %45, ptr %5, align 8
  ret i8 %46
}

; Function Attrs: cold noreturn
define void @"runtime::bounds_check_error.handle_error-0"(ptr %0, i32 %1, i32 %2, i64 %3, i64 %4) #7 {
decls:
  %5 = alloca %..string, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca %"runtime::Source_Code_Location", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %0, i64 16, i1 false)
  store i32 %1, ptr %6, align 4
  store i32 %2, ptr %7, align 4
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  call void @llvm.memset.p0.i64(ptr %10, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %10, i8 0, i64 40, i1 false)
  %11 = load %..string, ptr %5, align 8
  %12 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %10, i32 0, i32 0
  store %..string %11, ptr %12, align 8
  %13 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %10, i32 0, i32 1
  store i32 %1, ptr %13, align 4
  %14 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %10, i32 0, i32 2
  store i32 %2, ptr %14, align 4
  call void @"runtime::print_caller_location"(ptr %10)
  %15 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::bounds_check_error.handle_error-0$1")
  call void @"runtime::print_i64"(i64 %3)
  %16 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::bounds_check_error.handle_error-0$2")
  call void @"runtime::print_i64"(i64 %4)
  %17 = call i64 @"runtime::print_byte"(i8 10)
  call void @"runtime::bounds_trap"()
  unreachable
}

declare void @"sanitizer::address_unpoison_rawptr"(ptr, i64)

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i64, i1 } @llvm.uadd.with.overflow.i64(i64, i64) #5

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #4

define i64 @"runtime::default_random_generator_proc.read_u64-0"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %old_state = alloca i64, align 8
  %xor_shifted = alloca i64, align 8
  %rot = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = getelementptr inbounds nuw %"runtime::Default_Random_State", ptr %2, i32 0, i32 0
  %4 = load i64, ptr %3, align 8
  store i64 %4, ptr %old_state, align 8
  %5 = load ptr, ptr %1, align 8
  %6 = getelementptr inbounds nuw %"runtime::Default_Random_State", ptr %5, i32 0, i32 0
  %7 = load i64, ptr %old_state, align 8
  %8 = mul i64 %7, 6364136223846793005
  %9 = load ptr, ptr %1, align 8
  %10 = getelementptr inbounds nuw %"runtime::Default_Random_State", ptr %9, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = or i64 %11, 1
  %13 = add i64 %8, %12
  store i64 %13, ptr %6, align 8
  %14 = load i64, ptr %old_state, align 8
  %15 = lshr i64 %14, 59
  %16 = select i1 true, i64 %15, i64 0
  %17 = add i64 %16, 5
  %18 = load i64, ptr %old_state, align 8
  %19 = xor i64 %17, %18
  %20 = mul i64 %19, -5840758589994634535
  store i64 %20, ptr %xor_shifted, align 8
  %21 = load i64, ptr %old_state, align 8
  %22 = lshr i64 %21, 59
  %23 = select i1 true, i64 %22, i64 0
  store i64 %23, ptr %rot, align 8
  %24 = load i64, ptr %xor_shifted, align 8
  %25 = load i64, ptr %rot, align 8
  %26 = icmp ult i64 %25, 64
  %27 = lshr i64 %24, %25
  %28 = select i1 %26, i64 %27, i64 0
  %29 = load i64, ptr %xor_shifted, align 8
  %30 = load i64, ptr %rot, align 8
  %31 = sub i64 0, %30
  %32 = and i64 %31, 63
  %33 = icmp ult i64 %32, 64
  %34 = shl i64 %29, %32
  %35 = select i1 %33, i64 %34, i64 0
  %36 = or i64 %28, %35
  ret i64 %36
}

define void @"runtime::default_random_generator_proc.init-1"(ptr %0, i64 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %seed = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  store i64 %1, ptr %seed, align 8
  %4 = load i64, ptr %seed, align 8
  %5 = icmp eq i64 %4, 0
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %8 = call i64 @llvm.readcyclecounter()
  store i64 %8, ptr %seed, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr inbounds nuw %"runtime::Default_Random_State", ptr %9, i32 0, i32 0
  store i64 0, ptr %10, align 8
  %11 = load ptr, ptr %2, align 8
  %12 = getelementptr inbounds nuw %"runtime::Default_Random_State", ptr %11, i32 0, i32 1
  %13 = load i64, ptr %seed, align 8
  %14 = shl i64 %13, 1
  %15 = select i1 true, i64 %14, i64 0
  %16 = or i64 %15, 1
  store i64 %16, ptr %12, align 8
  %17 = call i64 @"runtime::default_random_generator_proc.read_u64-0"(ptr %0)
  %18 = load ptr, ptr %2, align 8
  %19 = getelementptr inbounds nuw %"runtime::Default_Random_State", ptr %18, i32 0, i32 0
  %20 = load i64, ptr %seed, align 8
  %21 = load i64, ptr %19, align 8
  %22 = add i64 %21, %20
  store i64 %22, ptr %19, align 8
  %23 = call i64 @"runtime::default_random_generator_proc.read_u64-0"(ptr %0)
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #6

declare void @"main::main"(ptr noalias nocapture nonnull)

define i64 @"runtime::alloc_from_memory_block.calc_alignment_offset-0"(ptr %0, i64 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %alignment_offset = alloca i64, align 8
  %4 = alloca ptr, align 8
  %ptr = alloca i64, align 8
  %mask = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  store i64 0, ptr %alignment_offset, align 8
  %5 = load ptr, ptr %2, align 8
  %6 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %5, i32 0, i32 2
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %2, align 8
  %9 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %8, i32 0, i32 3
  %10 = load i64, ptr %9, align 8
  %11 = getelementptr i8, ptr %7, i64 %10
  store ptr %11, ptr %4, align 8
  %12 = load ptr, ptr %4, align 8
  %13 = ptrtoint ptr %12 to i64
  store i64 %13, ptr %ptr, align 8
  %14 = sub i64 %1, 1
  store i64 %14, ptr %mask, align 8
  %15 = load i64, ptr %ptr, align 8
  %16 = load i64, ptr %mask, align 8
  %17 = and i64 %15, %16
  %18 = icmp ne i64 %17, 0
  %19 = zext i1 %18 to i8
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %21 = load i64, ptr %ptr, align 8
  %22 = load i64, ptr %mask, align 8
  %23 = and i64 %21, %22
  %24 = sub i64 %1, %23
  store i64 %24, ptr %alignment_offset, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %25 = load i64, ptr %alignment_offset, align 8
  ret i64 %25
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #6

define i64 @"runtime::arena_alloc.align_forward_uint-0"(i64 %0, i64 %1) {
decls:
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %p = alloca i64, align 8
  %modulo = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  store i64 %0, ptr %p, align 8
  %4 = load i64, ptr %p, align 8
  %5 = sub i64 %1, 1
  %6 = and i64 %4, %5
  store i64 %6, ptr %modulo, align 8
  %7 = load i64, ptr %modulo, align 8
  %8 = icmp ne i64 %7, 0
  %9 = zext i1 %8 to i8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %11 = load i64, ptr %modulo, align 8
  %12 = sub i64 %1, %11
  %13 = load i64, ptr %p, align 8
  %14 = add i64 %13, %12
  store i64 %14, ptr %p, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %15 = load i64, ptr %p, align 8
  ret i64 %15
}

; Function Attrs: cold noreturn
define void @"runtime::matrix_bounds_check_error.handle_error-0"(ptr %0, i32 %1, i32 %2, i64 %3, i64 %4, i64 %5, i64 %6) #7 {
decls:
  %7 = alloca %..string, align 8
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca %"runtime::Source_Code_Location", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %0, i64 16, i1 false)
  store i32 %1, ptr %8, align 4
  store i32 %2, ptr %9, align 4
  store i64 %3, ptr %10, align 8
  store i64 %4, ptr %11, align 8
  store i64 %5, ptr %12, align 8
  store i64 %6, ptr %13, align 8
  call void @llvm.memset.p0.i64(ptr %14, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %14, i8 0, i64 40, i1 false)
  %15 = load %..string, ptr %7, align 8
  %16 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %14, i32 0, i32 0
  store %..string %15, ptr %16, align 8
  %17 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %14, i32 0, i32 1
  store i32 %1, ptr %17, align 4
  %18 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %14, i32 0, i32 2
  store i32 %2, ptr %18, align 4
  call void @"runtime::print_caller_location"(ptr %14)
  %19 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::matrix_bounds_check_error.handle_error-0$1")
  call void @"runtime::print_i64"(i64 %3)
  %20 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::matrix_bounds_check_error.handle_error-0$2")
  call void @"runtime::print_i64"(i64 %4)
  %21 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::matrix_bounds_check_error.handle_error-0$3")
  call void @"runtime::print_i64"(i64 %5)
  %22 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::matrix_bounds_check_error.handle_error-0$4")
  call void @"runtime::print_i64"(i64 %6)
  %23 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::matrix_bounds_check_error.handle_error-0$5")
  %24 = call i64 @"runtime::print_byte"(i8 10)
  call void @"runtime::bounds_trap"()
  unreachable
}

; Function Attrs: cold noreturn
define void @"runtime::type_assertion_check.handle_error-0"(ptr %0, i32 %1, i32 %2, i64 %3, i64 %4) #7 {
decls:
  %5 = alloca %..string, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca %"runtime::Source_Code_Location", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %0, i64 16, i1 false)
  store i32 %1, ptr %6, align 4
  store i32 %2, ptr %7, align 4
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  call void @llvm.memset.p0.i64(ptr %10, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %10, i8 0, i64 40, i1 false)
  %11 = load %..string, ptr %5, align 8
  %12 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %10, i32 0, i32 0
  store %..string %11, ptr %12, align 8
  %13 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %10, i32 0, i32 1
  store i32 %1, ptr %13, align 4
  %14 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %10, i32 0, i32 2
  store i32 %2, ptr %14, align 4
  call void @"runtime::print_caller_location"(ptr %10)
  %15 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::type_assertion_check.handle_error-0$1")
  call void @"runtime::print_typeid"(i64 %3)
  %16 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::type_assertion_check.handle_error-0$2")
  call void @"runtime::print_typeid"(i64 %4)
  %17 = call i64 @"runtime::print_byte"(i8 10)
  call void @"runtime::type_assertion_trap"()
  unreachable
}

define i64 @"runtime::type_assertion_check2.variant_type-0"(i64 %0, ptr %1) {
decls:
  %2 = alloca i64, align 8
  %3 = alloca ptr, align 8
  %ti = alloca ptr, align 8
  %4 = alloca [48 x i8], align 8
  %5 = alloca ptr, align 8
  %tag_ptr = alloca i64, align 8
  %idx = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  store ptr %1, ptr %3, align 8
  %6 = icmp eq i64 %0, 0
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %9 = icmp eq ptr %1, null
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  ret i64 %0

if.done:                                          ; preds = %cmp.or
  %12 = call ptr @"runtime::__type_info_of"(i64 %0)
  %13 = call ptr @"runtime::type_info_base"(ptr %12)
  store ptr %13, ptr %ti, align 8
  %14 = load ptr, ptr %ti, align 8
  %15 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %14, i32 0, i32 5
  %16 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %15, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  switch i64 %17, label %typeswitch.done [
    i64 9, label %typeswitch.body
    i64 20, label %typeswitch.body1
  ]

typeswitch.body:                                  ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %15, i64 0, i1 false)
  store ptr %1, ptr %5, align 8
  %18 = load ptr, ptr %5, align 8
  %19 = getelementptr inbounds nuw %..any, ptr %18, i32 0, i32 1
  %20 = load i64, ptr %19, align 8
  ret i64 %20

typeswitch.body1:                                 ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %4, ptr %15, i64 48, i1 false)
  %21 = ptrtoint ptr %1 to i64
  %22 = getelementptr inbounds nuw %"runtime::Type_Info_Union", ptr %4, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  %24 = add i64 %21, %23
  store i64 %24, ptr %tag_ptr, align 8
  store i64 0, ptr %idx, align 8
  %25 = getelementptr inbounds nuw %"runtime::Type_Info_Union", ptr %4, i32 0, i32 2
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %26, i32 0, i32 0
  %28 = load i64, ptr %27, align 8
  switch i64 %28, label %switch.done [
    i64 1, label %switch.case.body
    i64 2, label %switch.case.body2
    i64 4, label %switch.case.body3
    i64 8, label %switch.case.body4
    i64 16, label %switch.case.body5
  ]

switch.case.body:                                 ; preds = %typeswitch.body1
  %29 = load i64, ptr %tag_ptr, align 8
  %30 = inttoptr i64 %29 to ptr
  %31 = load i8, ptr %30, align 1
  %32 = zext i8 %31 to i64
  %33 = sub i64 %32, 1
  store i64 %33, ptr %idx, align 8
  br label %switch.done

switch.case.body2:                                ; preds = %typeswitch.body1
  %34 = load i64, ptr %tag_ptr, align 8
  %35 = inttoptr i64 %34 to ptr
  %36 = load i16, ptr %35, align 2
  %37 = zext i16 %36 to i64
  %38 = sub i64 %37, 1
  store i64 %38, ptr %idx, align 8
  br label %switch.done

switch.case.body3:                                ; preds = %typeswitch.body1
  %39 = load i64, ptr %tag_ptr, align 8
  %40 = inttoptr i64 %39 to ptr
  %41 = load i32, ptr %40, align 4
  %42 = zext i32 %41 to i64
  %43 = sub i64 %42, 1
  store i64 %43, ptr %idx, align 8
  br label %switch.done

switch.case.body4:                                ; preds = %typeswitch.body1
  %44 = load i64, ptr %tag_ptr, align 8
  %45 = inttoptr i64 %44 to ptr
  %46 = load i64, ptr %45, align 8
  %47 = sub i64 %46, 1
  store i64 %47, ptr %idx, align 8
  br label %switch.done

switch.case.body5:                                ; preds = %typeswitch.body1
  %48 = load i64, ptr %tag_ptr, align 8
  %49 = inttoptr i64 %48 to ptr
  %50 = load i128, ptr %49, align 16
  %51 = trunc i128 %50 to i64
  %52 = sub i64 %51, 1
  store i64 %52, ptr %idx, align 8
  br label %switch.done

switch.done:                                      ; preds = %switch.case.body5, %switch.case.body4, %switch.case.body3, %switch.case.body2, %switch.case.body, %typeswitch.body1
  %53 = load i64, ptr %idx, align 8
  %54 = icmp slt i64 %53, 0
  %55 = zext i1 %54 to i8
  %56 = icmp ne i8 %55, 0
  br i1 %56, label %if.then6, label %if.else

if.then6:                                         ; preds = %switch.done
  ret i64 0

if.else:                                          ; preds = %switch.done
  %57 = load i64, ptr %idx, align 8
  %58 = getelementptr inbounds nuw %"runtime::Type_Info_Union", ptr %4, i32 0, i32 0
  %59 = getelementptr inbounds nuw { ptr, i64 }, ptr %58, i32 0, i32 1
  %60 = load i64, ptr %59, align 8
  %61 = icmp slt i64 %57, %60
  %62 = zext i1 %61 to i8
  %63 = icmp ne i8 %62, 0
  br i1 %63, label %if.then7, label %if.done8

if.then7:                                         ; preds = %if.else
  %64 = getelementptr inbounds nuw %"runtime::Type_Info_Union", ptr %4, i32 0, i32 0
  %65 = getelementptr inbounds nuw { ptr, i64 }, ptr %64, i32 0, i32 0
  %66 = load ptr, ptr %65, align 8
  %67 = load i64, ptr %idx, align 8
  %68 = getelementptr inbounds nuw { ptr, i64 }, ptr %64, i32 0, i32 1
  %69 = load i64, ptr %68, align 8
  call void @"runtime::bounds_check_error"(ptr @"ggv$runtime::type_assertion_check2.variant_type-0$1", i32 209, i32 24, i64 %67, i64 %69)
  %70 = getelementptr ptr, ptr %66, i64 %67
  %71 = load ptr, ptr %70, align 8
  %72 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %71, i32 0, i32 4
  %73 = load i64, ptr %72, align 8
  ret i64 %73

if.done8:                                         ; preds = %if.else
  br label %if.done9

if.done9:                                         ; preds = %if.done8
  br label %typeswitch.done

typeswitch.done:                                  ; preds = %if.done9, %if.done
  ret i64 %0
}

; Function Attrs: cold noreturn
define void @"runtime::type_assertion_check2.handle_error-1"(ptr %0, i32 %1, i32 %2, i64 %3, i64 %4, ptr %5) #7 {
decls:
  %6 = alloca %..string, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca ptr, align 8
  %actual = alloca i64, align 8
  %12 = alloca %"runtime::Source_Code_Location", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %6, ptr %0, i64 16, i1 false)
  store i32 %1, ptr %7, align 4
  store i32 %2, ptr %8, align 4
  store i64 %3, ptr %9, align 8
  store i64 %4, ptr %10, align 8
  store ptr %5, ptr %11, align 8
  %13 = call i64 @"runtime::type_assertion_check2.variant_type-0"(i64 %3, ptr %5)
  store i64 %13, ptr %actual, align 8
  call void @llvm.memset.p0.i64(ptr %12, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %12, i8 0, i64 40, i1 false)
  %14 = load %..string, ptr %6, align 8
  %15 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %12, i32 0, i32 0
  store %..string %14, ptr %15, align 8
  %16 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %12, i32 0, i32 1
  store i32 %1, ptr %16, align 4
  %17 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %12, i32 0, i32 2
  store i32 %2, ptr %17, align 4
  call void @"runtime::print_caller_location"(ptr %12)
  %18 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::type_assertion_check2.handle_error-1$1")
  call void @"runtime::print_typeid"(i64 %3)
  %19 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::type_assertion_check2.handle_error-1$2")
  call void @"runtime::print_typeid"(i64 %4)
  %20 = load i64, ptr %actual, align 8
  %21 = icmp ne i64 %20, %3
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %24 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::type_assertion_check2.handle_error-1$3")
  %25 = load i64, ptr %actual, align 8
  call void @"runtime::print_typeid"(i64 %25)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %26 = call i64 @"runtime::print_byte"(i8 10)
  call void @"runtime::type_assertion_trap"()
  unreachable
}

; Function Attrs: nounwind
define internal i64 @"__$hasher-3143511548502526014"(ptr nonnull %0, i64 %1) #8 {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %h.i = alloca i64, align 8
  %p.i = alloca ptr, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.lifetime.start.p0(i64 8, ptr %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %h.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %p.i)
  call void @llvm.lifetime.start.p0(i64 8, ptr %5)
  call void @llvm.lifetime.start.p0(i64 8, ptr %6)
  call void @llvm.lifetime.start.p0(i64 8, ptr %7)
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  store i64 8, ptr %4, align 8
  %8 = add i64 %1, -3750763034362895579
  store i64 %8, ptr %h.i, align 8
  store ptr %0, ptr %p.i, align 8
  store i64 0, ptr %5, align 8
  store i64 0, ptr %6, align 8
  br label %for.interval.loop.i

for.interval.loop.i:                              ; preds = %for.interval.body.i, %entry
  %9 = load i64, ptr %5, align 8
  %10 = icmp slt i64 %9, 8
  br i1 %10, label %for.interval.body.i, label %"runtime::default_hasher.exit"

for.interval.body.i:                              ; preds = %for.interval.loop.i
  %11 = load i64, ptr %h.i, align 8
  %12 = load ptr, ptr %p.i, align 8
  %13 = load i8, ptr %12, align 1
  %14 = zext i8 %13 to i64
  %15 = xor i64 %11, %14
  %16 = mul i64 %15, 1099511628211
  store i64 %16, ptr %h.i, align 8
  %17 = load ptr, ptr %p.i, align 8
  %18 = getelementptr i8, ptr %17, i64 1
  store ptr %18, ptr %7, align 8
  %19 = load ptr, ptr %7, align 8
  store ptr %19, ptr %p.i, align 8
  %20 = load i64, ptr %5, align 8
  %21 = add i64 %20, 1
  store i64 %21, ptr %5, align 8
  %22 = load i64, ptr %6, align 8
  %23 = add i64 %22, 1
  store i64 %23, ptr %6, align 8
  br label %for.interval.loop.i

"runtime::default_hasher.exit":                   ; preds = %for.interval.loop.i
  %24 = load i64, ptr %h.i, align 8
  %25 = and i64 %24, 9223372036854775807
  store i64 %25, ptr %h.i, align 8
  %26 = load i64, ptr %h.i, align 8
  %27 = load i64, ptr %h.i, align 8
  %28 = icmp eq i64 %27, 0
  %29 = zext i1 %28 to i64
  %30 = or i64 %26, %29
  call void @llvm.lifetime.end.p0(i64 8, ptr %2)
  call void @llvm.lifetime.end.p0(i64 8, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  call void @llvm.lifetime.end.p0(i64 8, ptr %h.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %p.i)
  call void @llvm.lifetime.end.p0(i64 8, ptr %5)
  call void @llvm.lifetime.end.p0(i64 8, ptr %6)
  call void @llvm.lifetime.end.p0(i64 8, ptr %7)
  ret i64 %30
}

; Function Attrs: nounwind
define internal i8 @"__$equal-3143511548502526014"(ptr nonnull %0, ptr nonnull %1) #8 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %2 = icmp eq ptr %0, %1
  br i1 %2, label %same_ptr, label %diff_ptr

same_ptr:                                         ; preds = %entry
  ret i8 1

diff_ptr:                                         ; preds = %entry
  %3 = load i64, ptr %0, align 8
  %4 = load i64, ptr %1, align 8
  %5 = icmp eq i64 %3, %4
  %6 = zext i1 %5 to i8
  ret i8 %6
}

; Function Attrs: cold noreturn
define void @"runtime::make_slice_error_loc.handle_error-0"(ptr %0, i64 %1) #7 {
decls:
  %2 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %1, ptr %2, align 8
  call void @"runtime::print_caller_location"(ptr %0)
  %3 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::make_slice_error_loc.handle_error-0$1")
  call void @"runtime::print_i64"(i64 %1)
  %4 = call i64 @"runtime::print_byte"(i8 10)
  call void @"runtime::bounds_trap"()
  unreachable
}

; Function Attrs: cold noreturn
define void @"runtime::make_dynamic_array_error_loc.handle_error-0"(ptr %0, i64 %1, i64 %2) #7 {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %1, ptr %3, align 8
  store i64 %2, ptr %4, align 8
  call void @"runtime::print_caller_location"(ptr %0)
  %5 = call i64 @"runtime::print_string"(ptr @"ggv$runtime::make_dynamic_array_error_loc.handle_error-0$1")
  call void @"runtime::print_i64"(i64 %1)
  %6 = call i64 @"runtime::print_byte"(i8 58)
  call void @"runtime::print_i64"(i64 %2)
  %7 = call i64 @"runtime::print_byte"(i8 10)
  call void @"runtime::bounds_trap"()
  unreachable
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.vector.reduce.or.v16i8(<16 x i8>) #5

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.vector.reduce.umin.v16i8(<16 x i8>) #5

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.vector.reduce.or.v8i8(<8 x i8>) #5

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.vector.reduce.umin.v8i8(<8 x i8>) #5

; Function Attrs: alwaysinline
define i64 @"runtime::map_total_allocation_size.round-0"(i64 %0) #1 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = add i64 %0, 63
  %3 = and i64 %2, -64
  ret i64 %3
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
declare i8 @llvm.expect.i8(i8, i8) #9

; Function Attrs: cold noreturn nounwind memory(inaccessiblemem: write)
declare void @llvm.trap() #10

; Function Attrs: alwaysinline
define i64 @"runtime::map_reserve_dynamic.ceil_log2-0"(i64 %0) #1 {
decls:
  %1 = alloca i64, align 8
  %z = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = call i64 @llvm.ctlz.i64(i64 %0, i1 false)
  store i64 %2, ptr %z, align 8
  %3 = load i64, ptr %z, align 8
  %4 = icmp ugt i64 %3, 0
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %7 = sub i64 %0, 1
  %8 = and i64 %0, %7
  %9 = icmp ne i64 %8, 0
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  %12 = load i64, ptr %z, align 8
  %13 = sub i64 %12, 1
  store i64 %13, ptr %z, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %cmp.and, %entry
  %14 = load i64, ptr %z, align 8
  %15 = sub i64 63, %14
  ret i64 %15
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i128 @llvm.ctlz.i128(i128, i1 immarg) #5

; Function Attrs: cold
define void @"runtime::assert.internal-0"(ptr %0, ptr %1, ptr noalias nocapture nonnull %__.context_ptr) #11 {
decls:
  %2 = alloca %..string, align 8
  %p = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %0, i64 16, i1 false)
  %3 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 2
  %4 = load ptr, ptr %3, align 8
  store ptr %4, ptr %p, align 8
  %5 = load ptr, ptr %p, align 8
  %6 = icmp eq ptr %5, null
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store ptr @"runtime::default_assertion_failure_proc", ptr %p, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %9 = load ptr, ptr %p, align 8
  call void %9(ptr @"ggv$runtime::assert.internal-0$1", ptr %2, ptr %1, ptr %__.context_ptr)
  unreachable
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare i64 @llvm.readcyclecounter() #12

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)
declare void @llvm.experimental.noalias.scope.decl(metadata) #13

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #14

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #14

attributes #0 = { noreturn }
attributes #1 = { alwaysinline }
attributes #2 = { noinline }
attributes #3 = { noinline optsize }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #5 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #6 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #7 = { cold noreturn }
attributes #8 = { nounwind }
attributes #9 = { nocallback nofree nosync nounwind willreturn memory(none) }
attributes #10 = { cold noreturn nounwind memory(inaccessiblemem: write) }
attributes #11 = { cold }
attributes #12 = { nocallback nofree nosync nounwind willreturn }
attributes #13 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #14 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!0 = !{!1}
!1 = distinct !{!1, !2, !"runtime::mem_alloc: argument 0"}
!2 = distinct !{!2, !"runtime::mem_alloc"}
!3 = !{!4}
!4 = distinct !{!4, !2, !"runtime::mem_alloc: %__.context_ptr"}
!5 = !{!1, !4}
!6 = !{!7}
!7 = distinct !{!7, !8, !"runtime::mem_free: %__.context_ptr"}
!8 = distinct !{!8, !"runtime::mem_free"}
!9 = !{!10}
!10 = distinct !{!10, !11, !"runtime::[default_temp_allocator_arena.odin]::safe_add: argument 0"}
!11 = distinct !{!11, !"runtime::[default_temp_allocator_arena.odin]::safe_add"}
!12 = !{!13}
!13 = distinct !{!13, !14, !"runtime::[default_temp_allocator_arena.odin]::safe_add: argument 0"}
!14 = distinct !{!14, !"runtime::[default_temp_allocator_arena.odin]::safe_add"}
!15 = !{!16}
!16 = distinct !{!16, !17, !"runtime::map_clear_dynamic: argument 0"}
!17 = distinct !{!17, !"runtime::map_clear_dynamic"}
!18 = !{!19}
!19 = distinct !{!19, !17, !"runtime::map_clear_dynamic: argument 1"}
!20 = !{!16, !19}
!21 = !{!22}
!22 = distinct !{!22, !23, !"runtime::_mem_resize: argument 0"}
!23 = distinct !{!23, !"runtime::_mem_resize"}
!24 = !{!25}
!25 = distinct !{!25, !23, !"runtime::_mem_resize: %__.context_ptr"}
!26 = !{!22, !25}
!27 = !{!28}
!28 = distinct !{!28, !29, !"runtime::_mem_resize: argument 0"}
!29 = distinct !{!29, !"runtime::_mem_resize"}
!30 = !{!31}
!31 = distinct !{!31, !29, !"runtime::_mem_resize: %__.context_ptr"}
!32 = !{!28, !31}
!33 = !{!34}
!34 = distinct !{!34, !35, !"runtime::mem_free_with_size: %__.context_ptr"}
!35 = distinct !{!35, !"runtime::mem_free_with_size"}
!36 = !{!37}
!37 = distinct !{!37, !38, !"runtime::mem_free: %__.context_ptr"}
!38 = distinct !{!38, !"runtime::mem_free"}
!39 = !{!40}
!40 = distinct !{!40, !41, !"runtime::mem_free_with_size: %__.context_ptr"}
!41 = distinct !{!41, !"runtime::mem_free_with_size"}
!42 = !{!43}
!43 = distinct !{!43, !44, !"runtime::mem_free_with_size: %__.context_ptr"}
!44 = distinct !{!44, !"runtime::mem_free_with_size"}
!45 = !{!46}
!46 = distinct !{!46, !47, !"runtime::mem_free_with_size: %__.context_ptr"}
!47 = distinct !{!47, !"runtime::mem_free_with_size"}
!48 = !{!49}
!49 = distinct !{!49, !50, !"runtime::mem_free_with_size: %__.context_ptr"}
!50 = distinct !{!50, !"runtime::mem_free_with_size"}
!51 = !{!52}
!52 = distinct !{!52, !53, !"runtime::mem_free_with_size: %__.context_ptr"}
!53 = distinct !{!53, !"runtime::mem_free_with_size"}
!54 = !{!55}
!55 = distinct !{!55, !56, !"runtime::mem_free_with_size: %__.context_ptr"}
!56 = distinct !{!56, !"runtime::mem_free_with_size"}
!57 = !{!58}
!58 = distinct !{!58, !59, !"runtime::mem_free_with_size: %__.context_ptr"}
!59 = distinct !{!59, !"runtime::mem_free_with_size"}
!60 = !{!61}
!61 = distinct !{!61, !62, !"runtime::mem_free_with_size: %__.context_ptr"}
!62 = distinct !{!62, !"runtime::mem_free_with_size"}
!63 = !{!64}
!64 = distinct !{!64, !65, !"runtime::mem_free_with_size: %__.context_ptr"}
!65 = distinct !{!65, !"runtime::mem_free_with_size"}
!66 = !{!67}
!67 = distinct !{!67, !68, !"runtime::mem_alloc_bytes: argument 0"}
!68 = distinct !{!68, !"runtime::mem_alloc_bytes"}
!69 = !{!70}
!70 = distinct !{!70, !68, !"runtime::mem_alloc_bytes: %__.context_ptr"}
!71 = !{!67, !70}
!72 = !{!73}
!73 = distinct !{!73, !74, !"runtime::mem_alloc_bytes: argument 0"}
!74 = distinct !{!74, !"runtime::mem_alloc_bytes"}
!75 = !{!76}
!76 = distinct !{!76, !74, !"runtime::mem_alloc_bytes: %__.context_ptr"}
!77 = !{!73, !76}
!78 = !{!79}
!79 = distinct !{!79, !80, !"runtime::mem_alloc_bytes: argument 0"}
!80 = distinct !{!80, !"runtime::mem_alloc_bytes"}
!81 = !{!82}
!82 = distinct !{!82, !80, !"runtime::mem_alloc_bytes: %__.context_ptr"}
!83 = !{!79, !82}
!84 = !{!85}
!85 = distinct !{!85, !86, !"runtime::map_cell_index_dynamic: argument 0"}
!86 = distinct !{!86, !"runtime::map_cell_index_dynamic"}
!87 = !{!88}
!88 = distinct !{!88, !89, !"runtime::map_cell_index_dynamic: argument 0"}
!89 = distinct !{!89, !"runtime::map_cell_index_dynamic"}
!90 = !{!91}
!91 = distinct !{!91, !92, !"runtime::map_cell_index_dynamic: argument 0"}
!92 = distinct !{!92, !"runtime::map_cell_index_dynamic"}
!93 = !{!94}
!94 = distinct !{!94, !95, !"runtime::mem_alloc_bytes: argument 0"}
!95 = distinct !{!95, !"runtime::mem_alloc_bytes"}
!96 = !{!97}
!97 = distinct !{!97, !95, !"runtime::mem_alloc_bytes: %__.context_ptr"}
!98 = !{!94, !97}
!99 = !{!100}
!100 = distinct !{!100, !101, !"runtime::map_cell_index_dynamic: argument 0"}
!101 = distinct !{!101, !"runtime::map_cell_index_dynamic"}
!102 = !{!103}
!103 = distinct !{!103, !104, !"runtime::map_cell_index_dynamic: argument 0"}
!104 = distinct !{!104, !"runtime::map_cell_index_dynamic"}
!105 = !{!106}
!106 = distinct !{!106, !107, !"runtime::map_cell_index_dynamic: argument 0"}
!107 = distinct !{!107, !"runtime::map_cell_index_dynamic"}
!108 = !{!109}
!109 = distinct !{!109, !110, !"runtime::map_cell_index_dynamic: argument 0"}
!110 = distinct !{!110, !"runtime::map_cell_index_dynamic"}
!111 = !{!112}
!112 = distinct !{!112, !113, !"runtime::map_cell_index_dynamic: argument 0"}
!113 = distinct !{!113, !"runtime::map_cell_index_dynamic"}
!114 = !{!115}
!115 = distinct !{!115, !116, !"runtime::map_cell_index_dynamic: argument 0"}
!116 = distinct !{!116, !"runtime::map_cell_index_dynamic"}
!117 = !{!118}
!118 = distinct !{!118, !119, !"runtime::map_cell_index_dynamic: argument 0"}
!119 = distinct !{!119, !"runtime::map_cell_index_dynamic"}
!120 = !{!121}
!121 = distinct !{!121, !122, !"runtime::map_cell_index_dynamic: argument 0"}
!122 = distinct !{!122, !"runtime::map_cell_index_dynamic"}
!123 = !{!124}
!124 = distinct !{!124, !125, !"runtime::map_cell_index_dynamic: argument 0"}
!125 = distinct !{!125, !"runtime::map_cell_index_dynamic"}
!126 = !{!127}
!127 = distinct !{!127, !128, !"runtime::map_cell_index_dynamic: argument 0"}
!128 = distinct !{!128, !"runtime::map_cell_index_dynamic"}
!129 = !{!130}
!130 = distinct !{!130, !131, !"runtime::mem_alloc_non_zeroed: argument 0"}
!131 = distinct !{!131, !"runtime::mem_alloc_non_zeroed"}
!132 = !{!133}
!133 = distinct !{!133, !131, !"runtime::mem_alloc_non_zeroed: %__.context_ptr"}
!134 = !{!130, !133}
!135 = !{!136}
!136 = distinct !{!136, !137, !"runtime::map_clear_dynamic: argument 0"}
!137 = distinct !{!137, !"runtime::map_clear_dynamic"}
!138 = !{!139}
!139 = distinct !{!139, !137, !"runtime::map_clear_dynamic: argument 1"}
!140 = !{!136, !139}
!141 = !{!142}
!142 = distinct !{!142, !143, !"runtime::map_cell_index_dynamic: argument 0"}
!143 = distinct !{!143, !"runtime::map_cell_index_dynamic"}
!144 = !{!145}
!145 = distinct !{!145, !146, !"runtime::map_cell_index_dynamic: argument 0"}
!146 = distinct !{!146, !"runtime::map_cell_index_dynamic"}
!147 = !{!148}
!148 = distinct !{!148, !149, !"runtime::map_cell_index_dynamic: argument 0"}
!149 = distinct !{!149, !"runtime::map_cell_index_dynamic"}
!150 = !{!151}
!151 = distinct !{!151, !152, !"runtime::map_cell_index_dynamic: argument 0"}
!152 = distinct !{!152, !"runtime::map_cell_index_dynamic"}
!153 = !{!154}
!154 = distinct !{!154, !155, !"runtime::map_cell_index_dynamic: argument 0"}
!155 = distinct !{!155, !"runtime::map_cell_index_dynamic"}
!156 = !{!157}
!157 = distinct !{!157, !158, !"runtime::map_cell_index_dynamic: argument 0"}
!158 = distinct !{!158, !"runtime::map_cell_index_dynamic"}
!159 = !{!160}
!160 = distinct !{!160, !161, !"runtime::map_cell_index_dynamic: argument 0"}
!161 = distinct !{!161, !"runtime::map_cell_index_dynamic"}
!162 = !{!163}
!163 = distinct !{!163, !164, !"runtime::map_cell_index_dynamic: argument 0"}
!164 = distinct !{!164, !"runtime::map_cell_index_dynamic"}
!165 = !{!166}
!166 = distinct !{!166, !167, !"runtime::map_cell_index_dynamic: argument 0"}
!167 = distinct !{!167, !"runtime::map_cell_index_dynamic"}
!168 = !{!169}
!169 = distinct !{!169, !170, !"runtime::map_cell_index_dynamic: argument 0"}
!170 = distinct !{!170, !"runtime::map_cell_index_dynamic"}
!171 = !{!172}
!172 = distinct !{!172, !173, !"runtime::map_cell_index_dynamic: argument 0"}
!173 = distinct !{!173, !"runtime::map_cell_index_dynamic"}
!174 = !{!175}
!175 = distinct !{!175, !176, !"runtime::map_cell_index_dynamic: argument 0"}
!176 = distinct !{!176, !"runtime::map_cell_index_dynamic"}
!177 = !{!178}
!178 = distinct !{!178, !179, !"runtime::map_cell_index_dynamic: argument 0"}
!179 = distinct !{!179, !"runtime::map_cell_index_dynamic"}
!180 = !{!181}
!181 = distinct !{!181, !182, !"runtime::map_cell_index_dynamic: argument 0"}
!182 = distinct !{!182, !"runtime::map_cell_index_dynamic"}
!183 = !{!184}
!184 = distinct !{!184, !185, !"runtime::map_cell_index_dynamic: argument 0"}
!185 = distinct !{!185, !"runtime::map_cell_index_dynamic"}
!186 = !{!187}
!187 = distinct !{!187, !188, !"runtime::map_cell_index_dynamic: argument 0"}
!188 = distinct !{!188, !"runtime::map_cell_index_dynamic"}
!189 = !{!190}
!190 = distinct !{!190, !191, !"runtime::_reserve_dynamic_array: %__.context_ptr"}
!191 = distinct !{!191, !"runtime::_reserve_dynamic_array"}
!192 = !{!193}
!193 = distinct !{!193, !194, !"runtime::_reserve_dynamic_array: %__.context_ptr"}
!194 = distinct !{!194, !"runtime::_reserve_dynamic_array"}
!195 = !{!196}
!196 = distinct !{!196, !197, !"runtime::map_cell_index_dynamic: argument 0"}
!197 = distinct !{!197, !"runtime::map_cell_index_dynamic"}
!198 = !{!199}
!199 = distinct !{!199, !200, !"runtime::map_cell_index_dynamic: argument 0"}
!200 = distinct !{!200, !"runtime::map_cell_index_dynamic"}
!201 = !{!202}
!202 = distinct !{!202, !203, !"runtime::map_insert_hash_dynamic: argument 0"}
!203 = distinct !{!203, !"runtime::map_insert_hash_dynamic"}
!204 = !{!205}
!205 = distinct !{!205, !203, !"runtime::map_insert_hash_dynamic: argument 1"}
!206 = !{!207}
!207 = distinct !{!207, !203, !"runtime::map_insert_hash_dynamic: %__.context_ptr"}
!208 = !{!202, !205, !207}
!209 = !{!210}
!210 = distinct !{!210, !211, !"runtime::_append_elem: argument 0"}
!211 = distinct !{!211, !"runtime::_append_elem"}
!212 = !{!213}
!213 = distinct !{!213, !211, !"runtime::_append_elem: %__.context_ptr"}
!214 = !{!210, !213}
!215 = !{!216}
!216 = distinct !{!216, !217, !"runtime::_reserve_dynamic_array: %__.context_ptr"}
!217 = distinct !{!217, !"runtime::_reserve_dynamic_array"}
!218 = !{!216, !210}
!219 = !{!220}
!220 = distinct !{!220, !221, !"runtime::_append_elem: argument 0"}
!221 = distinct !{!221, !"runtime::_append_elem"}
!222 = !{!223}
!223 = distinct !{!223, !221, !"runtime::_append_elem: %__.context_ptr"}
!224 = !{!220, !223}
!225 = !{!226}
!226 = distinct !{!226, !227, !"runtime::_reserve_dynamic_array: %__.context_ptr"}
!227 = distinct !{!227, !"runtime::_reserve_dynamic_array"}
!228 = !{!226, !220}
!229 = !{!230}
!230 = distinct !{!230, !231, !"runtime::_append_elem: argument 0"}
!231 = distinct !{!231, !"runtime::_append_elem"}
!232 = !{!233}
!233 = distinct !{!233, !231, !"runtime::_append_elem: %__.context_ptr"}
!234 = !{!230, !233}
!235 = !{!236}
!236 = distinct !{!236, !237, !"runtime::_reserve_dynamic_array: %__.context_ptr"}
!237 = distinct !{!237, !"runtime::_reserve_dynamic_array"}
!238 = !{!236, !230}
!239 = !{!240}
!240 = distinct !{!240, !241, !"runtime::_append_elem: argument 0"}
!241 = distinct !{!241, !"runtime::_append_elem"}
!242 = !{!243}
!243 = distinct !{!243, !241, !"runtime::_append_elem: %__.context_ptr"}
!244 = !{!240, !243}
!245 = !{!246}
!246 = distinct !{!246, !247, !"runtime::_reserve_dynamic_array: %__.context_ptr"}
!247 = distinct !{!247, !"runtime::_reserve_dynamic_array"}
!248 = !{!246, !240}
!249 = !{!250}
!250 = distinct !{!250, !251, !"runtime::_append_elem: argument 0"}
!251 = distinct !{!251, !"runtime::_append_elem"}
!252 = !{!253}
!253 = distinct !{!253, !251, !"runtime::_append_elem: %__.context_ptr"}
!254 = !{!250, !253}
!255 = !{!256}
!256 = distinct !{!256, !257, !"runtime::_reserve_dynamic_array: %__.context_ptr"}
!257 = distinct !{!257, !"runtime::_reserve_dynamic_array"}
!258 = !{!256, !250}
!259 = !{!260}
!260 = distinct !{!260, !261, !"runtime::_append_elems: argument 0"}
!261 = distinct !{!261, !"runtime::_append_elems"}
!262 = !{!263}
!263 = distinct !{!263, !261, !"runtime::_append_elems: %__.context_ptr"}
!264 = !{!260, !263}
!265 = !{!266}
!266 = distinct !{!266, !267, !"runtime::_reserve_dynamic_array: %__.context_ptr"}
!267 = distinct !{!267, !"runtime::_reserve_dynamic_array"}
!268 = !{!266, !260}
!269 = !{!270}
!270 = distinct !{!270, !271, !"runtime::map_cell_index_dynamic: argument 0"}
!271 = distinct !{!271, !"runtime::map_cell_index_dynamic"}
!272 = !{!273}
!273 = distinct !{!273, !274, !"runtime::map_cell_index_dynamic: argument 0"}
!274 = distinct !{!274, !"runtime::map_cell_index_dynamic"}
!275 = !{!276}
!276 = distinct !{!276, !277, !"runtime::map_cell_index_dynamic: argument 0"}
!277 = distinct !{!277, !"runtime::map_cell_index_dynamic"}
!278 = !{!279}
!279 = distinct !{!279, !280, !"runtime::map_cell_index_dynamic: argument 0"}
!280 = distinct !{!280, !"runtime::map_cell_index_dynamic"}
!281 = !{!282}
!282 = distinct !{!282, !283, !"runtime::map_cell_index_dynamic: argument 0"}
!283 = distinct !{!283, !"runtime::map_cell_index_dynamic"}
!284 = !{!285}
!285 = distinct !{!285, !286, !"runtime::mem_free_with_size: %__.context_ptr"}
!286 = distinct !{!286, !"runtime::mem_free_with_size"}
!287 = !{!288}
!288 = distinct !{!288, !289, !"runtime::[internal.odin]::byte_slice: %agg.result"}
!289 = distinct !{!289, !"runtime::[internal.odin]::byte_slice"}
